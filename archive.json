{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2022-08-28T01:03:06.879974+00:00",
  "repo": "cfrg/draft-irtf-cfrg-vdaf",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "draft-01",
      "description": "",
      "color": "F6C11D"
    },
    {
      "name": "draft-02",
      "description": "",
      "color": "019C33"
    },
    {
      "name": "draft-03",
      "description": "",
      "color": "5C9ACE"
    },
    {
      "name": "editorial",
      "description": "",
      "color": "F2C540"
    }
  ],
  "issues": [
    {
      "number": 8,
      "id": "I_kwDOGKuqOc4-qH_-",
      "title": "Syntax: Use agg parameter for prepare-init only",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/8",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This aggregation parameter isn't used anywhere but during the preparation phase. We may wind up wanting to specify a scheme that needs this, at which point we can add this back in. For now, removing this unnecessary joint will simplify the syntax.",
      "createdAt": "2021-11-11T18:01:23Z",
      "updatedAt": "2021-12-28T17:43:25Z",
      "closedAt": "2021-12-28T17:43:25Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "The aggregation parameter is used in hits in order to decode output shares and aggregate shares. Upon further reflection, it seems like we'll need something like this going forward.",
          "createdAt": "2021-12-28T17:43:25Z",
          "updatedAt": "2021-12-28T17:43:25Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOGKuqOc4-qq61",
      "title": "Can / should VDAF support DP shufflers?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/9",
      "state": "OPEN",
      "author": "csharrison",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Shuffle differential privacy (https://arxiv.org/pdf/1811.12469.pdf and many other papers) is a type of differential privacy where the privacy mechanism can be thought of as a composition of two pieces:\r\n1. A local randomizer applying some local noise to data (and stripping identifiers, etc)\r\n2. A central curator that takes as input a batch of client data and simply applies a permutation on it\r\n\r\nThe power of the shuffle DP is that the server-side mechanism is _simple_ and _general purpose_. The exact same shuffler can be used for different applications measuring different kinds of things. Privacy guarantees are based on two things:\r\n\r\n1. The level of local noise added to the data\r\n2. The number of clients that participate in a shuffle\r\n\r\nAt an intuitive level, the more reports you have, and the more noise is injected into the reports, the more a given client's input is \"hidden in the crowd\".\r\n\r\nIs this a good fit for VDAFs? Shuffling is conceptually a very simple task to ask a 2-party MPC protocol to do. I could imagine slotting this into the VDAF structure like:\r\n\r\n- Clients split their local data D into \"shares\" where Helper 1 gets Enc2(D) and Helper 2 gets Enc1(null). (Which helper gets the real message can be randomized). Note that nested encryption is used so that no helper can see any raw data before it is shuffled.\r\n- When each helper gets its batch of data, it will run it through a shuffle step, and send the shuffle results to the other helper\r\n- After the exchange, the helpers shuffle the exchanged batches one more time (ensuring all data is shuffled twice, once by each helper).\r\n- Helpers can then decrypt the data and share each shuffled batch to the collector\r\n\r\nPossible concerns:\r\n\r\n- In the simple example above, helpers learn a shuffled version of the true data (i.e. a DP release). The protocol is not zero-knowledge. This could probably be fixed, there is no need for helpers to learn any raw data.\r\n- We rely exclusively on DP for the protection. Whether this can be called \"aggregation\" is maybe subject for debate. Certainly you can say that (if the batches are large enough, with enough noise), that no individual's data can be learned\r\n- The splitting of shares and helpers independently shuffling partial batches is a bit awkward. Probably the ideal mechanism would be for clients to send all data to Helper 1, which shuffles and sends to Helper 2, which sends data to the collector. Parallel shuffling buys us nothing.\r\n- Some shuffle protocols may want some kind of \"label\" in the clear, with minimum batch sizes per label.\r\n\r\nAnyways, thoughts appreciated! Shuffling can be a simple and effective way to achieve good privacy with very simple mechanisms, but it doesn't fit so well into VDAFs.\r\n\r\ncc @schoppmp ",
      "createdAt": "2021-11-11T21:24:52Z",
      "updatedAt": "2021-11-16T18:36:01Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Interesting idea! This does indeed sound like a practical way to get good privacy. Even without DP, you get unlinkability of measurements to the client that sent them. This is basically what a mixnet does.\r\n\r\n* From a syntax perspective, this kind of construction doesn't fit because it requires the aggregation phase to be interactive. Currently the VDAF syntax permits interaction only during the preparation phase. More to the point, shuffling requires `O(n)` space to compute the aggregate result, where `n` is the number of measurements. On the other hand, evaluating the prio3 or hits VDAF requires just `O(1)` space.\r\n* From a security perspective, unlinkability of measurements to senders is useful, but is weaker than what we hope to achieve for, say, prio3 or hits, which is that they learn only the aggregate result. Perhaps there's a way to patch the scheme to prevent leaking the set of measurements, as you suggest. But suppose we manage to ensure that all the aggregators learn is the aggregate result: then what does shuffling buy us?\r\n* Broadening our perspective a bit, consider that VDAFs are *special purpose*  in the sense that a particular VDAF is only suitable for as particular (class of) aggregation functions. On the other hand, the shuffling scheme you're proposing is *general purpose*: pretty much any aggregation function can be computed this way, you just need to be able to define a \"null\" input. I think the purpose of this document should be to standardize an interface between general purpose \"wrapper\" protocols, like PPM, to special purpose schemes that are all ensure some baseline notion of security.\r\n\r\nMy own conclusion is that this protocol shape isn't appropriate for the VDAF document, however this may well be in-scope for what the PPM working group does.\r\n\r\nWhat do you think @bifurcation?",
          "createdAt": "2021-11-15T17:55:34Z",
          "updatedAt": "2021-11-15T17:55:34Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "By the way, I'm reading https://eprint.iacr.org/2021/1490.pdf right now. This protocol seems to have some shuffling, but also seems to aim for a security property stronger than unlinkability. I think if we can achieve the same security for this protocol as for prio3/hits, I think it's worth considering including it here.",
          "createdAt": "2021-11-15T19:42:22Z",
          "updatedAt": "2021-11-15T19:42:22Z"
        },
        {
          "author": "csharrison",
          "authorAssociation": "NONE",
          "body": "Thanks @cjpatton , this makes sense to me. A few quick responses below:\r\n\r\n> From a security perspective, unlinkability of measurements to senders is useful, but is weaker than what we hope to achieve for, say, prio3 or hits, which is that they learn only the aggregate result. Perhaps there's a way to patch the scheme to prevent leaking the set of measurements, as you suggest. But suppose we manage to ensure that all the aggregators learn is the aggregate result: then what does shuffling buy us?\r\n\r\nOne thing shuffling buys you is flexibility. Let's say all my users input data in [0, 10]. You could imagine a couple of different ways of aggregating this data, e.g. reporting the sum, median, percentiles, etc. With a shuffled version of the data, you can compute all of these on the collector side without embedding the computations in the aggregators.\r\n\r\nThere is also flexibility in terms of data used. In principle (as long as you trust the clients), the aggregators can just be shuffling opaque bytes. Clients could update to submit different kinds of data without any behavior update needed on the aggregator side. For instance, rather than shuffling integers they could shuffle sketches or some other data structure.\r\n\r\n> By the way, I'm reading https://eprint.iacr.org/2021/1490.pdf right now. This protocol seems to have some shuffling, but also seems to aim for a security property stronger than unlinkability. I think if we can achieve the same security for this protocol as for prio3/hits, I think it's worth considering including it here.\r\n\r\nThis proposal is interesting but it isn't the same kind of general purpose shuffling I'm discussing here. That paper only discusses computing histograms.",
          "createdAt": "2021-11-15T20:27:02Z",
          "updatedAt": "2021-11-15T20:27:02Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree the flexibility is attractive. My point about shuffling alone doesn't prevent aggregators from learning the set of measurements. Indeed, this is what makes it so flexible!",
          "createdAt": "2021-11-15T21:30:45Z",
          "updatedAt": "2021-11-15T21:30:45Z"
        },
        {
          "author": "csharrison",
          "authorAssociation": "NONE",
          "body": "> I agree the flexibility is attractive. My point about shuffling alone doesn't prevent aggregators from learning the set of measurements. Indeed, this is what makes it so flexible!\r\n\r\nOh sorry I missed this point. It should be easy to ensure that the shuffled data is not visible to the aggregators if they don't collude with the collector - just ensure all the data is also encrypted to the collector's key. The requirement is just that the MPC shuffles opaque blobs.",
          "createdAt": "2021-11-15T21:58:47Z",
          "updatedAt": "2021-11-15T21:58:47Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, but the collector would see the set of measurements in the clear, right? All the aggregators have done is permuted them.",
          "createdAt": "2021-11-15T22:18:58Z",
          "updatedAt": "2021-11-15T22:18:58Z"
        },
        {
          "author": "csharrison",
          "authorAssociation": "NONE",
          "body": "The collector sees the set of measurements \"in the clear\", but the technique is designed to be combined with local noise so it isn't really accurate to say that the final release contains the all of the original measurements.\r\n\r\n",
          "createdAt": "2021-11-16T18:29:12Z",
          "updatedAt": "2021-11-16T18:29:12Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, true enough!",
          "createdAt": "2021-11-16T18:36:01Z",
          "updatedAt": "2021-11-16T18:36:01Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOGKuqOc4-1Uh5",
      "title": "Is Masked LARk a (V)DAF?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/10",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[This paper](https://arxiv.org/pdf/2110.14794.pdf) describes a distributed computation of a gradient descent. We're given a set of `(x[i], y[i])` pairs, where `x[i]` is client `i`'s *feature* and `y[i]` is the corresponding *label*. From skimming the paper, my understanding is that stochastic gradient descent is computed iteratively as\r\n```\r\n\\theta_{j+1} = \\theta_j - \\eta * (f(x[1], y[1], \\theta_j) + ... + f(x[n], y[n], \\theta_j))\r\n```\r\nuntil we find a (locally) optimal model `\\theta_j`.  for a particular function `f`. (`\\eta` is a constant called the \"learning rate\".) What the paper shows is that each iteration can be computed by two aggregators who hold the plaintext features `x[1], ..., x[n]`, but only secret shares of the labels `y[1], ..., y[n]`. The features are kept privacy by adding DP.\r\n\r\nThis looks an awful lot like a distributed aggregation function:\r\n* measurement is a feature and label\r\n* aggregation parameter is the model `\\theta_j` from the previous step.\r\n* aggregate result is the model `\\theta_{j+1}` for the next step.\r\n\r\nAnd yet there are two important differences:\r\n1. The label is secret shared, but the feature is not. We can certainly formalize security in the usual way --- the aggregators learn nothing about the measurements beyond what they can deduce from their view of the protocol. But this definition isn't all that meaningful if the feature leaks a lot of information about the label.\r\n2. The output isn't verifiable. In particular, the current protocol appears to allow a client to submit bogus input shares and garble the output without being detected.\r\n\r\nAdding verifiability (i.e., solving (2)) seems quite feasible. I'm not sure how best to address (1). It might be worth reaching out to the papers' authors to see if they considered how they might keep the features secret.\r\n\r\n@csharrison I'm curious if you have thoughts here.",
      "createdAt": "2021-11-15T22:17:30Z",
      "updatedAt": "2022-04-06T20:34:52Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Another reference to drop here: https://eprint.iacr.org/2018/442.pdf",
          "createdAt": "2022-04-06T20:34:51Z",
          "updatedAt": "2022-04-06T20:34:51Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOGKuqOc4-5xna",
      "title": "Syntax: Public preprocessing during the preparation phase",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/11",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "For both prio3 and hits, each round of the preparation phase consists of a step of \"preprocessing\" of the previous round's messages. This preprocessing step is identical for all of the aggregators. In hits, for example, each aggregator begins each round by summing up the messages from the previous round. From Figure 15 in https://cjpatton.github.io/vdaf/draft-patton-cfrg-vdaf.html#name-preparation-3:\r\n```\r\n    ...\r\n    elif self.step == \"sketch round 1\" and len(inbound) == 2:\r\n      verifier_1 = Field[l].deocde_vec(inbound[0]) + \\             # ADD UP INPUT MESSAGES\r\n                   Field[l].deocde_vec(inbound[1])\r\n\r\n      verifier_share_2 = [\r\n        (verifier_1[0] * verifier_1[0] \\\r\n         - verifier_1[1] \\\r\n         - verifier_1[2]) * self.party_id \\\r\n        + A_share * verifer_1[0] \\\r\n        + B_share\r\n      ]\r\n\r\n      self.step = \"sketch round 2\"\r\n      return Field[l].encode_vec(verifier_share_2)\r\n\r\n    elif self.step == \"sketch round 2\" and len(inbound) == 2:\r\n      verifier_2 = Field[l].decode_vec(inbound[0]) + \\             # ADD UP INPUT MESSAGES\r\n                   Field[l].decode_vec(inbound[1])\r\n\r\n      if verifier_2 != 0: raise ERR_INVALID\r\n      return Field[l].encode_vec(self.output_share)\r\n   ...\r\n```\r\nThe essence of what's happening here is that, in each round, the aggregators are exchanging additive shares of a single message. prio3 is similar, although each message consists of an XOR-share of as byte string and an additive share of the FLP verifier. From Figure 10:\r\n```\r\n   ...\r\n   elif self.step == \"waiting\" and len(inbound) == SHARES:\r\n      k_joint_rand = zeros(KEY_SIZE)\r\n      verifier = vec_zeros(VERIFIER_LEN)\r\n      for r_share in inbound:\r\n        (k_joint_rand_share,\r\n         verifier_share) = decode_verifier_share(r_share)\r\n\r\n        k_joint_rand ^= k_joint_rand_share                           # ADD UP xor SHARES\r\n        verifer += verifier_share                                    # ADD UP ADDITIVE SHARES\r\n\r\n      if k_joint_rand != self.k_joint_rand: raise ERR_INVALID\r\n      if not flp_decide(verifier): raise ERR_INVALID\r\n      return Field.encode_vec(self.output_share)\r\n   ...\r\n```\r\nWhat we're likely to do in the PPM protocol is have one aggregator -- the Leader -- collect the verifier messages at each round and relay them to the other aggregators. We could save on communication cost if we have the Leader perform this public preprocessing step itself and disseminate the result.\r\n\r\nTo make this optimization generic, I'd like to propose that we lift the public processing step to an explicit part of the syntax. In particular, we'd change the preparation phase as follows (from Figure 6):\r\n```\r\n   # Each aggregator initializes its preparation state.\r\n    prep_states = []\r\n    for j in range(SHARES):\r\n      prep_states.append(PrepState(\r\n          verify_params[j], agg_param, nonce, input_shares[j]))\r\n\r\n    # Aggregators recover their output shares.\r\n-   inbound = []\r\n+   inbound = \"\"\r\n    for i in range(ROUNDS+1):\r\n      outbound = []\r\n      for j in range(SHARES):\r\n        outbound.append(prep_states[j].next(inbound))\r\n      # This is where we would send messages over the network\r\n      # in a distributed VDAF computation.\r\n-     inbound = outbound\r\n+     inbound = prep_preprocess(j, outbound)\r\n\r\n    # The final outputs of validation are the output shares\r\n    # for this input.\r\n    output_shares.append(outbound)\r\n```\r\n\r\nI don't think this syntactic change would decrease generality, but I also don't want it to be a nuisance. Maybe it makes sense to not call this out explicitly?",
      "createdAt": "2021-11-16T21:12:25Z",
      "updatedAt": "2022-01-19T17:44:43Z",
      "closedAt": "2022-01-19T17:44:43Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I actually think this could *increase* generality, since we're adding a stage that transforms outbound shares to some inbound parameter.  In the current framing, that stage has to be the identity transformation, such that the inbound parameter is the set of outbound shares.\r\n\r\nThe only real trouble I see here is that we don't currently have a name for the actor who would perform this transformation.  And just to confirm -- is this actor really untrusted in the examples we have today?  Or are they trusted in some limited way?",
          "createdAt": "2021-11-17T16:03:32Z",
          "updatedAt": "2021-11-17T16:03:32Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Who performs this transform will depend on how the VDAF is mapped to a protocol. It ought to be the case that *anyone* can perform this transform without impacting privacy. (We'll need to make this clear in security considerations.)",
          "createdAt": "2021-11-17T17:09:01Z",
          "updatedAt": "2021-11-17T17:09:01Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">What we're likely to do in the PPM protocol is have one aggregator -- the Leader -- collect the verifier messages at each round and relay them to the other aggregators. We could save on communication cost if we have the Leader perform this public preprocessing step itself and disseminate the result.\r\n\r\nI think this is a good optimization but IIUC it requires that the PPM leader be able to see all the verifier messages (i.e., Prio proof shares) in the clear, which isn't currently possible because the helper's proof share is inside the HPKE encrypted envelope. So does this change require corresponding PPM changes to move verifier shares out of the encryption envelope, or am I misunderstanding?",
          "createdAt": "2022-01-04T22:38:55Z",
          "updatedAt": "2022-01-04T22:38:55Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "What is being preprocessed is the set of messages passed between the Aggregators, which is not the proof shares. The proof shares are sent by the Clients to the Aggregators. If the Aggregators were to exchanges the proof shares themselves, this would result in a security violation.",
          "createdAt": "2022-01-04T23:06:11Z",
          "updatedAt": "2022-01-04T23:06:11Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The important thing is that this only reduces the complexity of communication if there are more than two aggregators, which is not currently the case in PPM. It's nevertheless a good change.",
          "createdAt": "2022-01-05T01:47:38Z",
          "updatedAt": "2022-01-05T01:47:38Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOGKuqOc4-98yb",
      "title": "VDAF for quantiles?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/12",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "With `prio3` it's straightforward to roughly estimate quantiles using a histogram (cf https://docs.rs/prio/0.6.1/prio/vdaf/prio3/type.Prio3Histogram64.html). But what if you wanted to precisely compute, say, the 50th percentile (i.e., the median) or the 95th percentile? Prio isn't well-suited for this (cf [[CGB17], Appendix G]).\r\n\r\nIf your application allows for multiple rounds of interaction with the clients, maybe you could do a kind of binary search to find the quantile you're after. Suppose the client measurements are arbitrary 32-bit integers and you want to compute the median. Suppose there are `N` measurements in all. Let `buckets = [2^31]`. Have the clients shard their measurements using `buckets` as the bucket boundaries. Execute the VDAF over the set of input shares, getting bucket counts `agg` as the aggregate result. `agg[0]` is equal to the number of measurements less than or equal to `2^31`, and `agg[1] <= N/2`, then the median must be less than `2^31`. On the other hand, if `agg[1] > N/2` then you know the median must greater than `2^31`. You then repeat the process, adjusting the bucket boundaries based on the previous result: if the median is less than `2^31`, then let `buckets = [2^31 - 2^30]`; otherwise let `buckets = [2^31 + 2^30]`.\r\n\r\nI'm not sure how many iterations would be needed, or how precisely you could compute quantiles this way. Regardless, ideally there would be a VDAF that allows for computing quantiles without interacting with clients more than once.\r\n\r\n\r\n\r\n\r\n\r\n[CGB17]: https://crypto.stanford.edu/prio/paper.pdf",
      "createdAt": "2021-11-17T17:58:28Z",
      "updatedAt": "2022-07-11T22:24:52Z",
      "closedAt": null,
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In addition to histograms, Prio3 could be used to estimate quantiles by constructing a CountMin sketch. (See section 5.1 here https://dsf.berkeley.edu/cs286/papers/countmin-latin2004.pdf) I think this would also require some tuning based on expected measurement ranges and precision. The underlying FLP validity condition would be equivalent to running multiple independent histograms.\r\n\r\nPoplar1 could be used to exactly compute quantiles, at a higher computational cost. Assuming the measurements are already integers, you could directly shard the measurements with Poplar1, and then run the Poplar1 aggregation process several times with a new tree-walking algorithm to arrive at the quantile. This algorithm would do a binary search to find the tree node where the number of measurements to the left, divided by the total number of measurements, is the closest to the target quantile level.",
          "createdAt": "2022-07-11T22:24:52Z",
          "updatedAt": "2022-07-11T22:24:52Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOGKuqOc4_1qX5",
      "title": "Specify method for generating field elements (was \"Proposal: use hash to field to generate field elements from a seed\")",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/13",
      "state": "CLOSED",
      "author": "armfazh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "> TODO This functionality closely resembles what people usually think of as an extract-then-expand KDF, but differs somewhat in its syntax and, also, its required security properties. Can we get the same functionality from something that's more commonplace? HKDF doesn't fit the bill, unfortunately, because keys can only be expanded to a fairly short length. Our application requires a rather long key stream.\r\n\r\nand\r\n>    *  Field.rand_vec(len: Unsigned) -> output: Vec[Field] returns a\r\n      vector of random field elements.  The length of output MUST be\r\n      len.\r\n>\r\n>         NOTE In reality this would be achieved by generating a random\r\n         key and expanding it into a sequence of field elements using a\r\n         key derivation scheme.  This should probably be made explicit.\r\n\r\n\r\nIn hash to curve draft, there is a method to derive an arbitrary number of field elements from a seed source.\r\nThis is called a Expander, and there are two types: one based on Merkle-Damgard functions and the other based on eXtendable Output functions.\r\nSee section 5.3 : https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve#section-5.3\r\n\r\n",
      "createdAt": "2021-12-03T22:53:51Z",
      "updatedAt": "2022-02-25T19:42:16Z",
      "closedAt": "2022-02-25T19:42:16Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I definitely like the idea of reusing a functionality from an existing draft.",
          "createdAt": "2021-12-04T00:02:20Z",
          "updatedAt": "2021-12-04T00:02:20Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Update based on discussion I had with @armfazh offline: We currently use rejection sampling for mapping bit strings to field elements. This has the advantage of inducing no bias, but it has the distinct disadvantage of making the runtime very slow for some fraction of the time. We hope that a constant-time algorithm will have better worst-case, or even average-case, performance. @armfazh is working on a performance evaluation.\r\n\r\nhash-to-field is quite simple: just take a hash function `H: \\bits^* \\to \\bits^n`, interpret the output as a `2^n`-bit integer, and reduce the integer mod `p`. The question is how much bias this modular reduction induces.\r\n\r\nOr more precisely: What's the statistical distance between a random variable chosen uniformly from `[0, p)` and a random variable chosen by sampling `[0, 2^n)` for some `2^n > p` and reducing the sampled number mod `p`? Intuitively, this depends on how large is `b = 2^n % p`: the smaller the `b`, the fewer outputs there are due to the modular reduction. In fact, it's not hard to show that the statistical distance can be bounded, fairly tightly, by `O(2^(log2(p) - n)`. This suggests that for `n \\approx 2*log(p)` the statistical distance is about `O(1/2^log(p))`.\r\n\r\nWhat does this mean for security? In our analysis of prio3 it'll be helpful to model the function that maps a seed to a sequence of field elements as a random oracle. Our hope would be that hash-to-field is indifferentiable from such an RO when the underlying hash function `H` is modeled as an RO. This ought to be the case for sufficiently large `n`.\r\n\r\nWe also observed that there are primes `p` for which there is an optimal `n`. For example, libprio uses `p = 18446744069414584321` for its 64-bit prime. It turns out that `2^192 % p == 1`, so picking `n=192` would make the distributions very close indeed. Ideally we could find a 128-bit prime with this property, too.",
          "createdAt": "2022-02-02T00:28:54Z",
          "updatedAt": "2022-02-02T00:28:54Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@schoppmp made an excellent point, which we ought to take into account: hash_to_field appears to be designed for entropy extraction. (@armfazh can you confirm?). However for our application we don't need an entropy extractor because we're starting with a (pseuo)random seed. Thus using SHA-2 or SHAKE for instantiating hash_to_field would be overkill: AES in CTR-mode would suite our needs perfectly fine.",
          "createdAt": "2022-02-03T18:43:38Z",
          "updatedAt": "2022-02-03T18:43:38Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Certainly, any SHA or SHAKE will be slower than AES (provided machine has hardware support for it). \r\nHash to field just receives seeds as input, and is not used for key expansion.",
          "createdAt": "2022-02-03T21:36:38Z",
          "updatedAt": "2022-02-03T21:36:38Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, and given how much randomness we consume in our applications, I think it would be worthwhile providing a mapping a seed-to-field-vector expansion function that is based purely on AES. I'll put together a PR with a proposal.",
          "createdAt": "2022-02-04T17:05:54Z",
          "updatedAt": "2022-02-04T17:05:54Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Ok, before sending a PR, I want to get y'all's take on the over all shape of the solution. Here's my proposal:\r\n1. Add a parameter `EXPANDED_SIZE` to `Field` that specifies the number of random bytes that are sampled per field element.\r\n2. Adopt a modified version of `hash_to_field` in which we replace `expand_message` with the key stream output by AES-CTR (or some other, compatible primitive).\r\n\r\nThis could look something like this (quoting from https://github.com/cjpatton/vdaf/pull/24):\r\n```python\r\n# The base class for PRGs.\r\nclass Prg:\r\n    # Size of the seed.\r\n    SEED_SIZE: int\r\n\r\n    # Derive a fresh seed from an existing `seed`. The `info` input is used for\r\n    # domain sepration.\r\n    @classmethod\r\n    def derive(cls, seed: bytes, info: bytes) -> bytes:\r\n        raise Error(\"not implemented\")\r\n\r\n    # Expand the input `seed` into the number of bytes requested.\r\n    @classmethod\r\n    def expand(cls, seed: bytes, length: int) -> bytes:\r\n        raise Error(\"not implemented\")\r\n\r\n    # Expand the input `seed` into vector of `length` field elements. This\r\n    # algorithm is based on \"hash_to_field\" in draft-irtf-cfrg-hash-to-curve13.\r\n    @classmethod\r\n    def expand_into_vec(cls, Field, seed: bytes, length: int):\r\n        L = Field.EXPANDED_SIZE\r\n        len_in_bytes = length * L\r\n        uniform_bytes = cls.expand(seed, len_in_bytes)\r\n\r\n        vec = []\r\n        for i in range(length):\r\n            tv = uniform_bytes[L*i:L*(i+1)]\r\n            u_i = OS2IP(tv) # Decode `tv` into an integer.\r\n            vec.append(Field(u_i))\r\n        return vec\r\n```\r\n\r\n@schoppmp what do you think of this proposal? Of course, we wouldn't literally plop down this Python into the spec :) A concrete PRG would implement `derive` and `expand`. For example:\r\n\r\n```python\r\n# A pseudorandom generator based on AES128. CMAC {{!RFC4493}} is used for seed\r\n# derivation and CTR mode is used for seed expansion.\r\nclass PrgAes128(Prg):\r\n    # Associated parameters\r\n    SEED_SIZE = 16\r\n\r\n    @classmethod\r\n    def derive(cls, seed, info) -> bytes:\r\n        hasher = CMAC.new(seed, ciphermod=AES)\r\n        return hasher.update(info).digest()\r\n\r\n    @classmethod\r\n    def expand(cls, seed, length):\r\n        counter = Counter.new(128, initial_value=bytes_to_long(zeros(16)))\r\n        cipher = AES.new(seed, AES.MODE_CTR, counter=counter)\r\n        # CTR-mode encryption of the all-zero string of the specified length and using\r\n        # the all-zero block as the IV.\r\n        cipher_stream = cipher.encrypt(zeros(length))\r\n        return cipher_stream\r\n```\r\n\r\nCMAC is a somewhat unconventional choice. A more conventional choice might be HMAC-SHA256, however in that case we might want to increase `SEED_SIZE` to `32`.",
          "createdAt": "2022-02-06T01:36:45Z",
          "updatedAt": "2022-02-06T01:57:22Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "PR #25 addresses the issue raised here. I ended up going in a slightly different direction with the API:\r\n```python\r\nclass Prg:\r\n    # Size of the seed.\r\n    SEED_SIZE: int\r\n\r\n    # Number of bytes sampled per pseudorandom field element.\r\n    EXPANDED_SIZE: int\r\n\r\n    # Expand the input `seed` into the number of bytes requested.\r\n    @classmethod\r\n    def expand(cls, seed: bytes, info: bytes, length: int) -> bytes:\r\n        raise Error(\"not implemented\")\r\n\r\n    # Derive a fresh seed from an existing one.\r\n    @classmethod\r\n    def derive(cls, seed: bytes, info: bytes) -> bytes:\r\n        return cls.expand(seed, info, cls.SEED_SIZE)\r\n\r\n    # Expand the input `seed` into vector of `length` field elements. This\r\n    # algorithm is based on \"hash_to_field\" in draft-irtf-cfrg-hash-to-curve13.\r\n    @classmethod\r\n    def expand_into_vec(cls, Field, seed: bytes, info: bytes, length: int):\r\n        L = Field.EXPANDED_SIZE\r\n        len_in_bytes = length * L\r\n        uniform_bytes = cls.expand(seed, info, len_in_bytes)\r\n\r\n        vec = []\r\n        for i in range(0, len(uniform_bytes), L):\r\n            tv = uniform_bytes[i:i+L]\r\n            x = OS2IP(tv)\r\n            vec.append(Field(x))\r\n        return vec\r\n```",
          "createdAt": "2022-02-08T01:21:33Z",
          "updatedAt": "2022-02-08T01:24:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "> @schoppmp made an excellent point, which we ought to take into account: hash_to_field appears to be designed for entropy extraction.\r\n\r\nFWIW, I don't think this is correct. ",
          "createdAt": "2022-02-08T13:54:36Z",
          "updatedAt": "2022-02-08T13:54:36Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton I don't think this approach works directly as you describe it. The reason is that if the field modulus p is small-ish (e.g., 32 bits), then just taking 32 uniform bits and reducing them mod p will result in something far from uniform. This is what hash_to_curve fixes by increasing L by the security parameter k. \r\n\r\nMy point was twofold: \r\n1. If we want to sample n prime field elements from a single seed, we don't need log(p) + k uniform bits for *every* element we sample, but something more on the order of log(p) * n + k + log(n) for *all* n samples. (Edit: Fixed the formula)\r\n2. If our seed is uniform, then using AES (either in counter mode or as a [hash function](https://eprint.iacr.org/2019/074.pdf)) might be cheaper than SHA(KE).\r\n\r\n@chris-wood Could you elaborate with which part you disagree?",
          "createdAt": "2022-02-08T17:13:43Z",
          "updatedAt": "2022-02-08T17:26:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "> @chris-wood Could you elaborate with which part you disagree?\r\n\r\nWith one exception, I don't disagree with anything you wrote in that comment. I was merely responding to the \"entropy extraction\" point, which is not an explicit goal of hash-to-field.\r\n\r\n> If our seed is uniform, then using AES (either in counter mode or as a [hash function](https://eprint.iacr.org/2019/074.pdf)) might be cheaper than SHA(KE).\r\n\r\nI may be misunderstanding you, but this seems like a non sequitur since `expand_message` will work for any input, regardless of its distribution. In any case, I think it's reasonable to require the seed to be uniformly distributed. And using a stream cipher instead of hash-based `expand_message` certainly seems like an improvement. (In fact, we should consider adding such variant to the hash-to-curve draft!)",
          "createdAt": "2022-02-08T17:18:44Z",
          "updatedAt": "2022-02-08T17:18:44Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> @schoppmp     1. If we want to sample n prime field elements from a single seed, we don't need log(p) + k uniform bits for _every_ element \r\nwe sample, but something more on the order of log(p) + n * k + log(n) for _all_ n samples.\r\n\r\nDo you mean `(log(p) + n) * k + log(n)` or `log(p) + (n * k) + log(n)`?\r\n",
          "createdAt": "2022-02-08T17:23:14Z",
          "updatedAt": "2022-02-08T17:23:14Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "> I may be misunderstanding you, but this seems like a non sequitur since expand_message will work for any input, regardless of its distribution.\r\n\r\nIf we want pseudorandom outputs, then the seed needs to be be pseudorandom as well, or, alternatively, have high entropy so we can use a hash function (e.g. SHA) to reduce it to a uniform pseudorandom seed. I think the second part is what @cjpatton meant by entropy extraction.\r\n\r\n> Do you mean (log(p) + n) * k + log(n) or log(p) + (n * k) + log(n)?\r\n\r\nI actually meant `(log(p) * n) + k + log(n)` :smile: . I'll fix the comment above.\r\n",
          "createdAt": "2022-02-08T17:25:09Z",
          "updatedAt": "2022-02-08T17:25:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "@schoppmp right -- it doesn't extract entropy. Garbage in means garbage out. =) In any case, I think we're aligned now.",
          "createdAt": "2022-02-08T17:27:20Z",
          "updatedAt": "2022-02-08T17:27:20Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@schoppmp Very interesting. Would you mind writing down the algorithm for mapping a `(log(p) * n) + k + log(n)` bits to `n` field elements? I'm curious how the extra `k + log(n)` bits are used. (You can also refer me to the IDPF code base.)",
          "createdAt": "2022-02-08T17:34:41Z",
          "updatedAt": "2022-02-08T17:34:41Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure, you can have a look [here](https://github.com/google/distributed_point_functions/blob/master/dpf/int_mod_n.h#L155). Note that the current implementation only works on 128-bit blocks, which limits the maximum `k` supported.",
          "createdAt": "2022-02-08T17:56:06Z",
          "updatedAt": "2022-02-08T17:56:06Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Alright, this is super neat. Me and @armfazh are going to work on benchmarking (in libprio) rejection sampling vs pad-then-reduce (a la hash_to_field) vs @schoppmp's algorithm. We should have this done today. \r\n\r\nIn the meantime, @schoppmp: Would you mind working on an alternative PR to #25 that specifies your algorithm?\r\n\r\nEDIT: By the way, I think it would make sense to fix the same \"security parameter\" (say, 64) for all fields, and possibly exclude fields that are too small for this sampling method to be statistically close to uniform (e.g., less than 64 bits). See also #22.",
          "createdAt": "2022-02-08T18:20:25Z",
          "updatedAt": "2022-02-08T18:52:12Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I've implemented both approaches PRs (linked to this issue).",
          "createdAt": "2022-02-14T21:40:23Z",
          "updatedAt": "2022-02-14T21:40:23Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A comparison of three methods can be found at: https://github.com/abetterinternet/libprio-rs/compare/main...armfazh:prg/bench?expand=1\r\n\r\n|Method|N=10|N=100|N=1000|\r\n|:---|---:|---:|---:|\r\n| Rejection Sampling | 5.2 |  7.8 |  38.1 |\r\n| Pad-and-reduce     | 4.8 | 15.1 | 115.8 |\r\n| Borrow-and-reduce  | 4.5 | 12.7 |  83.7 |\r\n\r\n\\* Timings are \u00b5s measured in Core i7-8650U CPU @ 1.90GHz.\r\n\r\n\r\n",
          "createdAt": "2022-02-23T17:45:37Z",
          "updatedAt": "2022-02-23T17:45:37Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @armfazh. Based on this assessment, I think that we should specify rejection sampling. @schoppmp do you object?\r\n",
          "createdAt": "2022-02-24T01:01:02Z",
          "updatedAt": "2022-02-24T01:01:02Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "An issue with rejection sampling is that it's hard to do with a constant-time implementation, which was also observed in the [hash-to-curve](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve#section-5) draft. Is your implementation returning early after the required number of finite field elements have been sampled? Or is it always sampling enough times to ensure the probability of rejecting too many samples is small enough (wrt. the security parameter)?",
          "createdAt": "2022-02-24T12:19:16Z",
          "updatedAt": "2022-02-24T12:19:29Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "libprio-rs currently generates samples until it reaches the number of field elements requested. This means the runtime is not bounded (in particular it's *definitely* not constant time!): \ufeffhttps://github.com/abetterinternet/libprio-rs/blob/main/src/prng.rs#L56-L82\r\n\r\nIncidentally, @armfazh noted that the current IDPF implementation is also not constant time, due to the division by the modulus here: https://github.com/abetterinternet/libprio-rs/blob/main/src/prng.rs#L56-L82. Though this should be easy enough to fix.\r\n\r\nTaking a step back, do we actually care if the algorithm that computes the mapping from pseudorandom byte strings to field elements is constant time? Take rejection sampling, for instance: assuming the underlying PRG is constant-time (i.e., AES-CTR is implemented in constant time) It seems to me that all that can be leaked by a non-constant-time implementation is the value of the bits that are rejected.",
          "createdAt": "2022-02-24T16:11:48Z",
          "updatedAt": "2022-02-24T16:11:48Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "> Incidentally, @armfazh noted that the current IDPF implementation is also not constant time, due to the division by the modulus here: https://github.com/abetterinternet/libprio-rs/blob/main/src/prng.rs#L56-L82. Though this should be easy enough to fix.\r\n\r\nNot sure what you mean, the link goes to libprio-rs. AFAICT all branches in the [DPF sampling function](https://github.com/google/distributed_point_functions/blob/master/dpf/int_mod_n.h#L155) are based on loop variables or compile-time constants.\r\n\r\n> Taking a step back, do we actually care if the algorithm that computes the mapping from pseudorandom byte strings to field elements is constant time? Take rejection sampling, for instance: assuming the underlying PRG is constant-time (i.e., AES-CTR is implemented in constant time) It seems to me that all that can be leaked by a non-constant-time implementation is the value of the bits that are rejected.\r\n\r\nMaybe you are right and that leakage is fine (in that it can be simulated in a proof). @chris-wood, do you have an insight as to why constant-time is required for hash-to-curve and thus rejection sampling is ruled out?",
          "createdAt": "2022-02-24T17:27:07Z",
          "updatedAt": "2022-02-24T17:27:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "> Maybe you are right and that leakage is fine (in that it can be simulated in a proof). @chris-wood, do you have an insight as to why constant-time is required for hash-to-curve and thus rejection sampling is ruled out?\r\n\r\nYeah -- some applications of hash-to-curve operate on secret input, and thus any side channels may leak the secret. [Dragonblood](https://papers.mathyvanhoef.com/wac2019-slides.pdf) is one famous example of this that motivated the hash-to-curve standard.",
          "createdAt": "2022-02-24T17:32:03Z",
          "updatedAt": "2022-02-24T17:32:03Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Ugh, sorry I copied the wrong link. I'm on a Mac and feel wayyy out of my depth :) Here's the link: https://github.com/google/distributed_point_functions/blob/master/dpf/int_mod_n.h#L170. I'm not sure this is guaranteed to be constant-time, i.e., the runtime of the division operation might depend on the value of `r`. I think this depends on the CPU arch.\r\n\r\n\r\n\r\n",
          "createdAt": "2022-02-24T17:34:25Z",
          "updatedAt": "2022-02-24T17:34:25Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "@cjpatton Ah got it. Yeah, I was assuming arithmetic operations are constant-time, but they might not be. In that case the fix should still be easy as you pointed out.\r\n\r\n@chris-wood So it seems that the number of iterations needed for many hashes of the same password + different auxiliary information (MAC, counter, ...) can be used to find the password. On the other hand, revealing even full blocks of an AES-CTR output shouldn't reveal anything about the key or any other blocks in the output. So is the issue in Dragonblood that the password is low-entropy?",
          "createdAt": "2022-02-24T18:15:06Z",
          "updatedAt": "2022-02-24T18:15:06Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Seems like we may have consensus for rejection sampling. Here's a PR: https://github.com/cjpatton/vdaf/pull/31. @schoppmp if you're happy with this outcome then please review at your convenience :)",
          "createdAt": "2022-02-25T00:51:38Z",
          "updatedAt": "2022-02-25T00:51:38Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "SGTM, provided we emphasize that the seed MUST be high-entropy, i.e., not derived from a password using a KDF or similar. I'll take a look at #31.",
          "createdAt": "2022-02-25T13:30:13Z",
          "updatedAt": "2022-02-25T13:30:13Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually I think high entropy (or, to be more precise, high min-entropy) won't be sufficient for all PRG constructions. See comments on the PR.",
          "createdAt": "2022-02-25T15:43:24Z",
          "updatedAt": "2022-02-25T15:43:24Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOGKuqOc5A-WhR",
      "title": "prio3: Make joint randomness optional",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/15",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Not all FLPs take joint randomness as input, in particular those for which `JOINT_RAND_LEN == 0`. For these FLPs we can reduce the bandwidth overhead by removing the `k_blind` and `k_hint` fields from the input share and the `k_joint_rand_share` from the prepare message.",
      "createdAt": "2021-12-28T19:27:29Z",
      "updatedAt": "2022-02-09T04:35:39Z",
      "closedAt": "2022-02-09T04:35:39Z",
      "comments": []
    },
    {
      "number": 18,
      "id": "I_kwDOGKuqOc5CXBsP",
      "title": "Threat model and protocol for distributed setup",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/18",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The \"setup\" algorithm defined in the spec specifies the generation of the public parameter used by the clients and verification parameter of each of the aggregators. This algorithm is said to run \"out-of-band\", effectively punting this consideration to applications. In particular, this is a problem that PPM will have to solve: see https://github.com/abetterinternet/ppm-specification/issues/161.\r\n\r\nWe know that the setup algorithm being run securely is crucial correctness, however it's not clear how important it is for privacy. As a strawman, suppose that we have one aggregator run the setup algorithm and distribute the output among the parties such that the clients never learn or control the value of the verification parameters. This ought to be good enough for correctness. What's less clear (to me, at least) is whether the aggregator, by choosing the verification parameters maliciously, can force an honest aggregator into revealing something that leads to a privacy violation.\r\n\r\nIf this strawman is not sufficient and we end up needing to do something fancier, then it may prudent to revisit the \"setup algorithm\" abstraction. What we woiuld want for prio3 and poplar1 is a protocol for exchanging a shared secret. (The properties we need from this key exchange are TBD, but note that something like a DH key exchange might not suffice. See https://github.com/abetterinternet/ppm-specification/issues/161 for discussion.)",
      "createdAt": "2022-01-25T01:53:41Z",
      "updatedAt": "2022-01-31T11:28:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "One thing to keep in mind is that the randomness used in the verification protocol (at least for Poplar) must be independent of the client keys. If a (semi-honest) helper server colludes with a (malicious) client, the client could use the randomness known to the helper server to generate an invalid share that still passes the verification. So I would propose running the setup phase only after all client shares have been collected and agreed on by the helper servers.\r\n\r\nRegarding maliciously generated randomness, are we considering malicious security for the helpers at all? If so, what exact formalization? For example, Poplar only provides malicious security with respect to privacy (but not correctness). Not sure we want to hard-code this threat model or instead leave it up to implementations.",
          "createdAt": "2022-01-25T10:32:56Z",
          "updatedAt": "2022-01-25T10:33:57Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> One thing to keep in mind is that the randomness used in the verification protocol (at least for Poplar) must be independent of the client keys. If a (semi-honest) helper server colludes with a (malicious) client, the client could use the randomness known to the helper server to generate an invalid share that still passes the verification.\r\n\r\nMost definitely. In fact, this is likely going to be true for most, if not all, VDAFs. \r\n\r\n> So I would propose running the setup phase only after all client shares have been collected and agreed on by the helper servers.\r\n\r\nThis isn't going to feasible for all deployments for PPM. In particular, a deployment of prio3 might throw report shares away as soon as they're aggregated, in order to limit storage overhead. Regardless, I think the main requirement is that the randomness is kept secret from the clients, which is definitely feasible.\r\n\r\n> Regarding maliciously generated randomness, are we considering malicious security for the helpers at all? If so, what exact formalization? For example, Poplar only provides malicious security with respect to privacy (but not correctness). Not sure we want to hard-code this threat model or instead leave it up to implementations.\r\n\r\nYes, as stated in our security considerations: for privacy we're concerned with malicious aggregators, but for correctness we assume the aggregators are honest. This amounts to the clients only needing to trust at least one aggregator for privacy, however the collector needs to trust that the aggregators compute the protocol correctly.\r\n\r\nThe main point raised in https://github.com/abetterinternet/ppm-specification/issues/161 is that there is a gap in the thread model not addressed by [BBCGGI19] or [BBCGGI21] (Poplar): The shared randomness used for verification may be controlled by the attacker. [BBCGGI19] and [BBCGGI21] side-step this by assuming an ideal \"coin-flipping\" functionality in the protocol. In practice, this coin-flipping functionality needs to be realized by some interaction among the aggregators.\r\n\r\nThus the main question I'm asking here is what properties do we actually need from the coin-flipping protocol. In particular: If we allow the attacker to control the honest aggregators' long lived randomness, are `poplar1` and `prio3` still private? This was discussed a bit in https://github.com/abetterinternet/ppm-specification/issues/161, but I'm not sure we have a definitive answer (at least for prio3).\r\n   * If yes, then the strawman setup procedure described above will suffice and we're done.\r\n   * If no, then we'll have to decide whether to consider an alternative here or leave this to applications like PPM.",
          "createdAt": "2022-01-25T15:57:21Z",
          "updatedAt": "2022-01-25T15:57:21Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "I think there are two questions here:\r\n1. How do we handle collusions between one of the servers and a subset of clients with respect to correctness? \r\n2. (Your question) Does a maliciously chosen randomness affect the privacy of the protocols?\r\n\r\nRegarding (1): Even though we don't care about correctness for malicious server behavior, a semi-honest server colluding with malicious clients might still be a problem. For example, in reality, we could enforce semi-honest helper servers using some form of binary attestation. But that wouldn't stop a malicious admin from reading out the verification randomness and then running a client with an invalid input that still passes verification with that randomness.\r\n> Regardless, I think the main requirement is that the randomness is kept secret from the clients, which is definitely feasible.\r\n\r\nGiven the example above, I'm not sure it is always realistic to assume that the randomness is kept secret from all clients. So I would like to at least keep the option to only generate the randomness once the client shares are agreed on. If we want to allow Fiat-Shamir as discussed in abetterinternet/ppm-specification#161, this would be required anyway.\r\n\r\nRegarding (2): I had a brief look at Poplar, and it doesn't seem like adversary-chosen randomness can break privacy. In particular, Proposition 2 in [Appendix C.4.1](https://eprint.iacr.org/2021/017.pdf#page=19&zoom=100,417,856) still holds (the simulator does not require r to be random). Maybe @henrycg has some insights for Prio?",
          "createdAt": "2022-01-26T14:05:00Z",
          "updatedAt": "2022-01-26T14:05:00Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> But that wouldn't stop a malicious admin from reading out the verification randomness and then running a client with an invalid input that still passes verification with that randomness.\r\n\r\nSince this involves sharing information with the client -- or, equivalently, acting as a client itself -- I would consider this malicious (i.e., active) behavior on the part of the server and, therefore, out of scope.\r\n\r\n>  So I would like to at least keep the option to only generate the randomness once the client shares are agreed on.\r\n\r\nI think keeping this option is reasonable. One question though: Is this a matter to be considered by the VDAF spec or by applications? We could discuss the attack you described above in security considerations and recommend setting up the verification parameters only after the input shares have been ingested.\r\n\r\n> If we want to allow Fiat-Shamir as discussed in abetterinternet/ppm-specification#161, this would be required anyway.\r\n\r\nCan you provide more detail here? We use Fiat-Shamir in prio3 for the \"joint randomness\", but not the \"query randomness\". I agree that there's an attack if the client knows the shared secret used to derive query randomness, but I don't see an attack if the shared secret is generated before the client generates its input shares (as long as it doesn't see it). Am I missing something?",
          "createdAt": "2022-01-26T15:38:19Z",
          "updatedAt": "2022-01-26T16:43:24Z"
        },
        {
          "author": "henrycg",
          "authorAssociation": "NONE",
          "body": "> Regarding (2): I had a brief look at Poplar, and it doesn't seem like adversary-chosen randomness can break privacy. In particular, Proposition 2 in [Appendix C.4.1](https://eprint.iacr.org/2021/017.pdf#page=19&zoom=100,417,856) still holds (the simulator does not require r to be random). Maybe @henrycg has some insights for Prio?\r\n\r\nYes, the same should be true for Prio, provided that the servers' random challenge is chosen, as in the Crypto'19 paper, to avoid the certain set of \"bad\" challenge points.",
          "createdAt": "2022-01-26T16:02:41Z",
          "updatedAt": "2022-01-26T16:02:41Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "> Can you provide more detail here? We use Fiat-Shamir in prio3 for the \"joint randomness\", but not the \"query randomness\". I agree that there's an attack if the client knows the shared secret used to derive query randomness, but I don't see an attack if the shared secret is generated before the client generates its input shares (as long as it doesn't see it). Am I missing something?\r\n\r\nOkay, so this means that you use fiat-shamir to derive the randomness used in each client's proof share, but not the randomness that is sampled independently by the servers using coin-flipping? In that case you are right, we don't need to wait until we know all client shares.\r\n\r\nStill, the issue regarding a server colluding with a malicious client stands. I'm not sure we can simply discount it for being \"out of scope\", given the example attack scenario I gave above. Or, to put it in more formal terms, I don't see why we should require the adversary to corrupt all parties in the same way, given that some (clients) are more easy to corrupt maliciously than others (helper servers).",
          "createdAt": "2022-01-26T16:59:20Z",
          "updatedAt": "2022-01-26T16:59:28Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is this a matter to be considered by the VDAF spec or by applications? We could discuss the attack you described above in security considerations and recommend setting up the verification parameters only after the input shares have been ingested.\r\n\r\nDo you think we should discuss this in the PPM spec as well (e.g. in abetterinternet/ppm-specification#161)?",
          "createdAt": "2022-01-26T17:02:26Z",
          "updatedAt": "2022-01-26T17:02:26Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "That's an interesting point, and I agree that there's no reason to think of all parties as being corrupted in the same way. Definitely worth thinking about.\r\n\r\nI'll just add this thought: If a malicious aggregator wants to break correctness, there's a much simpler attack than corrupting or acting as a client: all it has to do is make up a bogus aggregate share. The collector would have no way to detect this, at least for prio3 or poplar1.",
          "createdAt": "2022-01-28T03:15:28Z",
          "updatedAt": "2022-01-28T03:15:28Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'll just add this thought: If a malicious aggregator wants to break correctness, there's a much simpler attack than corrupting or acting as a client: all it has to do is make up a bogus aggregate share. The collector would have no way to detect this, at least for prio3 or poplar1.\r\n\r\nI assume you mean a malicious admin or similar insider would run this simpler attack at the aggregator service? Then it wouldn't work any more if there are additional measurements (e.g., binary attestation) to enforce semi-honest behavior of the aggregator process, whereas reading out the verification randomness and then uwing it with a maliciously crafted client message would still work. \r\n\r\nOverall, even if we only consider outside attackers, I believe leaking some secret value from one of the aggregator servers is easier (requires less severe vulnerabilities or exploits) than triggering a remote code execution to cheat during the aggregation protocol.",
          "createdAt": "2022-01-28T11:38:51Z",
          "updatedAt": "2022-01-28T11:38:51Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> I assume you mean a malicious admin or similar insider would run this simpler attack at the aggregator service? Then it wouldn't work any more if there are additional measurements (e.g., binary attestation) to enforce semi-honest behavior of the aggregator process, whereas reading out the verification randomness and then uwing it with a maliciously crafted client message would still work.\r\n\r\nBinary attestation would be super useful, but I don't think it will be used in all applications of VDAFs.\r\n\r\nRegardless, I think the threat you're describing is worth discussing in security considerations, and we could even RECOMMEND that, where feasible, the setup algorithm be run only after the batch of input shares has arrived. However I would not go so far as to say deployments MUST or even SHOULD do this. Do you think this would be a reasonable outcome?",
          "createdAt": "2022-01-28T16:05:45Z",
          "updatedAt": "2022-01-28T16:05:45Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "That sounds good to me. I opened #21 for that, PTAL.",
          "createdAt": "2022-01-31T11:28:59Z",
          "updatedAt": "2022-01-31T11:28:59Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "I_kwDOGKuqOc5CXDUr",
      "title": "VDAFs that use the public parameter?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/19",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-01"
      ],
      "body": "The \"setup\" algorithm outputs a public parameter used by the clients to shard their measurement into input shares. This was added to the syntax in anticipation of VDAFs that might make use of public-key cryptography in some way. For example, in the appendix, [BBCGGI19] describes alternative applications for FLPs, e.g., using homomorphic encryption. One can imagine a VDAF that uses homomorphic encryption in order to save a round trip for input validation. (This is basically what [AdScale](https://isi.jhu.edu/~mgreen/advertising.pdf) does, as I understand.)\r\n\r\nThis is a bit of a pain for PPM, since it means that rotating the verification parameter also requires re-configuring the clients with the new public parameter. (See https://github.com/abetterinternet/ppm-specification/issues/161.) Since we don't yet have a VDAF that makes use of the public parameter, it might be preferable to drop it from the syntax.",
      "createdAt": "2022-01-25T02:06:43Z",
      "updatedAt": "2022-05-18T23:12:33Z",
      "closedAt": "2022-05-18T23:12:33Z",
      "comments": []
    },
    {
      "number": 20,
      "id": "I_kwDOGKuqOc5CbTK5",
      "title": "What to do about DAFs (VDAFs w/o verifiability)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/20",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The syntax is compatible with schemes that forego verifiability altogether, but calling such a scheme a \"VDAF\" would be misleading. It's probably a good idea to make this distinction explicit, i.e., define \"DAFs\" as 0-round VDAFs that provide no verifiability. Should we make room for this in this document, or does it make sense to kick this to a different document?\r\n\r\nNote that this question came up previously in the context of PPM: https://github.com/abetterinternet/ppm-specification/issues/45.",
      "createdAt": "2022-01-25T23:10:00Z",
      "updatedAt": "2022-05-13T15:20:06Z",
      "closedAt": "2022-05-13T15:20:06Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "In case it helps, the [VOPRF document](https://cfrg.github.io/draft-irtf-cfrg-voprf/draft-irtf-cfrg-voprf.html) includes OPRFs with and without verifiability. I think it makes sense to include DAFs in this document, especially for deployments that don't need verifiability.",
          "createdAt": "2022-01-25T23:52:10Z",
          "updatedAt": "2022-01-25T23:52:10Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "One example of something that's close to a DAF: https://eprint.iacr.org/2018/442.pdf",
          "createdAt": "2022-04-06T20:33:59Z",
          "updatedAt": "2022-04-06T20:33:59Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "One thing @chris-wood and I noted today is that \"DAFs\" will have no need for a verification parameter, making them syntactically somewhat different.",
          "createdAt": "2022-04-28T21:24:13Z",
          "updatedAt": "2022-04-28T21:24:13Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "I_kwDOGKuqOc5C4vjo",
      "title": "Specify fields for poplar1 (was \"Specify fields for prio3 and poplar1\")",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/22",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-02"
      ],
      "body": "At this point we have fairly clear criteria for choosing fields for Prio. Namely, the prime modulus `p` should be of the form `2^k * q + 1`, where `k` is large enough to support proof sizes we're interested in. The fact that the multiplicative group has a subgroup of order `2^k` is exploited for fast polynomial interpolation. `k` should also be chosen to align with the word size of the machine, e.g., `32` or `64` so that fast arithmetic can be generated for it (cc/ @armfazh).\r\n\r\nThe requirements are different for Poplar, though any field we choose for Prio ought to be suitable for Poplar as well. The main difference I see is that we'll need a much larger field for the leaves of the IPDF tree than we need for the inner nodes. I wonder if the leaves could use `GF(2^255 - 19)`, since there are already fast, heavily vetted implementation of this field (namely for X25519 and ed25519)? @schoppmp do you have any other thoughts here?",
      "createdAt": "2022-02-02T16:59:10Z",
      "updatedAt": "2022-06-22T15:19:37Z",
      "closedAt": "2022-06-22T15:19:37Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "As far as how big the primes ought to be, I think we ought to aim for a soundness error of around 1/2^64 for any VDAF. Higher security levels can be targeted as desired.\r\n\r\nFor prio3, we should have:\r\n* a 64-bit field. This would only be appropriate for instantiations that don't do Fiat-Shamir.\r\n* a 96-bit field. Similarly, this would not be appropriate for Fiat-Shamir.\r\n* a 128-bit field. This would be suitable for Fiat-Shamir.\r\n\r\nFor poplar1 we might reuse these fields, or pick new ones if the fields we pick for prio3 aren't suitable. We will also need:\r\n* a 256-bit field (or close to it). It may be worthwhile to pick something suitable for prio3.",
          "createdAt": "2022-02-02T17:58:50Z",
          "updatedAt": "2022-02-02T18:02:41Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "The document now specifies a 64-bit and a 128-bit field suitable for prio3.",
          "createdAt": "2022-03-04T01:45:53Z",
          "updatedAt": "2022-03-04T01:45:53Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "I_kwDOGKuqOc5El_DQ",
      "title": "PRGs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/32",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Our initial PRG construction is based on AES: https://github.com/cjpatton/vdaf/pull/28. @schoppmp points out that there may alternative AES-based constructions that are better suited to our application. In addition, there may be alternative primitives, like an XOF hash function, that are well suited for VDAFs. This issue is for tracking this discussion.",
      "createdAt": "2022-02-25T19:49:52Z",
      "updatedAt": "2022-08-12T05:14:16Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's the paper Phillipp referenced: https://eprint.iacr.org/2019/074.pdf",
          "createdAt": "2022-03-09T18:04:39Z",
          "updatedAt": "2022-03-09T18:04:39Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "The text you added to the draft suggests that fixed-key AES (as it is called in the paper) might be something to move to.  The paper suggests that you don't get correlation robustness in that case, so maybe that isn't the best choice.\r\n\r\nA PRG based on AES does seem to be a sensible choice here from a performance perspective if nothing else, and the idea of using a counter seems reasonable.  Maybe consider using $\\mathsf{MMO}^\\pi$ or $\\widehat{\\mathsf{MMO}}_\\sigma^\\pi$ from that paper instead.  The added cost is modest, but it would appear that the properties they provide are superior.",
          "createdAt": "2022-08-12T05:09:42Z",
          "updatedAt": "2022-08-12T05:09:42Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "Oh, I should add https://eprint.iacr.org/2022/080 describes another variant that adds a tweak.  The tweak looks like $H(m,t) = \\pi(m\\otimes t)\\oplus (m\\otimes t)$, which is a little slower overall, but probably still in line with what you are looking for.  The only trick there is in deciding the tweak.",
          "createdAt": "2022-08-12T05:13:54Z",
          "updatedAt": "2022-08-12T05:14:16Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "I_kwDOGKuqOc5FZnLF",
      "title": "Serializaiton of the verification parameter",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/38",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-01"
      ],
      "body": "As @tgeoghegan pointed out in https://github.com/abetterinternet/libprio-rs/pull/192#issuecomment-1062483035, some applications will require transmitting verification parameters over a secure channel. To support these, we we ought to require that VDAFs specify an encoding.",
      "createdAt": "2022-03-09T19:20:51Z",
      "updatedAt": "2022-05-18T23:15:36Z",
      "closedAt": "2022-05-18T23:15:35Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "One way to resolve this issue is to codify the \"aggregator ID\" in the syntax and make the verification parameter simply a shared secret. This would be compatible with at least Prio3 and Poplar1.",
          "createdAt": "2022-05-10T01:05:18Z",
          "updatedAt": "2022-05-10T01:05:18Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by #62.",
          "createdAt": "2022-05-18T23:15:35Z",
          "updatedAt": "2022-05-18T23:15:35Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "I_kwDOGKuqOc5FxJ2w",
      "title": "Prio3: Shorten the prepare message",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/39",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-01"
      ],
      "body": "By moving `decide()` into `prep_shares_to_prep()` we can avoid sending the unsharded verifier message over the network.",
      "createdAt": "2022-03-16T04:05:40Z",
      "updatedAt": "2022-05-18T23:13:52Z",
      "closedAt": "2022-05-18T23:13:52Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed via #64.",
          "createdAt": "2022-05-18T23:13:52Z",
          "updatedAt": "2022-05-18T23:13:52Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "I_kwDOGKuqOc5GLehI",
      "title": "Does VDAF need a notion of leader?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/40",
      "state": "OPEN",
      "author": "tgeoghegan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "PPM has a notion of a distinguished aggregator called the \"leader\". Wherever messages contain a sequence of objects, that protocol insists that the leader's share always be the first element (e.g. [`Report.encrypted_input_shares`](https://www.ietf.org/archive/id/draft-gpew-priv-ppm-01.html#section-4.2.2-4.4)).\r\n\r\nVDAF only references the notion of a leader in its specification of `Prio3`, [whose input sharding algorithm does specify that the leader's share appears first](https://www.ietf.org/archive/id/draft-patton-cfrg-vdaf-01.html#section-6.2.2).\r\n\r\nHowever that constraint isn't articulated generically for all VDAFs, which leaves things ambiguous for implementations. Consider the current generic declaration of [`prio::vdaf::Client::shard`](https://docs.rs/prio/latest/prio/vdaf/trait.Client.html):\r\n```\r\n    /// Shards a measurement into a sequence of input shares, one for each Aggregator.\r\n    fn shard(\r\n        &self,\r\n        public_param: &Self::PublicParam,\r\n        measurement: &Self::Measurement,\r\n    ) -> Result<Vec<Self::InputShare>, VdafError>;\r\n```\r\nPPM implementations have to guess that the 0th element in the returned `Vec` is the leader's share. Should the [VDAF-level definition of `shard`](https://www.ietf.org/archive/id/draft-patton-cfrg-vdaf-01.html#section-4.2) discuss the notion of a leader share, and require that the 0-th value returned from `Vdaf.measurement_to_input_shares` be the leader's?\r\n",
      "createdAt": "2022-03-22T23:31:13Z",
      "updatedAt": "2022-04-19T17:50:11Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree this ambiguity matters to PPM -- or, more generally, the Leader/Model architecture -- insofar that it makes sense to send the \"big\" share to the leader in order to decrease communication cost for the helpers. It's also true that this asymmetry --- i.e., the existence of a distinguished \"big\" share -- exists for Prio3 and, to a lesser extend, Poplar1; but it's worth pointing out that the asymmetry doesn't necessarily exist for all VDAFs.\r\n\r\nFor this reason, my view here is that it's not worth making a syntactic change to the VDAF spec in order to accommodate this. What I would go for is adding guidance somewhere in the spec to nudge things in the right direction. In particular: would it be sufficient to RECOMMEND that future VDAFs put the \"big\" share first (if it exists)?",
          "createdAt": "2022-03-22T23:47:23Z",
          "updatedAt": "2022-03-22T23:48:11Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure that a recommendation will suffice. If there's a difference in the encoding of one share vs. the others, then a PPM implementation needs to able to tell which one is different so it can be sent to the aggregator that is configured to handle that kind of share.\r\n\r\nAlternatively, an encoded input share could include some indication of how it is encoded (e.g. whether or not it's compressed in prio3) and then `Vdaf.prep_init` could use that inline information to decide how to decode the input share.",
          "createdAt": "2022-03-22T23:57:26Z",
          "updatedAt": "2022-03-22T23:57:26Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm not sure that a recommendation will suffice. If there's a difference in the encoding of one share vs. the others, then a PPM implementation needs to able to tell which one is different so it can be sent to the aggregator that is configured to handle that kind of share.\r\n\r\nTrue enough. Right now the information needed to decode (and indeed to prepare an input) is encoded by the verification parameter: https://www.ietf.org/archive/id/draft-patton-cfrg-vdaf-01.html#name-setup-2. This seems sufficient, but  perhaps there's a better way to expose this?\r\n\r\nBy the way, to decode a Prio3 input share, you need to know more than whether the share is for the \"leader\" or a \"helper\". You also need the \"aggregator ID\", which is used in an essential way to compute the joint randomness. For Prio3 this is encoded by the verification parameter.\r\n\r\n> Alternatively, an encoded input share could include some indication of how it is encoded (e.g. whether or not it's compressed in prio3) and then `Vdaf.prep_init` could use that inline information to decide how to decode the input share.\r\n\r\nSeems reasonable, though it would cost a few bits of communication.",
          "createdAt": "2022-03-23T00:03:22Z",
          "updatedAt": "2022-03-23T00:04:02Z"
        },
        {
          "author": "BranLwyd",
          "authorAssociation": "NONE",
          "body": "I don't think VDAFs need the notion of a leader -- but I do think that the VDAF spec should consider specifying that for the various per-aggregator parameters, values are correlated by index (so e.g. `verify_params` index 0 is always used with `input_shares` index 0). The only text I can find suggesting this is in the `run_vdaf` pseudocode in Section 4.6, but I am not sure this is normative.\r\n\r\nSeparately, PPM should specify that the leader uses VDAF index 0, helper uses index 1 (or vice versa).",
          "createdAt": "2022-04-14T23:33:07Z",
          "updatedAt": "2022-04-14T23:33:07Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, there is currently no normative text regarding which server gets which share. I also don't think there should be, at least not in the VDAF spec. On the other hand, I agree we need language here to make sure that\r\n(1) it's possible for PPM to specify which server gets which share.\r\n(2) Users are guided towards making sensible choices which servers consume the \"big\" shares (when applicable).\r\n\r\nI welcome suggestions for ways to solve each of these :)",
          "createdAt": "2022-04-19T17:50:11Z",
          "updatedAt": "2022-04-19T17:50:11Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "I_kwDOGKuqOc5GkD62",
      "title": "Representing 'linear state machine' requirement in pseudocode",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/42",
      "state": "OPEN",
      "author": "divergentdave",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The following currently appears in section 4.3.\r\n\r\n> TODO Consider how to bake this \"linear state machine\" condition into the syntax. Given that Python 3 is used as our pseudocode, it's easier to specify the preparation state using a class.",
      "createdAt": "2022-03-28T19:00:08Z",
      "updatedAt": "2022-08-25T00:16:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My suggestion: If we augment our pseudocode with dependent types, then we could parameterize the type of `Prep` by how many rounds are left before the output share is recovered. Making up some syntax, this would look like:\r\n\r\n```\r\nVdaf.prep_init(verify_param: VerifyParam, agg_param: AggParam, nonce: Bytes, input_share: Bytes) -> Prep[ROUNDS]\r\n\r\nVdaf.prep_next(prep: Prep[ROUNDS], inbound: None) -> If[ROUNDS == 0, OutShare, Tuple[Prep[ROUNDS - 1], Bytes]]\r\nVdaf.prep_next(prep: Prep[R such that R < ROUNDS], inbound: Bytes) -> If[R == 0, OutShare, Tuple[Prep[R - 1], Bytes]]\r\n```",
          "createdAt": "2022-03-28T19:00:13Z",
          "updatedAt": "2022-03-28T21:55:48Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "That's an interesting idea. It would be great to see a PR with this idea implemented. Two constraints I'd like to keep top of mind:\r\n(1) If possible, our \"pseudocode\" ishould syntactically correct Python3 (well, Sage really.)\r\n(2) Readability is more important than rigorous type semantics.",
          "createdAt": "2022-04-06T19:20:43Z",
          "updatedAt": "2022-04-06T19:20:43Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure, I'll noodle on that. I'm not sure Python typing can express the concept directly, but maybe we could show ~3 `@overload`s with `Literal[1]`, `Literal[2]`, `Literal[3]`, as parameters, etc.",
          "createdAt": "2022-04-06T20:25:53Z",
          "updatedAt": "2022-04-06T20:25:53Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "I_kwDOGKuqOc5HO1SU",
      "title": "Poplar1: `k_verify_rand` should be derived from agg param",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/44",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-02"
      ],
      "body": "Currently only the nonce is used to derive the shared verification randomness. This should also depend on the aggregation parameter so that the verification randomness is unique for each aggregation parameter.",
      "createdAt": "2022-04-06T19:23:33Z",
      "updatedAt": "2022-07-11T21:00:31Z",
      "closedAt": "2022-07-11T21:00:31Z",
      "comments": []
    },
    {
      "number": 45,
      "id": "I_kwDOGKuqOc5H9Pb0",
      "title": "Combined state machine and output extraction",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/45",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Right now, `prep_next` returns one of two types: a final output share, or a new state and output message. Why not split these two into separate functions, e.g., `prep_next` for advancing the state machine and then `prep_finish` for producing the final output?",
      "createdAt": "2022-04-18T16:56:44Z",
      "updatedAt": "2022-08-25T00:17:12Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "We had this separation at some point, then decided to merge them into the same function. IIRC the thinking was that a particular VDAF might have a variable number of rounds, where the number of rounds depends on the inputs to the preparation phase. In this case the user would not know whether it should call `prep_next` or `prep_finish` at a particular step.\r\n\r\nThe VDAFs we have so far are all constant-round, and I think we're unlikely to have such a variable-round VDAF in the future. However, there are ways to extend your suggestion to allow the user to check if the current round is the last.\r\n\r\nI would be in favor the change you suggest, since it reduces a bit of API complexity. However, note that this complexity is, arguably, inherent to the pseudocode and is not shared by languages like Rust that have rich enum support. E.g.: \r\nhttps://github.com/divviup/libprio-rs/blob/main/src/vdaf.rs#L223.) \r\n\r\nThoughts, @schoppmp and @bifurcation?\r\n\r\n\r\n",
          "createdAt": "2022-04-19T17:43:55Z",
          "updatedAt": "2022-04-19T17:43:55Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To pile onto cjpatton's point: when we had a distinct `prepare_finish` method in `libprio`, we found that all it did was introduce the possibility of disagreement between client's tracking of the round of the prepare protocol we're on (which it has to do in order to choose whether to call `prepare_next` or `prepare_finish`) and `libprio`'s tracking of the round (which is encoded into the prepare state for all the VDAFs we've got). So `libprio` had to write extra code to handle `prepare_finish` being called at the wrong time, and clients of `libprio` had to write extra code to handle having their `prepare_next` call being rejected.\r\n\r\nAnother possibility that absolves the client of the VDAF from tracking rounds is to add a method on prepare state so you can query whether you are on the last round, and then do:\r\n\r\n```\r\nif prepare_state.is_last_round() {\r\n    let output_share = prepare_finish(prepare_state, messages);\r\n} else {\r\n    let (new_state, next_message) = prepare_next(prepare_state, messages);\r\n}\r\n```\r\n\r\nI agree with Chris P. that returning sum types make abstracting all this away behind a single `prepare_next` really nice in Rust (and I would think even in Python, tuple returns make this not so bad), but maybe `is_last_round` is an appropriate way to define VDAF to make it usable regardless of programming language features? Especially since we're free to define the interface of our Rust implementation however we like, regardless of how VDAF spells out `prepare_next` or `prepare_finish`.",
          "createdAt": "2022-04-19T21:03:49Z",
          "updatedAt": "2022-04-19T21:06:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "@tgeoghegan's suggestion seems fine, but I would name `is_las_round` to something like `is_finished`. This seems _purely_ an editorial change, I think, since one could use type system in Rust like @cjpatton suggests to fold `is_finished` into the `prep_next`.",
          "createdAt": "2022-04-20T13:59:36Z",
          "updatedAt": "2022-04-20T13:59:36Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, this is pretty much editorial.",
          "createdAt": "2022-04-21T01:13:00Z",
          "updatedAt": "2022-04-21T01:13:00Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "I_kwDOGKuqOc5IguuL",
      "title": "Define a method for merging multiple aggregate shares into an aggregate share",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/47",
      "state": "OPEN",
      "author": "tgeoghegan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A VDAF must define a few [associated types](https://github.com/cjpatton/vdaf/blob/15c6abadc46d760a2b39a5708492a195fb4ee2e9/draft-patton-cfrg-vdaf.md?plain=1#L400):\r\n\r\n```\r\n| `OutShare`    | Type of each output share     |\r\n| `AggShare`    | Type of each aggregate share  |\r\n| `AggResult`   | Type of the aggregate result  |\r\n```\r\n\r\nVDAF defines a method for combining multiple output shares into an aggregate share: [`Vdaf.out_shares_to_agg_share(agg_param: AggParam, output_shares: Vec[OutShare]) -> agg_share: AggShare`](https://github.com/cjpatton/vdaf/blob/15c6abadc46d760a2b39a5708492a195fb4ee2e9/draft-patton-cfrg-vdaf.md?plain=1#L590). That's implemented in libprio as [`prio::vdaf::Aggregator::aggregate`](https://github.com/divviup/libprio-rs/blob/1bd54185d01110ff4486b8d71ed8f17f1ea77b78/src/vdaf.rs#L201).\r\n\r\nVDAF also defines a method for combining multiple aggregate shares into an aggregate result: [`Vdaf.agg_shares_to_result(agg_param: AggParam, agg_shares: Vec[AggShare]) -> AggResult`](https://github.com/cjpatton/vdaf/blob/15c6abadc46d760a2b39a5708492a195fb4ee2e9/draft-patton-cfrg-vdaf.md?plain=1#L627). That's implemented in libprio as [`prio::vdaf::Collector::unshard`](https://github.com/divviup/libprio-rs/blob/1bd54185d01110ff4486b8d71ed8f17f1ea77b78/src/vdaf.rs#L214).\r\n\r\nlibprio's trait [`prio::vdaf::Aggregatable`](https://github.com/divviup/libprio-rs/blob/1bd54185d01110ff4486b8d71ed8f17f1ea77b78/src/vdaf.rs#L236) is meant to correspond to a VDAF `AggShare` and also provides the method `Aggregatable:merge(&self, other: &Self) -> Result<(), VdafError>`. This method is extremely useful if not required for PPM implementations which will want to implement a map-reduce strategy for constructing aggregate shares. VDAF should define a method that corresponds to libprio's `merge`, and perhaps require that the combination of VDAF output shares into aggregate shares should not depend on order of the output shares.",
      "createdAt": "2022-04-26T22:20:43Z",
      "updatedAt": "2022-05-10T00:33:02Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "libprio also has `Aggregatable::accumulate(&mut self, output_share: &Self::OutputShare) -> Result<(), VdafError>`, for accumulating an output share into an existing `AggShare`. VDAF may also want to define that method.",
          "createdAt": "2022-04-26T22:21:17Z",
          "updatedAt": "2022-04-26T22:21:17Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Besides the concrete mapping of VDAF methods to the libprio interface, we came across another interesting ambiguity in #53 ([link](https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/53#discussion_r868486690)).\r\n\r\nThe current draft discusses \"one-shot\" vs. \"streaming\" aggregation. \"Streaming\" means that it's possible to accumulate output shares into an aggregate one at a time, and that you don't have to keep all the output shares around. Such an aggregation is enabled by the `Aggregatable::merge` method libprio defines, and makes sense for the current Prio3 and Poplar1 VDAFs. \"One-shot\" means that you can't combine output shares into an aggregate until you have every output share that will go into that aggregate. @divergentdave's example is a median.\r\n\r\nI, at least, got confused about what \"one shot\" vs. \"streaming\" means and conflated it with the distinction between VDAFs that have an aggregation parameter (so you can't prepare any input shares until the collector provides `agg_param`; Poplar1 is such a VDAF)) and ones where the aggregation parameter is implicit or empty, and aggregators can prepare inputs as soon as they're uploaded (Prio3 VDAFs are like this). We should consider adding text to VDAF and/or DAP to clarify these two features of a VDAF and their implications on input preparation, assuming that I'm not the only person confused by these two things.",
          "createdAt": "2022-05-10T00:33:01Z",
          "updatedAt": "2022-05-10T00:33:01Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "I_kwDOGKuqOc5IlhvL",
      "title": "Rename Prepare",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/48",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "While prepare seems to make sense in the context of the whole VDAF flow -- \"prepare a thing to be aggregated\" -- it's where most of the interesting VDAF work takes place. Maybe \"process\" or something would be better?",
      "createdAt": "2022-04-27T19:33:58Z",
      "updatedAt": "2022-08-25T00:16:43Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "\"process\" works for me.",
          "createdAt": "2022-04-27T19:48:31Z",
          "updatedAt": "2022-04-27T19:48:31Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think either \"prepare\" or \"process\" are particularly good (both are too generic) but \"prepare\" at least implies that something else is going to be done to the value (namely, being aggregated). The verb \"process\" carries even less information than \"prepare\".\r\n\r\nIf we look at Prio3 and Poplar1, what actually is happening is proof verification. Did we previously reject \"verify\" as the verb to use here? Is the idea that there might be some future VDAF that either doesn't verify anything or does stuff besides verification?",
          "createdAt": "2022-04-27T20:18:28Z",
          "updatedAt": "2022-04-27T20:18:28Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "The reason I'm not sure \"verify\" is suitable is because it implies a particular MPC technique. There other possibilities, like OT-extensions + Boolean-to-Arithmetic conversion (a la Prio+) that I would like to continue to make room for.",
          "createdAt": "2022-04-27T21:18:15Z",
          "updatedAt": "2022-04-27T21:18:15Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "I_kwDOGKuqOc5ImX8-",
      "title": "sage poc: JOINT_RAND_LEN duplicated accidentally",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/51",
      "state": "CLOSED",
      "author": "jbr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The second and third fields [here](https://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/main/poc/flp.sage#L15-L22) should likely be `PROVE_RAND_LEN` and `QUERY_RAND_LEN`",
      "createdAt": "2022-04-28T00:26:34Z",
      "updatedAt": "2022-04-28T03:38:05Z",
      "closedAt": "2022-04-28T03:38:05Z",
      "comments": []
    },
    {
      "number": 58,
      "id": "I_kwDOGKuqOc5JVUC1",
      "title": "Should the draft be prescriptive about encoding? (was \"Serialization of aggregate shares needs to be specified\")",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/58",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "`Vdaf` implementations need to define a type`Vdaf.AggShare` for the aggregate shares. Because the aggregate share are transmitted over the network, their encoding needs to be specified. There are two solutions to consider:\r\n(1) Replace `Vdaf.AggShare` with `Bytes`\r\n(2) Add methods on `Vdaf.AggShare` for encoding/decoding\r\n\r\nThe other quantities written to the network are input shares, prepare message shares, and the combined prepare message for each round. If we do (2), then for consistency we should also consider defining separate encoding/decoding methods for these. Currently the methods are implicit, since the type of each of these values is `Bytes`.",
      "createdAt": "2022-05-09T22:39:52Z",
      "updatedAt": "2022-05-25T17:51:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "My view here is that, as a general rule, the spec shouldn't expose the encoding to the user unless doing so simplifies the spec. Implementations are of course free to follow a different rule. Following this rule to the letter, we would pick (1). I'm interested to hear other takes here.",
          "createdAt": "2022-05-10T01:36:04Z",
          "updatedAt": "2022-05-10T01:36:04Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "Does the encoding need to be part of the VDAF spec? I.e., couldn't this be defined by the user / the spec of the protocol that wraps a given VDAF? The same holds for input shares, which currently are given as `Bytes`, but where I'd also prefer having a dedicated type, the serialization of which is defined by the outer protocol.",
          "createdAt": "2022-05-10T17:14:05Z",
          "updatedAt": "2022-05-10T17:14:05Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Good question. I don't think there is consensus in the CFRG: some drafts aim to be perspective about encoding, others don't. Thus far this draft has been prescriptive.\r\n\r\nMy personal view is that the specification of a cryptographic algorithm should be as prescriptive as possible. The goal of being prescriptive is to eliminate classes of bugs that occur when two different implementations of the same algorithm try to interoperate. (See https://eprint.iacr.org/2021/923 for a recent example.) Certainly the manner by which VDAF messages are encoded falls into this category. Imagine, for example, that you had a DAF (al a #53) for which one implementation chose big endian encoding of field elements and the other chose little endian.",
          "createdAt": "2022-05-10T19:53:24Z",
          "updatedAt": "2022-05-10T19:53:24Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't want to cut off the discussion on this thread, but I would at least like to ensure that the next draft specifies an encoding of agg shares. This is accomplished by https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/75. There are two questions raised here, which the PR explicitly punts on:\r\n(1) Should all quantities have an explicit type, regardless of whether the type needs to be encoded?\r\n(2) Should the document be prescriptive about encoding?",
          "createdAt": "2022-05-19T22:57:01Z",
          "updatedAt": "2022-05-19T22:57:01Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "> (2) Should the document be prescriptive about encoding?\r\n\r\nI'm okay with ensuring that our current VDAF candidates (Prio3 & Poplar1) specify encodings (so all implementations use the same endianness etc.), but I wouldn't prescribe anything at the VDAF level, and instead leave this to the specs for particular VDAFs.",
          "createdAt": "2022-05-23T16:22:50Z",
          "updatedAt": "2022-05-23T16:22:50Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "I_kwDOGKuqOc5JV1lu",
      "title": "poc: Enforce types",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/59",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Type annotations are used in the reference implementation in order to generate a more readable spec. Currently these type annotations aren't for correctness. For instance, in https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/57, @jbr noticed that type for the verification parameter for Prio3 is not defined.\r\n\r\nIn python3 it's possible to use a static type checker, like https://mypy.readthedocs.io/en/stable/, for this purpose. At the very least, we should extend the unit tests to check that class attributes that are expected to be non-`None` have a value.\r\n\r\nNote that, for the verification parameter in particular, a solution to https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/38 might make this a moot point. However there are many situations for which this would be useful.\r\n",
      "createdAt": "2022-05-10T01:11:18Z",
      "updatedAt": "2022-05-10T02:30:02Z",
      "closedAt": null,
      "comments": [
        {
          "author": "divergentdave",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One other example: GEN_ORDER has a type hint that says \"Unsigned\", but it is actually sage.rings.integer.Integer. This matters because there's a place it is used in single-slash division, and the result is used as an exponent. If it were Unsigned, this would be raising an element to a power of a floating point number, but in reality, the power is a sage rational number, with no fractional part, which is OK. (Thanks to @jbr for catching this)",
          "createdAt": "2022-05-10T02:20:01Z",
          "updatedAt": "2022-05-10T02:20:30Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Ugh, yeah the fact that Sage is effectively \"compiled\" to Python3 makes this issue quite hairy. Then intended semantics of `__div__(self, other)` for `Field` is indeed `self * other.inv()`.\r\n\r\nStill unclear as to whether Sage is really the best choice for the reference implementation/spec. @chris-wood had prepared [a rant for IETF 113](https://datatracker.ietf.org/meeting/113/materials/slides-113-cfrg-cfrg-specifications-in-theory-and-practice-00) that touches on this very question, but we unfortunately ran out of time to give him a full hearing.",
          "createdAt": "2022-05-10T02:29:08Z",
          "updatedAt": "2022-05-10T02:30:02Z"
        }
      ]
    },
    {
      "number": 60,
      "id": "I_kwDOGKuqOc5JV33O",
      "title": "syntax: Have `prep_init()` output the first-round prepare-message share",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/60",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Assuming we:\r\n(1) merge https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/53\r\n(2) resolve https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/19 by removing the public parameter\r\n\r\nthere will be no possibility of a 0-round VDAF. In this case we should consider modifying the VDAF syntax so that `prep_init()` outputs the first prepare-message share. This would resolve some ugliness in the state machine of implementations. For Prio3 for instance, we need to distinguish between a \"Ready\" state and a \"Waiting\" state, where the only difference is whether the prepare-message share has been sent. For example, see libprio-rs: https://github.com/divviup/libprio-rs/blob/main/src/vdaf/prio3.rs#L942-L946\r\n\r\n@tgeoghegan, @divergentdave, I'd love to have your thoughts here. Note that this change would go in the next draft.\r\n",
      "createdAt": "2022-05-10T01:29:40Z",
      "updatedAt": "2022-05-25T17:29:06Z",
      "closedAt": "2022-05-25T17:29:06Z",
      "comments": [
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I buy that this would enable 0-round VDAFs (is a 0-round VDAF the same as a DAF?). Can you sketch out how it affects one-or-more round VDAFs? Would the leader still gather up each helper's prepare message share to then join them and broadcast them back out, or would we take the opportunity to have leader send its prepare message to helper in the first message?",
          "createdAt": "2022-05-10T22:44:30Z",
          "updatedAt": "2022-05-10T22:44:30Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's what I had in mind: https://github.com/cfrg/draft-irtf-cfrg-vdaf/commit/ad5ad030bbe6be7a4ecd109686569fb9b2bbb665\r\n\r\nBasically the main difference is that `prep_next()` always takes in a prepare message, whereas before in the first round the input would be `None`.",
          "createdAt": "2022-05-13T19:21:24Z",
          "updatedAt": "2022-05-13T19:21:24Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems like the options here are isomorphic.\r\n\r\nNew->Old: Since the share contents are defined by the concrete protocol, if a protocol couldn't generate a real share in the first instance, it could send an empty value.\r\n\r\nOld->New: Similarly, in a zero-round VDAF, the protocol could specify that any putatively non-local inputs to `prep_next()` actually have some value that can be computed locally.  Then an aggregator implementing said protocol could just call `prep_init()` and `prep_next()` together to simulate the proposed modification to `prep_init()`.\r\n\r\nAssuming I've got that right, it seems like it doesn't really matter and we should just pick the one that is most natural for the cases we have in hand.",
          "createdAt": "2022-05-18T19:29:08Z",
          "updatedAt": "2022-05-18T19:29:08Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "That's a good way of looking at it, yeah. And I agree they're isomorphic. I think the new syntax would be more natural for the [DAP spec](https://ietf-wg-ppm.github.io/draft-ietf-ppm-dap/draft-ietf-ppm-dap.html#name-input-share-preparation). In particular it would allow us to rewrite\r\n> ```\r\n> prep_state = VDAF.prep_init(vdaf_verify_param, agg_param, nonce, input_share)\r\n> out = VDAF.prep_next(prep_state, None)\r\n> ```\r\n>\r\n> vdaf_verify_param is the public VDAF parameter, and agg_param is the opaque aggregation parameter. If either step fails, the aggregator marks the report as invalid with error vdaf-prep-error.\r\n>\r\n> Otherwise, the value out is interpreted as follows. If this is the last round of the VDAF, then out is the aggregator's output share. Otherwise, out is the pair (prep_state, prep_msg).\r\n\r\nas\r\n\r\n> ```\r\n> (prep_state, prep_msg) = VDAF.prep_init(vdaf_verify_key, agg_id, agg_param, nonce, input_share)\r\n> ```\r\n>\r\n> vdaf_verify_key is the secret VDAF verification key shared by both aggregators, agg_id is equal to `0` for the leader and `1` for the helper, and agg_param is the opaque aggregation parameter. If this step fails, the aggregator marks the report as invalid with error vdaf-prep-error.",
          "createdAt": "2022-05-18T23:31:58Z",
          "updatedAt": "2022-05-18T23:32:14Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure why GH decided to close this based on a PR from libprio getting merged. In any case, I've reopened this because we decided not to merge #73 for draft-01. @schoppmp pointed out that this may end up being a regression if we end up having a 0-round VDAF one day. In particular, in order to account for schemes with public keys we will need to either modify the VDAF syntax (basically revert #62) or define a new object (\"PK-VDAF\" for example). See discussion on #73 for details.",
          "createdAt": "2022-05-25T16:28:01Z",
          "updatedAt": "2022-05-25T16:28:01Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "I_kwDOGKuqOc5JZptR",
      "title": "Split share verification out of preparation phase.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/61",
      "state": "OPEN",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From [previous discussion](https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/53#pullrequestreview-966895328):\r\n\r\nI think it makes sense to split up the preparation (as in, turning an input share into an output share), and the verification.\r\nThe reason is that the outer protocol using a VDAF might want to \"opportunistically\" aggregate shares, in particular for Poplar, where there are many rounds of Preparation, Aggregation, and Unsharding. This would save communication rounds, since the verification on one layer (of the Poplar tree) can be done in parallel with computing the aggregation shares on the next layer. In case a share turns out to be invalid, the corresponding aggregation shares can just be subtracted from the aggregated result.",
      "createdAt": "2022-05-10T17:15:59Z",
      "updatedAt": "2022-05-17T18:57:54Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "If I understand correctly, this suggestion entails a syntactic change where by we allow a VDAF to release unverified output shares early. This gets addressed in Section 4.3](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-00#section-4.3):\r\n\r\n> The preparation-state update accomplishes two tasks: recovery of\r\n   output shares from the input shares and ensuring that the recovered\r\n   output shares are valid.  The abstraction boundary is drawn so that\r\n   an Aggregator only recovers an output share if it is deemed valid (at\r\n   least, based on the Aggregator's view of the protocol).  Another way\r\n   to draw this boundary would be to have the Aggregators recover output\r\n   shares first, then verify that they are valid.  However, this would\r\n   allow the possibility of misusing the API by, say, aggregating an\r\n   invalid output share. Moreover, in protocols like Prio+ [[AGJOP21](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vdaf-00#ref-AGJOP21)]\r\n   based on oblivious transfer, it is necessary for the Aggregators to\r\n   interact in order to recover aggregatable output shares at all.\r\n\r\nBasically this paragraph boils down to two potential objections to this change:\r\n(1) Releasing unverified output shares is unsafe (it's up to the wrapper protocol to ensure correctness)\r\n(2) There may be interesting schemes that are syntactically incompatible with this change (i.e., not all VDAFs an explicit notion of \"verification\").\r\n\r\nPerhaps the key question to address here is whether all schemes we want to deploy *need* to have the same syntax. The [DAP protocol (formerly known as PPM)](https://datatracker.ietf.org/doc/draft-ietf-ppm-dap/) expects that all VDAFs have the same interface so that one can be swapped out for another and re-use the same protocol bits. This is useful for reducing code complexity, but is arguably not essential.\r\n\r\nOne more point to take into account: The purpose of the VDAF syntax in the draft is to (1) guide API design for implementations and (2) define the object of study for security analysis. Ideally our guidance on APIs makes it easy for applications to use VDAFs securely, but there is no reason why the syntax needs to prescribe a particular API. That said, the spec should make clear about the responsibilities that applications take on when they don't follow that guidance.\r\n\r\nWith that in mind, I think there are a few options for accommodating this change:\r\n(a) Adapt the VDAF syntax to accommodate release of unverified output shares and adapt Prio3 and Poplar1 to the new syntax.\r\n(b) Define a new primitive that supports this use case and specify Poplar1 as an instance.\r\n(c) Do noting, but describe this alternative way of implementing Poplar1 and discuss the security considerations for this implementation.\r\n\r\n\r\n\r\n",
          "createdAt": "2022-05-10T20:34:28Z",
          "updatedAt": "2022-05-10T20:34:28Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that (a) would require changes to DAP (formerly known as PPM). We would also want to consider adapting DAP for (c).",
          "createdAt": "2022-05-13T16:00:40Z",
          "updatedAt": "2022-05-17T18:47:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "@schoppmp how much work would it be to produce data indicating the cost of Poplar _without_ this change (released of unverified shares)? I wonder how much of this is premature optimization.",
          "createdAt": "2022-05-17T18:57:54Z",
          "updatedAt": "2022-05-17T18:57:54Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "I_kwDOGKuqOc5JpX4n",
      "title": "Prio3: Investigate eliminating FFT by switching polynomial bases",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/63",
      "state": "OPEN",
      "author": "divergentdave",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We may be able to eliminate FFT polynomial interpolation from sharding and preparation, possibly reducing computational requirements, by switching our polynomials from the monomial basis to the Lagrange basis. See [this post](https://ethresear.ch/t/kate-commitments-from-the-lagrange-basis-without-ffts/6950) for an application of the same trick to pairing-based polynomial commitments. Construction of the wire polynomials in the Lagrange basis would be trivial, `poly_wire_i[j-1](x) = w[0]L0(x) + w[1]L1(x) + ... w[n]Ln(x)`. Given a polynomial in the Lagrange basis and an evaluation point, the evaluation of that polynomial at the given point can be computed with the \"barycentric formula\", see the post above. This is competitive with straightforward monomial basis polynomial evaluation, as it takes one field inversion and a linear number of field multiplications. The rest of the FLP scheme would have to be adapted, but I'm optimistic that this could work.\r\n\r\nIf this is feasible, it would constitute a huge change, but I think it would be good to investigate it eventually.\r\n\r\nRegarding the value of replacing FFT: the input size dependent part of the computational complexity is dominated by the FFT, but how much does it contribute for typical concrete sizes? In the proof-of-concept Sage implementation, for example, FFT sizes range from 2 to 16. Interpolation is measurable, but by and large lost in other overheads. Perhaps the difference will be appreciable if we specify a construction like \"CountVec\", which has many more gadget calls.",
      "createdAt": "2022-05-13T18:59:01Z",
      "updatedAt": "2022-05-13T20:26:04Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Very interesting idea! If I understand correctly, this would be an alternative FLP to `FlpGeneric`, correct? Would any changes to `Prio3` be required?",
          "createdAt": "2022-05-13T19:24:57Z",
          "updatedAt": "2022-05-13T19:24:57Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That sounds right, I think this would only be a change at the FLP level.",
          "createdAt": "2022-05-13T20:13:56Z",
          "updatedAt": "2022-05-13T20:13:56Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "If I were you I would go prototype it in libprio. If we see a significant improvement in prove time and/or proof size (FFT requires us to pad the wire polynomials to the nearest power of 2), then we should 100% consider adding it to the VDAF draft. However I don't think we should consider it a replacement for `FlpGeneric`, at least not until we've had a chance to do a security proof. ",
          "createdAt": "2022-05-13T20:18:14Z",
          "updatedAt": "2022-05-13T20:26:04Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm happy to learn the math and review the code :)",
          "createdAt": "2022-05-13T20:18:39Z",
          "updatedAt": "2022-05-13T20:18:39Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "I_kwDOGKuqOc5J62_r",
      "title": "Define `VERSION` constant for building DSTs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/67",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-01"
      ],
      "body": "DSTs throughout the spec are likely to share a common prefix identifying the version of spec (e.g., \"vdaf-00\"). This common prefix could be defined in Section 2 so that it can be referenced from VDAF definitions. See discussion on #65 for motivation.\r\n\r\ncc/ @tgeoghegan ",
      "createdAt": "2022-05-18T15:51:17Z",
      "updatedAt": "2022-05-19T00:41:45Z",
      "closedAt": "2022-05-19T00:41:45Z",
      "comments": []
    },
    {
      "number": 68,
      "id": "I_kwDOGKuqOc5J65MZ",
      "title": "Add aggregator ID to DAP syntax",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/68",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-01"
      ],
      "body": "This is likely needed to distinguish \"big\" input shares from \"small\" input shares. This would align with https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/62.",
      "createdAt": "2022-05-18T15:57:30Z",
      "updatedAt": "2022-05-19T20:45:59Z",
      "closedAt": "2022-05-19T20:45:59Z",
      "comments": []
    },
    {
      "number": 72,
      "id": "I_kwDOGKuqOc5J9d1v",
      "title": "Miscellaneous tasks before cutting draft-01",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/72",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "draft-01"
      ],
      "body": "* Update test vectors\r\n* Add Change Log section enumerating non-editorial changes from draft-00\r\n* Update VERSION",
      "createdAt": "2022-05-19T00:46:46Z",
      "updatedAt": "2022-05-26T14:09:46Z",
      "closedAt": "2022-05-26T14:09:46Z",
      "comments": []
    },
    {
      "number": 77,
      "id": "I_kwDOGKuqOc5KaRon",
      "title": "Scope Questions: Public-key, Shuffling-based, and Zero-round VDAFs?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/77",
      "state": "OPEN",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There have been a couple of issues around features in hyptothetical VDAFs that are needed by neither Prio3 nor Poplar1.\r\nTwo examples are public-key encryption based VDAFs (which are currently hard to support after the [removal of public parameters ](https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/62)), or [zero-round verification](https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/73). A third would be support for multi-round aggregation protocols that might include shuffling of individual records, to enable something like [IPA](https://docs.google.com/document/u/1/d/1KpdSKD8-Rn0bWPTu4UtK54ks0yv2j22pA5SrAD9av4s/edit).\r\n\r\nAll of these are not supported with the current VDAF syntax, and would require explicit accommodations in higher-level protocols such as [DAP](https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/). The goal of this issue is to discuss and align on the question how much flexibility we want to allow in the VDAF syntax.\r\n\r\nSome preliminary thoughts from a discussion with @cjpatton:\r\n- In general, providing too many options to choose from in protocols leads to security issues due to increased complexity, attack surface, possibility of downgrades, and so forth. If we want to provide flexibility here, we have to ensure that we don't introduce these issues.\r\n- We can't think of all possible syntax needs for hypothetical future constructions that semantically still fit a \"verifiable distributed aggregation function\". How can we extend the VDAF syntax in such cases? Do we instead want to require a new kind of object (e.g., a PK-VDAF that supports public keys), at the risk of not being compatible with higher-level protocols?",
      "createdAt": "2022-05-25T16:58:41Z",
      "updatedAt": "2022-05-25T17:47:17Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": ">    In general, providing too many options to choose from in protocols leads to security issues due to increased complexity, attack surface, possibility of downgrades, and so forth. If we want to provide flexibility here, we have to ensure that we don't introduce these issues.\r\n\r\nI don't think this is a very strong argument in this case. This is not a situation of negotiation but rather where there is a single explicit and verified configuration, but each VDAF (or whatever) runs effectively in parallel.\r\n\r\n> We can't think of all possible syntax needs for hypothetical future constructions that semantically still fit a \"verifiable distributed aggregation function\". How can we extend the VDAF syntax in such cases? Do we instead want to require a new kind of object (e.g., a PK-VDAF that supports public keys), at the risk of not being compatible with higher-level protocols?\r\n\r\nThere are two ways to extend DAP:\r\n\r\n1. Add new VDAFs\r\n2. Extend it to support new non-VDAF constructions\r\n\r\nIf there are new primitives that don't make sense as VDAFs but do make sense in DAP (for instance, IPA, or an ElGamal-based system like that in Adnostic), then we should do that by extending DAP.",
          "createdAt": "2022-05-25T17:15:18Z",
          "updatedAt": "2022-05-25T17:15:18Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "FTR, Adnostic is https://crypto.stanford.edu/adnostic/. There is also AdScale, which is follow-on work: https://isi.jhu.edu/~mgreen/advertising.pdf\r\n\r\nI (currently) agree with EKR, especially in light of our recent experience working VDAFs into DAP. But @schoppmp made one more point, which convinced me that we may not know yet what the best path forward is here.\r\n\r\nIn protocol design it's typical to treat symmetric-key primitives differently from their public-key analogues. For example, a protocol built around symmetric encryption is going to be different from one built around public-key encryption.\r\n\r\nThe current VDAF syntax is specialized for a specific class of schemes. In particular, it does not admit public keys. Following the design principle above, we would want to treat schemes that do (e.g., Adnostic or AdScale) as a different kind of primitive, e.g., a PK-VDAF. However, @schoppmp pointed out that, in the MPC literature, the boundaries between different classes of constructions are more blurry than \"public-key\" versus \"symmetric\".\r\n\r\nBefore making a decision here, it will be helpful to first try to flesh out those classes of constructions that intersect with the PPM working group (and maybe PATCG).",
          "createdAt": "2022-05-25T17:43:49Z",
          "updatedAt": "2022-05-25T17:47:17Z"
        }
      ]
    },
    {
      "number": 82,
      "id": "I_kwDOGKuqOc5KwZJN",
      "title": "Specify agg_param details",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/82",
      "state": "CLOSED",
      "author": "simon-friedberger",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "draft-02"
      ],
      "body": "It should be clear what the type of agg_param is and how it should be handled.\r\nFor specific VDAFs it should probably be clarified when the agg_param needs to be available and how it is distributed.\r\n\r\nSee also ietf-wg-ppm/draft-ietf-ppm-dap/issues/267",
      "createdAt": "2022-05-31T17:54:50Z",
      "updatedAt": "2022-07-09T23:58:22Z",
      "closedAt": "2022-07-09T23:58:22Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Can you be a bit more specific? My take on https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/issues/267 is that DAP treats the agg param as an opaque byte string, but the VDAF does not specify an encoding of this byte string.\r\n\r\nNote that this also relates to https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/58.",
          "createdAt": "2022-05-31T18:12:39Z",
          "updatedAt": "2022-05-31T18:12:39Z"
        },
        {
          "author": "simon-friedberger",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The VDAFs only specify the contents of agg_params globally, e.g. in 7.2 in Table 6.\r\n\r\nDAP could be optimized by precalculating the validation step if it does not need agg_param for this step.\r\n\r\nSo - IIUC - not everything that is called agg_param in DAP will contain the thing that is called agg_param here. The VDAFs should be explicit about which agg_params are needed and for which steps.",
          "createdAt": "2022-05-31T19:58:53Z",
          "updatedAt": "2022-05-31T19:58:53Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Perhaps this is the misunderstanding: In DAP wherever there is a struct with a field `agg_param`, the type of that field is `opaque <0..2^16-1>`.  This is a length-prefixed byte string. There will always be here, even if it's just an empty string. For Prio3 for example, this field would simply be empty (That is, the encoding of `None` as a byte string would simply the empty string. To be clear, this is currently not specified at all.)\r\n\r\nFor some deployments the agg param may be \"predictable\". For Prio3 in particular, the only valid agg param is `None` (i.e., the empty string).",
          "createdAt": "2022-05-31T21:30:47Z",
          "updatedAt": "2022-05-31T21:30:47Z"
        },
        {
          "author": "simon-friedberger",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Let me see if I got this right now....\r\n\r\n`run_vdaf` in Figure 7 uses `agg_param` in\r\n* `prep_init`\r\n* `prep_shares_to_prep`\r\n* `out_shares_to_agg_share`\r\n* `agg_shares_to_result`\r\nbut there is no statement about how `agg_param` would get distributed in a system like DAP. If some of the functions only need parts of `agg_param`, or some of them can be empty, the specific VDAF (so Chapter 7 and Chapter 8) should specify that.\r\n\r\n1. Prio3\r\nIn Prio3 `agg_param` is empty so it's simple because it can be defined task wide in DAP and sending empty messages is the cheapest anyway.\r\n* `task.agg_param = None`\r\n* `CollectReq.agg_param = None`\r\n* `AggregateInitializeReq.agg_param = None`\r\n* `AggregateShareReq.agg_param = None`\r\nWhich conveniently makes them all the same and the same as in the VDAF.\r\n\r\n2. Poplar1\r\nIn Poplar1 `agg_param` contains the candidate prefixes and, iiuc, needs to be provided by the DAP collector in `CollectReq.agg_param`.\r\nSo here we would end up with something like\r\n* `task.agg_param = None`\r\n* `CollectReq.agg_param = candidate_prefixes`\r\n* `AggregateInitializeReq.agg_param = CollectReq.agg_param`\r\n* `AggregateShareReq.agg_param = None`\r\nespecially, they are not all the same.\r\n\r\nImho, since the field in DAP is opaque this is okay, but we should clarify in DAP that the `agg_params` are not all the same.\r\nAnd for the VDAF examples, we should specify how to get the different AggParams for the different steps.",
          "createdAt": "2022-06-01T08:09:04Z",
          "updatedAt": "2022-06-01T08:09:04Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "* What is `task.agg_param`?\r\n* The value of `AggregateShareReq.agg_param` is supposed to match `CollectReq.agg_param`. Does the DAP spec say otherwise?",
          "createdAt": "2022-06-01T14:23:32Z",
          "updatedAt": "2022-06-01T14:23:32Z"
        },
        {
          "author": "simon-friedberger",
          "authorAssociation": "CONTRIBUTOR",
          "body": "`task.agg_param` is just a name I gave it. The spec lists it here: \r\n\r\n> The basic unit of DAP is the \"task\" which represents a single measurement\r\n(though potentially taken over multiple time windows). The definition of a task\r\nincludes the following parameters:\r\n> * The type of each measurement.\r\n> * The aggregation function to compute (e.g., sum, mean, etc.) and an optional\r\n  aggregation parameter.\r\n\r\n`AggregateShareReq.agg_param` might be the same as `CollectReq.agg_param`. The spec says nothing on the topic.\r\n\r\nWas your intention that all the `agg_param`s in DAP should also be the same?",
          "createdAt": "2022-06-01T14:29:32Z",
          "updatedAt": "2022-06-01T14:29:32Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Ohh ok, this text is at least misleading, if not flat out wrong:\r\n```\r\nThe aggregation function to compute (e.g., sum, mean, etc.) and an optional\r\naggregation parameter.\r\n```\r\n\r\nIt's not as if there is a single agg param that's used for every collect request for a given task. The Collector is supposed to be able to choose each agg param based on previous agg results.\r\n\r\nWhat we are trying to get at here is that some agg functions have an an additional input that we call the \"agg param\".\r\n\r\n> AggregateShareReq.agg_param might be the same as CollectReq.agg_param. The spec says nothing on the topic.\r\n\r\nThen this needs to be fixed. Please send a PR! \r\n\r\n> Was your intention that all the agg_params in DAP should also be the same?\r\n\r\nYes.",
          "createdAt": "2022-06-01T14:36:25Z",
          "updatedAt": "2022-06-01T14:36:38Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I suspect this issue is solved in DAP by https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/pull/282, so I will close this. @simon-friedberger, feel free to re-open if you think there is something else that needs to be done.",
          "createdAt": "2022-07-09T23:58:22Z",
          "updatedAt": "2022-07-09T23:58:22Z"
        }
      ]
    },
    {
      "number": 83,
      "id": "I_kwDOGKuqOc5LadY5",
      "title": "Can we support Prio3Aes128CountVec?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/83",
      "state": "OPEN",
      "author": "qiuxiangcassie",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "### Why\r\nWith Prio3Aes128CountVec, each measurement is a vector of integers in `[0,2)` and the aggregate is the element-wise sum. This is very helpful for supporting some use cases, e.g., checkbox survey question.\r\n\r\n### Discussions\r\nBased on discussions in the chat group, there are some potential concerns with the trade-off between proof generation time and proof size. \r\n\r\n- If the circuit has arithmetic degree 3. The proof generation will be expensive. The proof size is O(sqrt(N)).\r\n- If the circuit has arithmetic degree 2. The proof generation is faster but the proof size is O(N)",
      "createdAt": "2022-06-08T19:54:09Z",
      "updatedAt": "2022-06-09T00:59:40Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "For context, `Prio3Aes128CountVec` refers to a Prio3 variant implemented in libprio-rs.\r\n\r\nI've added some benchmarks to libprio-rs that allow us to roughly compare these two proof systems. (See https://github.com/divviup/libprio-rs/pull/243.) The latter, which has degree 2 and proof size O(N), is very similar to what's used in ENPA today. I'll call this `Prio2`. `Prio3Aeas128CountVecMultithreaded` is a variant of `Prio3Aes128CountVec` that implements the same proof system but parallelizes part of the computation. The field used for each is `Field128`.\r\n\r\nReported times are from my 2.6 GHz 6-Core Intel Core i7 laptop.\r\n\r\ninput size: 10 (number of field elements)\r\n| System | proof size | generation time | query time |\r\n| ------- | ------ | ----- | ----- |\r\n| Prio2 | 29 | 10us | 12us |\r\n| Prio3Aes128CountVec | 28 | 21us | 15us |\r\n| Prio3Aes128CountVecMultithreaded | 28 | 67us | 15us |\r\n\r\ninput size: 100\r\n| System | proof size | generation time | query time |\r\n| ------- | ------ | ----- | ----- |\r\n| Prio2 | 231 | 76us | 58us |\r\n| Prio3Aes128CountVec | 66 | 121us | 39us |\r\n| Prio3Aes128CountVecMultithreaded | 66 | 146us | 37us |\r\n\r\ninput size: 1,000\r\n| System | proof size | generation time | query time |\r\n| ------- | ------ | ----- | ----- |\r\n| Prio2 | 2,027 | 678us | 528us |\r\n| Prio3Aes128CountVec | 252 | 3020us | 375us |\r\n| Prio3Aes128CountVecMultithreaded | 252 | 1001us | 366us |\r\n\r\ninput size: 10,000\r\n| System | proof size | generation time | query time |\r\n| ------- | ------ | ----- | ----- |\r\n| Prio2 | 26,387 | 14.9ms | 10.7ms |\r\n| Prio3Aes128CountVec | 582 | 21.4ms | 2.5ms |\r\n| Prio3Aes128CountVecMultithreaded | 582 | 6.3ms | 2.5ms |",
          "createdAt": "2022-06-08T21:34:20Z",
          "updatedAt": "2022-06-09T00:59:40Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "I_kwDOGKuqOc5LftGp",
      "title": "Specify Poplar1 VDAF",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/84",
      "state": "CLOSED",
      "author": "tgeoghegan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "draft-02"
      ],
      "body": "An upcoming draft-irtf-cfrg-vdaf should fully specify Poplar1.",
      "createdAt": "2022-06-09T20:10:19Z",
      "updatedAt": "2022-07-11T21:00:31Z",
      "closedAt": "2022-07-11T21:00:31Z",
      "comments": []
    },
    {
      "number": 89,
      "id": "I_kwDOGKuqOc5L9DhU",
      "title": "Field element decoding: check that the inputs are fully reduced",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/89",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [
        "bug",
        "draft-02"
      ],
      "body": "@armfazh pointed this out here: https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/88#discussion_r899660677",
      "createdAt": "2022-06-17T00:39:37Z",
      "updatedAt": "2022-07-11T21:13:02Z",
      "closedAt": "2022-07-11T21:13:02Z",
      "comments": []
    },
    {
      "number": 90,
      "id": "I_kwDOGKuqOc5MP7Qf",
      "title": "Field element encoding: Accommodations for `GF(2^255-19)`",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/90",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As of #88, we'll use `GF(2^255-19)` for the leaf node field for `IdpfPoplar`. This field is a natural choice because it is close to the security level cited by [the paper](https://eprint.iacr.org/2021/017) and there are already a number of implementations of it already. (E.g., https://github.com/cloudflare/circl/tree/master/math/fp25519.) However, this choice surfaces an issue related to field element encoding that needs discussion.\r\n\r\nFirst, the manner in which field elements are represented as byte strings matters for two reasons:\r\n1. In `Prio3`, vectors of field elements are encoded and used for key derivation. In general, it's likely that the VDAF draft will have cryptographic computations that depend on encoded field elements.\r\n2. So far we have opted to be prescriptive about the encoding of any value that would be written to the network by some application. For example, input shares and prep messages all have a fully-specified encoding. For additional discussion, see #58.\r\n\r\n@armfazh [points out](https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/88#discussion_r899660677) that implementations of `GF(2^255-19)` typically operate directly on little-endian byte-strings (https://github.com/cloudflare/circl/blob/master/math/fp25519/fp.go#L14). The current draft uses `I2OSP()` from RFC 3447 for encoding field elements, which is big-endian. This is makes it inconvenient to use these implementations for `IdpfPoplar`, as they will be required to re-order the byte strings in order to encode them properly. This is unlikely to be a performance issue, but is potentially a source of bugs.\r\n\r\nA related question raised by this issue is whether little-endian is somehow \"better\" for optimized finite field arithmetic. Perhaps using `I2OSP()` is an anti-pattern, given current trends in cryptographic code design?\r\n\r\nHere are a few ways we might resolve this issue:\r\n\r\n1. Keep the current big-endian encoding for all fields. In order to be compatible with the draft, an implementation of `IdpfPoplar` that uses an existing implementation of `GF(2^255-19)` may need to adjust the encoding.\r\n2. Use little-endian for all fields. This would make it convenient to use existing implementations of `GF(2^255-19)`. Of course, this would require changing the other fields defined in the draft. However, these fields are new and there are no optimized implementations of them yet. (For what it's worth, the choice to use `I2SOP()` was somewhat arbitrary.  We noticed that it was used for other drafts, like [hash-to-curve](https://datatracker.ietf.org/doc/draft-irtf-cfrg-hash-to-curve/), and it seemed like a good idea to crib on prior work.)\r\n3. Allow each field to specify its own encoding. The potential downside here is code complexity. (It's nice when there is only one way to do a thing.)\r\n4. If we decide not to be prescriptive about encoding (cf. #58), then this is issue is somewhat less relevant. However we would still need to specify how to encode field elements that are used as inputs to other cryptographic operations. This may or may not end up mattering for `GF(2^255-19)`.",
      "createdAt": "2022-06-21T23:41:24Z",
      "updatedAt": "2022-06-22T05:46:10Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Currently I'm inclined to take option (2.), but I would like to understand better why `I2SOP()` was designed the way it is. As it comes from [RFC 3447](https://datatracker.ietf.org/doc/html/rfc3447), we can infer that it was developed in a world in which all keys read from the wire are RSA moduli. In this world, big-endian probably seems sensible because it would allow you consume the RSA modulus from the wire one byte a time without buffering it. This is less relevant to us because we need to decode numbers whose sizes are constant (cf. `Field.ENCODED_SIZE`) and relatively small (<=32 bytes).",
          "createdAt": "2022-06-21T23:47:08Z",
          "updatedAt": "2022-06-21T23:47:08Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Here are my two cents,\r\nI think is better do not to specify any encodings, unless they are part of the _cryptographic protocol_ (and not of the communication protocol).\r\nFor example, if some element needs to be serialized because it will be an input of a hash function, then an encoding should be explicitly enforced. (here it does not matter which on is used).\r\n\r\nApplications could be free to choose the encoding for the communication protocol. For interoperability between applications an encoding could be recommended, but not enforced.\r\nFor test vectors, an encoding could be chosen only for the test code.",
          "createdAt": "2022-06-22T01:41:32Z",
          "updatedAt": "2022-06-22T01:41:32Z"
        },
        {
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I2OSP seems to be omnipresent in all crypto libraries, mainly due to RSA and friends.\r\n\r\nThe little-endian seems to be relevant for Fp25519 and other optimized implementations. But in fact, optimized implementations actually represent field elements with multiple words and with redundancy, so the byte representation is not so important and it is only used at transport.\r\n",
          "createdAt": "2022-06-22T01:46:35Z",
          "updatedAt": "2022-06-22T01:46:35Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> Here are my two cents, I think is better do not to specify any encodings, unless they are part of the _cryptographic protocol_ (and not of the communication protocol). For example, if some element needs to be serialized because it will be an input of a hash function, then an encoding should be explicitly enforced. (here it does not matter which on is used).\r\n\r\nAs I mentioned at the top, in Prio3, vectors of field elements are used as input for a hash function.\r\n\r\n\r\n",
          "createdAt": "2022-06-22T03:45:23Z",
          "updatedAt": "2022-06-22T05:46:10Z"
        }
      ]
    },
    {
      "number": 92,
      "id": "I_kwDOGKuqOc5MmB6-",
      "title": "Pass the number of reports to agg_shares_to_result()",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/92",
      "state": "CLOSED",
      "author": "divergentdave",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "divergentdave"
      ],
      "labels": [
        "draft-02"
      ],
      "body": "Inspired by the discussion on divviup/libprio-rs#256, I propose that the number of reports should be added as an argument to `agg_shares_to_result()` for DAFs and VDAFs. This would be useful in Prio for any AFE where the encoding does not preserve the additive identity. (or doesn't map some other identity to the additive identity) In such cases, then the unsharding algorithm could cancel out whatever constant term got added by every client's input. Any application using VDAF should already know how many reports contributed to one aggregate, we just need to expose it back down to the VDAF layer.\r\n\r\nNote that this would also enable computing an average \"inside the VDAF\" rather than computing a sum and leaving it to the application to compute the average from that. This is more trivial than remapping [-1, 1] to [0, 2^n], as in the example that motivated this.\r\n\r\nWhile it would be technically possible for an application to reverse the [-1, 1] to [0, 2^n] mapping, if given just a raw sum from Prio and a priori knowledge of the number of reports (by dividing by 2^(n-1) and subtracting num_reports), I think it would be more user-friendly if we made it possible for the unsharding step to do so. The postprocessing necessary for the averaging use case is easy enough to write out by hand, this fixed-point with offset encoding is slightly more difficult, but generally, AFE encodings could include multiple such encoded numbers, or even nonlinear functions composed with affine remappings. (The Prio paper includes examples of calculating a product or geometric mean. This would be done by taking a logarithm of the input, and this logarithm would most likely need to be encoded as a fixed point number with an offset.) For this reason, I think we should provide this number of reports to `agg_shares_to_result()`, so that unsharding can be \"as powerful as\" sharding, and applications won't have to concern themselves as much with the encoding details of particular more complicated VDAFs.\r\n\r\ncc @MxmUrw",
      "createdAt": "2022-06-26T21:35:47Z",
      "updatedAt": "2022-07-10T00:13:06Z",
      "closedAt": "2022-07-10T00:13:05Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "This sounds like a reasonable change to me. My only worry would be scope creep, however a (V)DAF already explicitly defines the type of aggregate result, so I don't this actually changes the scope of the draft. It seems like this is likely to be useful for other types as well.\r\n\r\nBarring objections from @schoppmp or @bifurcation, I think this is a clear win. Would either @divergentdave or @MxmUrw care to start working on a PR? Ideally this PR would also make the corresponding change to the reference implementation.",
          "createdAt": "2022-06-27T18:32:04Z",
          "updatedAt": "2022-06-27T18:32:04Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure, I can write one up later this week",
          "createdAt": "2022-06-27T18:45:33Z",
          "updatedAt": "2022-06-27T18:45:33Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good, no objection from my side.",
          "createdAt": "2022-06-28T11:27:46Z",
          "updatedAt": "2022-06-28T11:27:46Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by #95.",
          "createdAt": "2022-07-10T00:13:05Z",
          "updatedAt": "2022-07-10T00:13:05Z"
        }
      ]
    },
    {
      "number": 94,
      "id": "I_kwDOGKuqOc5MvfOB",
      "title": "Accommodations for differential privacy",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/94",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We wish for the VDAF draft to have first-class support for schemes that are amendable to differential privacy (DP). The task for this issue is to identify what changes need to be made, if any, to accommodate DP. In addition, we should consider adding guidance to the draft about best practices.",
      "createdAt": "2022-06-28T15:22:45Z",
      "updatedAt": "2022-07-08T14:47:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "At a minimum, I imagine we will need a way for:\r\n(a) an Aggregator to add noise to its aggregate share\r\n(b) a Client to add noise to its measurement\r\n\r\n(a) is straight-forward for both Prio3 and Poplar1 since the aggregate shares are vectors over some finite field. In general, I think all we'll need syntactically is that the set of all aggregate shares form a (semi-)group. The mechanism for (b) seems like it'll depend somewhat on the measurement type.\r\n",
          "createdAt": "2022-06-28T15:28:20Z",
          "updatedAt": "2022-06-28T15:28:20Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My intuition is that (b) would be out of scope for [V]DAF or DAP since the DP would be applied before `Vdaf.measurement_to_input_shares` and removed after `Vdaf.agg_shares_to_result`. So long as a noised input is still a valid encoding of a measurement, VDAF doesn't need to know about the DP, right?",
          "createdAt": "2022-06-28T17:20:26Z",
          "updatedAt": "2022-06-28T17:20:26Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that's probably right, except it may be desirable to add noise to the aggregate shares (a).",
          "createdAt": "2022-06-28T17:22:32Z",
          "updatedAt": "2022-06-28T17:24:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "Yeah, I think I agree with @tgeoghegan here. I think it makes sense to add discussion to this draft as to how clients might add local DP, and how, for example, deployments might use shuffling to amplify that DP effect, but both seem outside the scope of the draft. In contrast, (a) being an application of central DP seems like something squarely in scope?",
          "createdAt": "2022-06-28T17:33:45Z",
          "updatedAt": "2022-06-28T17:33:45Z"
        },
        {
          "author": "simon-friedberger",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe I am misunderstanding but I think for heavy hitters the distribution complicates things. Some of the finite field vector values are just too unlikely.\r\n\r\nIf I flip a bit in \"https://www.facebook.com\" I might end up with \"https://www.fa{ebook.com\" which doesn't add meaningful privacy from a client point of view and makes the value almost useless from a collector point of view.\r\n\r\nTo clarify: The client has no good way of adding DP randomness here for (b). For (a) the servers could still adjust the count for \"https://www.facebook.com\" by random +/-10 when computing the Private Subset Histogram solution for that string. So, doing (b) would also be difficult here.",
          "createdAt": "2022-06-29T12:16:29Z",
          "updatedAt": "2022-06-29T12:23:35Z"
        },
        {
          "author": "csharrison",
          "authorAssociation": "NONE",
          "body": "Note I wrote a bit of my thoughts on how we might want to do this in the DAP repo at https://github.com/ietf-wg-ppm/draft-ietf-ppm-dap/issues/19#issuecomment-1118837160.\r\n\r\nA few relevant points from that discussion:\r\n- Do we even want to add noise addition to VDAF vs. specify it in DAP (my preference is to do it in VDAF)\r\n- Are we concerned about malicious helpers adding \"bad\" noise shares such that we would want to \"verify\" the noise shares (I think we don't need this given our threat model)\r\n\r\n@simon-friedberger I agree for the heavy hitters problem the client side noise addition is difficult. Your observation that a single bit flip in \"facebook.com\" doesn't add privacy is correct, the DP analysis would agree with you. You need to flip many bits in the entire (high entropy) output domain. However, remember that the privacy that we get is stronger than just the noise from a single client, we just want to achieve good privacy after aggregation (when everything is back in cleartext).\r\n\r\nThe biggest problem I see with client-side noise is that the poplar protocol (as far as I can tell) only really works with one-hot input vectors. This means that a RAPPOR-like randomizer similar to [ENPAs](https://covid19-static.cdn-apple.com/applications/covid19/current/static/contact-tracing/pdf/ENPA_White_Paper.pdf) which randomly flips many bits independently in the whole domain would mean constructing tons of dpf keys (scaling linearly with the domain size) on the client for each noisy \"1\", leading to large communication and processing overhead.\r\n\r\nThere may be solutions here using different local randomizers, but I think it's hard to get around the domain size problem (e.g. regular randomized response will guarantee you that you only send a one-hot vector, but then the _noise_ scales with the domain size)",
          "createdAt": "2022-06-29T13:47:27Z",
          "updatedAt": "2022-06-29T13:47:27Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "For what it's worth, the [Poplar paper](https://arxiv.org/pdf/2012.14884.pdf) describes how to add noise for (a) in Appendix E. It may be the case that this is sufficient for reasonable measures of privacy, without requiring the client to do anything.",
          "createdAt": "2022-06-29T15:05:24Z",
          "updatedAt": "2022-06-29T15:05:34Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for bumping that thread, @csharrison.\r\n\r\n> * Do we even want to add noise addition to VDAF vs. specify it in DAP (my preference is to do it in VDAF)\r\n\r\nI agree, I think the mechanism needs to live in VDAF-land. However, ideally this would require only minimal syntax changes (e.g., as suggested for (a) here: https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/94#issuecomment-1168872702) and would leave it up to applications (like a DAP deployment) to tune noise as needed. The VDAF draft could also provide detailed recommendations for adding local DP, or central DP, or both (if applicable) to the VDAFs it specifies.\r\n\r\n> * Are we concerned about malicious helpers adding \"bad\" noise shares such that we would want to \"verify\" the noise shares (I think we don't need this given our threat model)\r\n\r\nI think this threat model only matters insofar as it impacts privacy. For correctness, we already concede that all of the Aggregators are trusted to execute the protocol correctly.\r\n\r\n",
          "createdAt": "2022-06-29T15:07:52Z",
          "updatedAt": "2022-06-29T15:10:54Z"
        },
        {
          "author": "csharrison",
          "authorAssociation": "NONE",
          "body": "> For what it's worth, the [Poplar paper](https://arxiv.org/pdf/2012.14884.pdf) describes how to add noise for (a) in Appendix E. It may be the case that this is sufficient for reasonable measures of privacy, without requiring the client to do anything.\r\n\r\nYeah this is the standard way we'd add DP in the central model. I think there may be ways to optimize the noise in that section with (discretized) gaussian/skellam noise instead of Laplace too (see https://desfontain.es/privacy/gaussian-noise.html for an intro). \r\n\r\nI also think that section assumes each noisy prefix is published publicly, which I don't think is necessarily the view of the collector in the poplar vdaf (would need to double check that).",
          "createdAt": "2022-06-29T16:04:22Z",
          "updatedAt": "2022-06-29T16:06:46Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@schoppmp and I have been working on completing the spec for Poplar1 (#84). Once that's done, I think a great first step would be to add a subsection that spells out recommendations for adding DP to the heavy hitters computation. @csharrison would you be willing to spend time on this?\r\n\r\nAlternatively, we could get cracking on Prio3 right away.",
          "createdAt": "2022-06-29T16:24:15Z",
          "updatedAt": "2022-06-29T16:33:15Z"
        },
        {
          "author": "csharrison",
          "authorAssociation": "NONE",
          "body": "> @schoppmp and I have been working on completing the spec for Poplar1 (#84). Once that's done, I think a great first step would be to add a subsection that spells out recommendations for adding DP to the heavy hitters computation. @csharrison would you be willing to spend time on this?\r\n\r\nI am actually on pat leave right now until late Aug so unfortunately I can't spend much time on this (just enough free time to bug ya'll on issues \ud83d\ude04 )  . Let's just make sure what's specified in the poplar paper is possible and I might be able to help out when I get back. In general, I think we want to consider:\r\n- Alternative noise mechanisms other than Laplace (this should be pretty simple)\r\n- Configurations where noise is only added at the last step of the heavy hitters protocol, vs. adding it to every prefix and publishing those prefixes publicly (this means that a malicious server could publish non-DP prefix counts, which may be OK in some deployments).",
          "createdAt": "2022-06-29T17:16:51Z",
          "updatedAt": "2022-06-29T17:20:54Z"
        },
        {
          "author": "kunal-talwar",
          "authorAssociation": "NONE",
          "body": "I think it would be worth supporting both (a) and (b). \r\nFor (a), having an option to add central DP noise to the aggregate makes sense, and can perhaps be implemented as part of Daf.out_shares_to_agg_share() and this can be specified in each VDAF.\r\nFor (b): there are many ways of doing local randomization which are compatible with prio/poplar. In particular, for frequency estimation / heavy hitters, when working over a small universe, RAPPOR can be used in conjunction with pro. Over larger universes, PI-RAPPOR (https://arxiv.org/abs/2102.12099) and ProjectiveResponse (https://arxiv.org/abs/2203.00194) can be used to randomize to a one-hot vector over a smaller domain. This makes these well-compatible with prio or poplar, and I could imagine, for example, pi-rappor+poplar to be a useful VDAF.\r\nThe shuffling/aggregation based privacy amplification results though depend on a the batch over which we are summing to be large enough. This application therefore would make a strong case to have the min_batch_size be a natively supported feature in DAP. E.g. it would be great to have a way for the task parameter to specify just the minimum batch size and have the servers agree on a batch boundary that is close to getting this minimum batch size, without having to predict the batch interval in advance.",
          "createdAt": "2022-06-29T21:24:37Z",
          "updatedAt": "2022-06-29T21:24:37Z"
        },
        {
          "author": "csharrison",
          "authorAssociation": "NONE",
          "body": "@kunal-talwar I would love to hear more about how concretely we could compose e.g. pi-rappor with poplar. It seems very non-obvious to me but I might be missing something. In pi-rappor we're sending some seed to the server, are you saying we'd encode this seed as a one-hot vector and aggregate over seeds in the VDAF?\r\n\r\nI hadn't seen the paper on ProjectiveReponse, will need to read it \ud83d\ude04 . In general though I agree with you about supporting both (a) and (b). The most obvious candidate requiring (b) support is the existing ENPA system.",
          "createdAt": "2022-06-30T03:15:00Z",
          "updatedAt": "2022-06-30T03:15:00Z"
        },
        {
          "author": "kunal-talwar",
          "authorAssociation": "NONE",
          "body": "It is indeed not obvious (or at least wasn't obvious to me at first). But an approach along the lines you suggested works. We send the seed using poplar, and can either aggregate the seeds, or decode each seed to a vector in the original domain and aggregate those. The generalized version of PI-RAPPOR can allow additional efficiencies on top of this basic approach. We have a write-up that should be on the arxiv in a couple of weeks.",
          "createdAt": "2022-06-30T15:30:44Z",
          "updatedAt": "2022-06-30T15:30:44Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Great discussion, I'm very happy to see engagement on this draft from folks who are deep in differential privacy. Something to keep in mind here is that this document will be developed by the CFRG (\"Cryptography Forum Research Group\"), which, to my knowledge, has not done a lot with DP as of yet. Thus I think a useful goal would be to ensure that (V)DAFs are compatible with a variety of mechanisms for (a) and (b), but without being too prescriptive about a particular mechanism.\r\n\r\nThat said, @kunal-talwar we would welcome text in the document that describes how some of these methods might be applied to either Prio3 or Poplar1. Such text would be maximally useful if it also provided a gentle introduction to the method described.",
          "createdAt": "2022-07-08T14:47:22Z",
          "updatedAt": "2022-07-08T14:47:22Z"
        }
      ]
    },
    {
      "number": 101,
      "id": "I_kwDOGKuqOc5Nj8Zm",
      "title": "Guidance for encoding IDPF index",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/101",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "IDPFs (and Poplar1 by extension) take in an \"index\" `alpha` represented as an `Unsigned`. @bifurcation pointed out in https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/97#discussion_r918280713 that we also call this a \"bit-string\", which is ambiguous. The draft needs guidance on how applications should represent bit strings as IDPF indexes.",
      "createdAt": "2022-07-11T21:48:30Z",
      "updatedAt": "2022-07-11T21:48:51Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 102,
      "id": "I_kwDOGKuqOc5OxfY4",
      "title": "Review: Henry Corrigan-Gibbs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/102",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cjpatton"
      ],
      "labels": [],
      "body": "@henrycg reviewed draft 02 and sent his feedback privately via an email. \r\n\r\n- [x] In the introduction, point out that VDAF can provide DP in addition to MPC-style security. (See also #94.)\r\n- [x] Section 6.1.2: \"Large subgroup\": Say exactly how large the group needs to be. (2^20-ish is going to be sufficient, I think.)\r\n- [x] Section 7.2.2: There is an attack on the soundness of Prio3 stemming from a bug in [the paper](https://eprint.iacr.org/2019/188). The paper has been updated with a patch.\r\n- [ ] Section 7.2.2: Consider using a smaller field and re-running the proof verification multiple times. This would trade communication cost for CPU time.\r\n- [x] Fiat-Shamir: Use circuit codepoints for domain separation.\r\n- [ ] Section 8: We should flag early on in this section that, when used multiple times, Poplar1 has leakage (via prefix hit counts) that other VDAFs don't necessarily suffer from in the same way.\r\n- [ ] Section 8: Discuss hashing construction from Appendix B.",
      "createdAt": "2022-07-28T23:38:49Z",
      "updatedAt": "2022-08-24T22:10:49Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "All tasks for VDAF-03 are complete. What remains are editorial changes and additional security considerations for Poplar1.",
          "createdAt": "2022-08-24T22:10:44Z",
          "updatedAt": "2022-08-24T22:10:44Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "I_kwDOGKuqOc5PCdG0",
      "title": "Prio3: Use circuit ID for domain separation.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/103",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-08-02T15:40:58Z",
      "updatedAt": "2022-08-02T15:41:12Z",
      "closedAt": "2022-08-02T15:41:12Z",
      "comments": []
    },
    {
      "number": 106,
      "id": "I_kwDOGKuqOc5P6OQM",
      "title": "Modeling PrgAes128 as a random oracle",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/106",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In Prio3, `PrgAes128.derive_seed()` is used with a fixed seed for the Fiat-Shamir heuristic. We need to decide if this is safe. It would be sufficient to prove, say, that this function is indifferentiable from a random oracle when modeling AES as an ideal cipher.\r\n\r\nNote that we might end up picking a PRG in #32 that is already safe a safe choice here, in which case we should just replace `PrgAes128`.",
      "createdAt": "2022-08-16T17:24:49Z",
      "updatedAt": "2022-08-24T22:54:18Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 109,
      "id": "I_kwDOGKuqOc5QRUbq",
      "title": "Poplar1 aggregation parameters reveal information about submitted measurements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/109",
      "state": "CLOSED",
      "author": "branlwyd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I believe that Poplar1 aggregation values are sensitive in the sense that they are prefixes of the most common values reported by clients. This makes them the only data exposed to aggregators which directly reveals information about the set of measurements being aggregated.\r\n\r\nAssuming the above is accurate, I think it would be nicer if the aggregators were not exposed to measurement information. Would this be a realistically feasible change?\r\n\r\n(edit: this fell out of discussion on https://github.com/divviup/janus/pull/417)",
      "createdAt": "2022-08-22T16:54:35Z",
      "updatedAt": "2022-08-23T17:17:25Z",
      "closedAt": "2022-08-23T17:10:40Z",
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Unfortunately this problem is inherent to the construction. See the \"Limitations\" subsection from the intro of [the paper](https://eprint.iacr.org/2021/017.pdf).\r\n\r\nIt's possible that there is a different VDAF that doesn't have this issue, but we don't have one today.\r\n\r\n[STAR](https://datatracker.ietf.org/doc/draft-dss-star/) is an alternative to DAP/Poplar1 for computing heavy hitters. It doesn't have the problem of leaking intermediate data to Aggregators, however the trust model is different.",
          "createdAt": "2022-08-23T16:24:19Z",
          "updatedAt": "2022-08-23T16:24:19Z"
        },
        {
          "author": "branlwyd",
          "authorAssociation": "NONE",
          "body": "OK, given that this is a known limitation of poplar1, I don't think leaving an open-but-unresolved/unresolvable issue around is useful. A different VDAF would be nice, but that is a far larger change (and wouldn't be tracked through this issue anyway).",
          "createdAt": "2022-08-23T17:10:40Z",
          "updatedAt": "2022-08-23T17:10:40Z"
        }
      ]
    },
    {
      "number": 110,
      "id": "I_kwDOGKuqOc5QW-a7",
      "title": "Complete IANA considerations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/110",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As of VDAF-03, the draft has codepoints intended to be used by other drafts (e.g., DAP). These are currently summarized in a table `{{codepoints}}`. This is good enough for now, but eventually we'll need to flesh this out into a section that IANA can actually use. @bifurcation points to an example of how to do this properly:  https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/104#discussion_r948280200_",
      "createdAt": "2022-08-23T16:14:29Z",
      "updatedAt": "2022-08-23T16:14:29Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 113,
      "id": "I_kwDOGKuqOc5QeaxT",
      "title": "Merge field parameters into one table",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/113",
      "state": "OPEN",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2022-08-25T00:15:28Z",
      "updatedAt": "2022-08-25T00:15:28Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOGKuqOc4tFEy5",
      "title": "Edits",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/1",
      "state": "MERGED",
      "author": "tgeoghegan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Some clarifications and changes found while reviewing https://github.com/abetterinternet/libprio-rs/pull/93 and checking it against this document.\r\n\r\n- `vdaf_input` returns a vector of input shares rather than a single blob'o'bytes\r\n- make aggregation parameter more obvious in `vdaf_start`\r\n- remove obsolete references to ready and waiting states in Prio3 `vdaf_start` and `vdaf_finish` definitions",
      "createdAt": "2021-10-12T15:29:23Z",
      "updatedAt": "2021-10-12T16:29:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "c667b77422eabbe1cf1c8450f396e5ba54d887c8",
      "headRepository": "tgeoghegan/vdaf",
      "headRefName": "edits",
      "headRefOid": "0b2ae6afa5f8a8473cc5aa7baf6f0cfca206aac9",
      "closedAt": "2021-10-12T16:29:27Z",
      "mergedAt": "2021-10-12T16:29:26Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "d25be886346f3388b1972e540f5f38209e521401"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 2,
      "id": "PR_kwDOGKuqOc4tGzIf",
      "title": "Add an intro",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/2",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-12T21:43:32Z",
      "updatedAt": "2022-05-26T14:58:01Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "810e990a8c6cf03b6b21091d72fd394b6a68a6f9",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "intro",
      "headRefOid": "12e409b59fcbff030a351de55606c562b8dd215d",
      "closedAt": "2021-10-13T21:54:17Z",
      "mergedAt": "2021-10-13T21:54:17Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "9d04d03236a215b29a3e9087159dfa2de1247692"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4uXdKU",
          "commit": {
            "abbreviatedOid": "6d91a58"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This is great! A few comments.",
          "createdAt": "2021-10-12T21:57:25Z",
          "updatedAt": "2021-10-12T22:15:37Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "```suggestion\r\nThe remainder of this document is structured as follows:\r\n```",
              "createdAt": "2021-10-12T21:57:25Z",
              "updatedAt": "2021-10-12T22:15:37Z"
            },
            {
              "originalPosition": 29,
              "body": "This is a pretty good description of systems like RAPPOR, but I think it would be useful to speak about DP more broadly. Roughly speaking, differentially private data aggregation systems guarantee that the degree to which an individual user influences the aggregate output is small.",
              "createdAt": "2021-10-12T22:14:50Z",
              "updatedAt": "2021-10-12T22:15:37Z"
            },
            {
              "originalPosition": 36,
              "body": "In my view, the greater drawback of DP is the need to enforce a privacy budget. ",
              "createdAt": "2021-10-12T22:15:13Z",
              "updatedAt": "2021-10-12T22:15:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 3,
      "id": "PR_kwDOGKuqOc4tG5Ka",
      "title": "Some comments",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/3",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-12T22:12:05Z",
      "updatedAt": "2022-05-26T14:58:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "b23df123f181528e4b1fedbcc231d81e3a707a72",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "rlb-review",
      "headRefOid": "be528b0101facbb7d53bdb18edf3a43b98175441",
      "closedAt": "2021-10-25T14:54:20Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4uXjtC",
          "commit": {
            "abbreviatedOid": "be528b0"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-12T22:32:02Z",
          "updatedAt": "2021-10-12T22:37:46Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "DAFs and VDAFs are meant to be distinct primitives. They differ in two important ways: VDAFs require the aggregators to interact; and DAFs don't provide any guarantee about the validity of the output. DAFs and VDAFs aren't necessarily \"compatible\" with one another. It's true that that there may be some overlap between specific constructions, but this isn't necessarily the case.\r\n\r\nTo be clear, VDAFs are the interesting primitive here. The main reason I defined DAFs is because they are conceptually simpler and provide a nice warm up to VDAFs. Perhaps we should just drop DAFs altogether?",
              "createdAt": "2021-10-12T22:32:02Z",
              "updatedAt": "2021-10-12T22:37:46Z"
            },
            {
              "originalPosition": 17,
              "body": "Validation applies to VDAFs, not DAFs.",
              "createdAt": "2021-10-12T22:32:47Z",
              "updatedAt": "2021-10-12T22:37:46Z"
            },
            {
              "originalPosition": 25,
              "body": "The aggregation parameter is what maps an input to an output. For heavy hitters for example, the aggregation parameter is the set of candidate prefixes. I'll make this more clear.",
              "createdAt": "2021-10-12T22:34:25Z",
              "updatedAt": "2021-10-12T22:37:46Z"
            },
            {
              "originalPosition": 31,
              "body": "Right, the way aggregability is defined currently is that the set of output shares is an algebraic group, and the output is recovered by adding up the output shares. Would defining an explicit \"unsharding\" algorithm be more clear, in your opinion?",
              "createdAt": "2021-10-12T22:35:33Z",
              "updatedAt": "2021-10-12T22:37:46Z"
            },
            {
              "originalPosition": 62,
              "body": "This is something that's a bit in-flux right now. I think where we're going to land is that the client gets a \"public key\" (the \"public parameter\") and each aggregator gets its own \"secret key\" (the \"verification parameter\").",
              "createdAt": "2021-10-12T22:37:02Z",
              "updatedAt": "2021-10-12T22:37:46Z"
            },
            {
              "originalPosition": 72,
              "body": "That's the plan! This is still very much WIP.",
              "createdAt": "2021-10-12T22:37:35Z",
              "updatedAt": "2021-10-12T22:37:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4ugW0-",
          "commit": {
            "abbreviatedOid": "be528b0"
          },
          "author": "ekr",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-14T20:48:19Z",
          "updatedAt": "2021-10-14T20:48:39Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "I think that's the right answer. It would be fine to describe it just in the process of describing a VDAF, but just to motivate the whole thing. The way I usually describe this is to just walk through what it means to be a DAF and then say \"of course you need proofs\" and then talk about the proofs. In this document  I would signal that at the beginning and then just define VDAFs.",
              "createdAt": "2021-10-14T20:48:19Z",
              "updatedAt": "2021-10-14T20:48:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 4,
      "id": "PR_kwDOGKuqOc4tcP5z",
      "title": "WIP: Define VDAF for heavy hitters",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/4",
      "state": "MERGED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-20T13:54:35Z",
      "updatedAt": "2021-10-25T09:29:17Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "fee81313bda6dde38d702c48a09bf2c2e8962c32",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "vdaf_hits",
      "headRefOid": "f319d38c96aea2e7e960fdbf2e9450f68c32c270",
      "closedAt": "2021-10-22T23:27:51Z",
      "mergedAt": "2021-10-22T23:27:51Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "97c3ad0df641cd02734908475fb2de1a5f647e1b"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "It looks like you merged at some point to deal with conflicts. While trying to rebase I gave up and just force-pushed a commit with your patch.",
          "createdAt": "2021-10-22T23:27:08Z",
          "updatedAt": "2021-10-22T23:27:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4uxeF_",
          "commit": {
            "abbreviatedOid": "ed0fa2d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Good start! I left some mostly editorial comments to start. Some high level editorial things: \r\n* `make` fails due to trailing whitespace. Make sure you can run `make` locally and that it builds successfully. (If you've never built an Internet-Draft before, let me know and I can help you get started!)\r\n* Please wrap lines at 80 characters.\r\n\r\nAs for the design:\r\n1. The purpose of the nonce is to allow the aggregators to derive fresh randomness per VDAF evaluation. This randomness could be derived by applying a PRF to the nonce using the key generated for the verification parameters.\r\n2. I'm curious why you allow the caller to specify the group parameters for each level of the tree. I would think it's better if the scheme *prescribed* these parameters. In other words, a concrete IDPF would specify the field parameters of each level of the tree.",
          "createdAt": "2021-10-20T16:19:25Z",
          "updatedAt": "2021-10-20T16:34:35Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "* Replace this reference with `[BBCGGI21, Section 4.3]`\r\n* When this gets compiled, the markdown reference won't appear in the text version. The reference should be added to the  list of informative references at the top of this file.",
              "createdAt": "2021-10-20T16:19:25Z",
              "updatedAt": "2021-10-20T16:34:35Z"
            },
            {
              "originalPosition": 8,
              "body": "Add a newline between headings and the first line.",
              "createdAt": "2021-10-20T16:21:33Z",
              "updatedAt": "2021-10-20T16:34:35Z"
            },
            {
              "originalPosition": 17,
              "body": "?\r\n```suggestion\r\nAn IDPF is defined over a domain of size `2**d`. The client can specify an index `alpha` and values `beta`, one for each level `l` in `[d]`. The key generation generates two IDPF keys that individually hide `alpha` and `beta`. When locally evaluated at any point `x` in `2**l` at level `l`, the IDPF returns shares of `beta[l]`, if `x` is the `l`-bit prefix of `alpha`, and shares of zero otherwise.\r\n```",
              "createdAt": "2021-10-20T16:22:27Z",
              "updatedAt": "2021-10-20T16:34:35Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\n- `idpf_gen(value_types: Vec[ValueType], alpha: int, beta: Vec[Value]) -> (Bytes, Bytes)`: Takes as input the value types describing the IDPF output domains, as well as the index and values for the IDPF. Returns two serialized DPF keys, one for each aggregator.\r\n```",
              "createdAt": "2021-10-20T16:23:35Z",
              "updatedAt": "2021-10-20T16:34:35Z"
            },
            {
              "originalPosition": 21,
              "body": "Should `x` be unsigned? How about `Unsigned` as the type hint, for consistency with the section above?",
              "createdAt": "2021-10-20T16:24:28Z",
              "updatedAt": "2021-10-20T16:34:35Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\n### Malicious sketching for IDPFs\r\n```",
              "createdAt": "2021-10-20T16:26:36Z",
              "updatedAt": "2021-10-20T16:34:35Z"
            },
            {
              "originalPosition": 115,
              "body": "The nonce should be used to generate a seed for the verification randomness vector `r`. For example, in prio3 we have\r\n```python\r\ndef vdaf_start(k_query_init, _, nonce, r_input_share):  \r\n  ...\r\n  k_query_rand = get_key(k_query_init, byte(255) + nonce)\r\n  ...\r\n```\r\n\r\nwhere `k_query_init` is the verification parameter.",
              "createdAt": "2021-10-20T16:29:57Z",
              "updatedAt": "2021-10-20T16:34:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u1kkX",
          "commit": {
            "abbreviatedOid": "cdd7a84"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-21T14:35:44Z",
          "updatedAt": "2021-10-21T14:35:44Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I removed the second reference, since the value type implementation is not really important if we assume that the concrete scheme fixes the types for each level.",
              "createdAt": "2021-10-21T14:35:44Z",
              "updatedAt": "2021-10-21T14:35:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u1kn7",
          "commit": {
            "abbreviatedOid": "cdd7a84"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-21T14:35:55Z",
          "updatedAt": "2021-10-21T14:35:55Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Done.",
              "createdAt": "2021-10-21T14:35:55Z",
              "updatedAt": "2021-10-21T14:35:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u1kr_",
          "commit": {
            "abbreviatedOid": "cdd7a84"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-21T14:36:06Z",
          "updatedAt": "2021-10-21T14:36:07Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Done.",
              "createdAt": "2021-10-21T14:36:06Z",
              "updatedAt": "2021-10-21T14:36:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u1lIl",
          "commit": {
            "abbreviatedOid": "cdd7a84"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-21T14:37:25Z",
          "updatedAt": "2021-10-21T14:37:25Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "Done.",
              "createdAt": "2021-10-21T14:37:25Z",
              "updatedAt": "2021-10-21T14:37:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u3TbU",
          "commit": {
            "abbreviatedOid": "02a855d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-10-21T22:19:46Z",
          "updatedAt": "2021-10-21T22:30:19Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\ndetails. An instantiation of this VDAF specifies a function `get_value_type(n: Unsigned) -> ValueType` that\r\n```",
              "createdAt": "2021-10-21T22:19:47Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nof a given group, and `Value` to refer to an actual element of the group.\r\n```",
              "createdAt": "2021-10-21T22:20:17Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 23,
              "body": "I know we're supposed to be doing everything in Python, but let's just write this as\r\n```suggestion\r\nAn IDPF is defined over a domain of size `2^d`. The client can specify an\r\n```",
              "createdAt": "2021-10-21T22:21:01Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 27,
              "body": "Would it be more accurate to say\r\n```suggestion\r\nWhen locally evaluated at any point `x` in `2**l` at level `l`, the IDPF\r\nkey returns a share of `beta[l]`, if `x` is the `l`-bit prefix of `alpha`, and\r\n```",
              "createdAt": "2021-10-21T22:22:35Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 31,
              "body": "I've been naming the output parameters. How about `-> (idpf_key1: Bytes, idpf_key2: Bytes)` or something?",
              "createdAt": "2021-10-21T22:24:05Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nkeys, one for each aggregator.\r\n```",
              "createdAt": "2021-10-21T22:24:16Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 34,
              "body": "```suggestion\r\n- `idpf_eval_next(state: State, idpf_key: Bytes, x: Unsigned) `\r\n```",
              "createdAt": "2021-10-21T22:25:07Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 44,
              "body": "Above I use \"joint rand\" to refer to randomness shared by the prover and verifier for PCPs. Can we call this something else, like \"verify_rand\"?",
              "createdAt": "2021-10-21T22:26:55Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 44,
              "body": "Here and elsewhere\r\n```suggestion\r\n  r = expand_rand(joint_randomness, len(idpf_output), level)\r\n```",
              "createdAt": "2021-10-21T22:27:10Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 47,
              "body": "Here and below\r\n```suggestion\r\n    [value[0] for value in dpf_output,\r\n```",
              "createdAt": "2021-10-21T22:28:01Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            },
            {
              "originalPosition": 133,
              "body": "I'm having a hard time understanding what's going on here. It seeems like you want the IDPF api to be stateful, but the VDAF api is not. So how does the state of the IPDF get passed through to subsequent VDAF evaluations?\r\n\r\nUnless I'm misunderstanding, I think the answer is that, at least as far as this spec is concerned, the IDPF api needs to be stateless. ",
              "createdAt": "2021-10-21T22:30:13Z",
              "updatedAt": "2021-10-21T22:30:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u42C9",
          "commit": {
            "abbreviatedOid": "dda25de"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T09:56:12Z",
          "updatedAt": "2021-10-22T09:56:12Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "Not sure I understand the statefull / stateless distinction here.\r\nIn the [input evaluation](https://github.com/cjpatton/vdaf/blob/main/draft-patton-cfrg-vdaf.md#input-evaluation) section, it seems like there is an `EvalState` that is kept between the communication rounds between the aggregators. Wouldn't this state also be able to contain the partially evaluated IDPF state? The IDPF-based heavy hitter protocol needs to keep some sort of state between rounds. We could of course emulate that by sending the state back and forth encrypted, but I think that would unnecessarily limit implementations who might want to keep state locally.",
              "createdAt": "2021-10-22T09:56:12Z",
              "updatedAt": "2021-10-22T09:56:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u5Rbs",
          "commit": {
            "abbreviatedOid": "dda25de"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T12:08:41Z",
          "updatedAt": "2021-10-22T12:08:41Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Done.",
              "createdAt": "2021-10-22T12:08:41Z",
              "updatedAt": "2021-10-22T12:08:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u5Rn0",
          "commit": {
            "abbreviatedOid": "dda25de"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T12:09:31Z",
          "updatedAt": "2021-10-22T12:09:31Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Done.",
              "createdAt": "2021-10-22T12:09:31Z",
              "updatedAt": "2021-10-22T12:09:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u5SSE",
          "commit": {
            "abbreviatedOid": "dda25de"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T12:12:40Z",
          "updatedAt": "2021-10-22T12:12:40Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Done.",
              "createdAt": "2021-10-22T12:12:40Z",
              "updatedAt": "2021-10-22T12:12:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u5STf",
          "commit": {
            "abbreviatedOid": "dda25de"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-22T12:12:47Z",
          "updatedAt": "2021-10-22T12:12:47Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Done.",
              "createdAt": "2021-10-22T12:12:47Z",
              "updatedAt": "2021-10-22T12:12:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u7ah-",
          "commit": {
            "abbreviatedOid": "f319d38"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Merging as-is and will iterate on it over the weekend.",
          "createdAt": "2021-10-22T23:27:43Z",
          "updatedAt": "2021-10-22T23:27:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 5,
      "id": "PR_kwDOGKuqOc4tnd68",
      "title": "Finish `hits` specification",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/5",
      "state": "MERGED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-25T10:33:46Z",
      "updatedAt": "2021-10-25T15:56:06Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "a17f7917cbf554c3c50464252c371286561a9040",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "vdaf_hits",
      "headRefOid": "76f086eddda2feba75558d41c381991d873fe17e",
      "closedAt": "2021-10-25T15:55:00Z",
      "mergedAt": "2021-10-25T15:55:00Z",
      "mergedBy": "schoppmp",
      "mergeCommit": {
        "oid": "4ab9d62399dc4b879f592af05cf16c37c0f4eed2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4u-t8t",
          "commit": {
            "abbreviatedOid": "5e545b3"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T14:21:21Z",
          "updatedAt": "2021-10-25T14:32:08Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "No, each aggregator is mean to consume all of the messages sent in the previous round.",
              "createdAt": "2021-10-25T14:21:21Z",
              "updatedAt": "2021-10-25T14:32:08Z"
            },
            {
              "originalPosition": 38,
              "body": "Ack, let's delete my comment then.",
              "createdAt": "2021-10-25T14:22:29Z",
              "updatedAt": "2021-10-25T14:32:08Z"
            },
            {
              "originalPosition": 49,
              "body": "The first is used by the first aggregator and the second is used by the second.",
              "createdAt": "2021-10-25T14:22:57Z",
              "updatedAt": "2021-10-25T14:32:08Z"
            },
            {
              "originalPosition": 61,
              "body": "It does. I went back-and-forth on this and ultimately thought that this is simpler. The reason is that this loop in `run_vdaf` \r\n```\r\n# Aggregators recover their output shares.\r\ninbound = []\r\nfor i in range(ROUNDS+1):\r\n  outbound = []\r\n  for j in range(SHARES):\r\n    outbound.append(eval_states[j].next(inbound))\r\n  inbound = outbound\r\n```\r\n\r\nwould have to be something like\r\n```\r\n# Aggregators recover their output shares.\r\ninbound = []\r\nfor i in range(ROUNDS+1):\r\n  outbound = []\r\n  for j in range(SHARES):\r\n    inbound_for_aggregator = []\r\n    for (k, v) in enumerate(inbound):\r\n      if k != j: inbound_for_aggregator.append(v)\r\n    outbound.append(eval_states[j].next(inbound))\r\n  inbound = outbound\r\n```",
              "createdAt": "2021-10-25T14:30:29Z",
              "updatedAt": "2021-10-25T14:32:08Z"
            },
            {
              "originalPosition": 76,
              "body": "I don't think so, and good catch here. What about passing the aggregation parameter into the constructor here and computing the number of prefixes from that? We'd need to make the same change in the VDAF definition section.",
              "createdAt": "2021-10-25T14:32:00Z",
              "updatedAt": "2021-10-25T14:32:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u-46g",
          "commit": {
            "abbreviatedOid": "5e545b3"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T14:53:21Z",
          "updatedAt": "2021-10-25T14:53:22Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "Changed the definition here.",
              "createdAt": "2021-10-25T14:53:22Z",
              "updatedAt": "2021-10-25T14:53:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u-48u",
          "commit": {
            "abbreviatedOid": "f9fdc26"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T14:53:27Z",
          "updatedAt": "2021-10-25T14:53:28Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Okay, removed my comment.",
              "createdAt": "2021-10-25T14:53:27Z",
              "updatedAt": "2021-10-25T14:53:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u-4-3",
          "commit": {
            "abbreviatedOid": "f9fdc26"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T14:53:33Z",
          "updatedAt": "2021-10-25T14:53:33Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Ack. Removed the comment.",
              "createdAt": "2021-10-25T14:53:33Z",
              "updatedAt": "2021-10-25T14:53:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u-5A2",
          "commit": {
            "abbreviatedOid": "f9fdc26"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T14:53:38Z",
          "updatedAt": "2021-10-25T14:53:39Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Done.",
              "createdAt": "2021-10-25T14:53:38Z",
              "updatedAt": "2021-10-25T14:53:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u-5Kx",
          "commit": {
            "abbreviatedOid": "f9fdc26"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T14:54:07Z",
          "updatedAt": "2021-10-25T14:54:07Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Ack. Removed comment.",
              "createdAt": "2021-10-25T14:54:07Z",
              "updatedAt": "2021-10-25T14:54:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u-6P9",
          "commit": {
            "abbreviatedOid": "962a327"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T14:57:18Z",
          "updatedAt": "2021-10-25T14:57:41Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "As we (ideally!) make clear in the Overview/Definition sections, this document doesn't tell you how to execute the protocol over a network. This function in particular only tells you how you put the pieces together to execute the VDAF over a set of inputs.\r\n\r\nTo make an analogy: VDAF is, in this sense, like an encryption scheme. It doesn't tell *how* to encrypt packets that you send over the network, it just describes a function and its intended properties. ",
              "createdAt": "2021-10-25T14:57:18Z",
              "updatedAt": "2021-10-25T14:57:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u-70M",
          "commit": {
            "abbreviatedOid": "962a327"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T15:01:52Z",
          "updatedAt": "2021-10-25T15:11:55Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "I found this necessary when I did my implemnetation. The reason is that the `verifier_share` is supposed to be a 2-way additive share.",
              "createdAt": "2021-10-25T15:01:52Z",
              "updatedAt": "2021-10-25T15:11:55Z"
            },
            {
              "originalPosition": 47,
              "body": "Resolution: have one party add the first term.",
              "createdAt": "2021-10-25T15:11:52Z",
              "updatedAt": "2021-10-25T15:11:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u_IWT",
          "commit": {
            "abbreviatedOid": "1f0adbf"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T15:41:52Z",
          "updatedAt": "2021-10-25T15:41:52Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Okay. Changed the comment to clarify where the network communication would take place.",
              "createdAt": "2021-10-25T15:41:52Z",
              "updatedAt": "2021-10-25T15:41:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u_IZK",
          "commit": {
            "abbreviatedOid": "1f0adbf"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T15:42:01Z",
          "updatedAt": "2021-10-25T15:42:02Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Done.",
              "createdAt": "2021-10-25T15:42:02Z",
              "updatedAt": "2021-10-25T15:42:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4u_Js9",
          "commit": {
            "abbreviatedOid": "1f0adbf"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-25T15:46:32Z",
          "updatedAt": "2021-10-25T15:46:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 6,
      "id": "PR_kwDOGKuqOc4toxx7",
      "title": "Update authors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/6",
      "state": "MERGED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-25T16:57:11Z",
      "updatedAt": "2022-05-26T14:58:04Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "8d6bc15ea63c534a8398985fbacaf7acc1aad9a9",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "update_authors",
      "headRefOid": "a3e13b02617094cee91ba6a8ef9e3d13724a6ffe",
      "closedAt": "2021-10-25T17:00:39Z",
      "mergedAt": "2021-10-25T17:00:39Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "ee05d18c5cd217354acfa713e0fec79aeec61330"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4u_dkr",
          "commit": {
            "abbreviatedOid": "a3e13b0"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-25T17:00:29Z",
          "updatedAt": "2021-10-25T17:00:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 7,
      "id": "PR_kwDOGKuqOc4tpN7W",
      "title": "RLB refactor of vdaf",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/7",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-25T19:35:28Z",
      "updatedAt": "2022-05-26T14:58:04Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d8059ea57a2d09fbd21842dd297c735584c35887",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "vdaf-refactor",
      "headRefOid": "a96d3c3b163c955abeb56671fc8f1c8ca3aa239f",
      "closedAt": "2021-10-25T20:54:52Z",
      "mergedAt": "2021-10-25T20:54:52Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "29a8ff25572bd9fc4ba400100c1e58332b6e32b3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4vACJz",
          "commit": {
            "abbreviatedOid": "94b96e1"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-25T19:40:51Z",
          "updatedAt": "2021-10-25T20:52:38Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Caption needs updating.",
              "createdAt": "2021-10-25T19:40:51Z",
              "updatedAt": "2021-10-25T20:52:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4vAjVp",
          "commit": {
            "abbreviatedOid": "a96d3c3"
          },
          "author": "ekr",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T22:23:01Z",
          "updatedAt": "2021-10-25T22:26:37Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I don't love this term. Maybe \"Decoding\"?",
              "createdAt": "2021-10-25T22:23:02Z",
              "updatedAt": "2021-10-25T22:26:37Z"
            },
            {
              "originalPosition": 50,
              "body": "Do we need to assume it's randomized?",
              "createdAt": "2021-10-25T22:24:15Z",
              "updatedAt": "2021-10-25T22:26:37Z"
            },
            {
              "originalPosition": 56,
              "body": "Is this always true? Suppose we had a VDAF in which the ZKPs of correctness were publicly verifiable?",
              "createdAt": "2021-10-25T22:25:16Z",
              "updatedAt": "2021-10-25T22:26:37Z"
            },
            {
              "originalPosition": 90,
              "body": "This seems like an unnecessary assumption. It might be true, but it might not be.",
              "createdAt": "2021-10-25T22:26:06Z",
              "updatedAt": "2021-10-25T22:26:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOGKuqOc4wWGea",
      "title": "Add public preprocessing of messages",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/14",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #11.\r\n\r\nThis makes explicit a feature of prio3 and hits that allows applications\r\nto save on bandwidth. At the same time, it does not decrease generality\r\nsince this preprocessing step might simply be a no-op.\r\n\r\nThis change also replaces reference to `vec_zeros()` with\r\n`Field.zeros()`.\r\n",
      "createdAt": "2021-12-28T18:47:12Z",
      "updatedAt": "2022-02-08T16:52:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "71f9481b446f191da17118fd4b82b1a8cf9aa6fd",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/issue11",
      "headRefOid": "bd8b7a4a80336d15980164b1afe731c17bc1f3a2",
      "closedAt": "2022-01-19T17:44:44Z",
      "mergedAt": "2022-01-19T17:44:43Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "6b856956b14b89d70e22ed8fd3655f9521720b14"
      },
      "comments": [
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It seems like this PR is just splitting `next` into two steps that both happen inside the same computer. Why is this useful?\r\n> \r\n> In general, I think the design philosophy should be that the inputs and outputs from these abstract functions should be to the network, i.e., the boundaries that matter are the ones that are visible from the outside. How the processing is arranged inside the computer, between network-observable points, is up to the individual implementation.\r\n\r\nThe idea is that the leader can do the `prep_preprocess` step once and broadcast the result to however many helpers there are, whereas previously, every aggregator would have had to broadcast prep messages to every other aggregator (extra network communication) and then every aggregator would have to run the prep message assembly (extra CPU time). The reduction in network communication is a much more significant win than the reduction of redundant work, but the it's hard to see that communication graph in this specification, because it's all abstracted away behind the `inputs = outputs` step, which in a real deployment would be a big, messy graph with `n^2` edges in it.",
          "createdAt": "2022-01-06T18:40:17Z",
          "updatedAt": "2022-01-06T18:40:17Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "With the current syntax:  In a Leader/Helper communication model, the Leader would request each Helper's next prepare message in one round, then broadcast the entire round of messages to each Helper in the next round.\r\n\r\nWith the changed syntax: Instead of broadcasting all of the messages, the Leader can perform this precomputation step, which for both `prio3` and `poplar1` reduces the amount of data broadcast by a factor of `SHARES`.",
          "createdAt": "2022-01-06T22:28:39Z",
          "updatedAt": "2022-01-06T22:28:39Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to make an executive decision and merge this by Wednesday, 2022/01/19 unless anyone flags objections to this change. ",
          "createdAt": "2022-01-15T00:27:00Z",
          "updatedAt": "2022-01-15T00:27:00Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm OK with this, as long as we agree that the degenerate case where `prep_shares_to_prep` just concatenates the shares is in-bounds (which puts us back in the broadcast posture).",
          "createdAt": "2022-01-18T22:03:51Z",
          "updatedAt": "2022-01-18T22:04:18Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm OK with this, as long as we agree that the degenerate case where `prep_shares_to_prep` just concatenates the shares is in-bounds (which puts us back in the broadcast posture).\r\n\r\nYeah I agree. It would be premature to rule this out.",
          "createdAt": "2022-01-19T00:29:16Z",
          "updatedAt": "2022-01-19T00:29:16Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Squashed. Thanks all for your feedback!",
          "createdAt": "2022-01-19T17:44:29Z",
          "updatedAt": "2022-01-19T17:44:29Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4yIVrb",
          "commit": {
            "abbreviatedOid": "cc28349"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-28T18:48:16Z",
          "updatedAt": "2021-12-28T18:48:16Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Can we think of a better verb than \"preprocess\"? While accurate, it seems too generic.",
              "createdAt": "2021-12-28T18:48:16Z",
              "updatedAt": "2021-12-28T18:48:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yT1lW",
          "commit": {
            "abbreviatedOid": "aa4ebef"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-04T22:25:32Z",
          "updatedAt": "2022-01-05T01:48:26Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Should this be `Optional[Vec[Bytes]]` or is `Bytes` itself a vector of bytes? ",
              "createdAt": "2022-01-04T22:25:32Z",
              "updatedAt": "2022-01-05T01:48:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yUNLA",
          "commit": {
            "abbreviatedOid": "aa4ebef"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-05T02:05:32Z",
          "updatedAt": "2022-01-05T02:05:32Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "`Bytes` is itself a vector of bytes.",
              "createdAt": "2022-01-05T02:05:32Z",
              "updatedAt": "2022-01-05T02:05:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yZl0N",
          "commit": {
            "abbreviatedOid": "aa4ebef"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-06T12:16:36Z",
          "updatedAt": "2022-01-06T12:19:04Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Can you elaborate a bit what the `prep_preprocess` step does and in what cases it is useful? This doesn't become clear from the description currently.",
              "createdAt": "2022-01-06T12:16:36Z",
              "updatedAt": "2022-01-06T12:19:04Z"
            },
            {
              "originalPosition": 29,
              "body": "I agree, in particular the double `pre` prefix is a bit confusing. Maybe `combine_verifier_shares` or something like that?",
              "createdAt": "2022-01-06T12:18:49Z",
              "updatedAt": "2022-01-06T12:19:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4ya-93",
          "commit": {
            "abbreviatedOid": "aa4ebef"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "It seems like this PR is just splitting `next` into two steps that both happen inside the same computer.  Why is this useful?\r\n\r\nIn general, I think the design philosophy should be that the inputs and outputs from these abstract functions should be to the network, i.e., the boundaries that matter are the ones that are visible from the outside.  How the processing is arranged inside the computer, between network-observable points, is up to the individual implementation.",
          "createdAt": "2022-01-06T18:33:55Z",
          "updatedAt": "2022-01-06T18:33:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc4yb1Kk",
          "commit": {
            "abbreviatedOid": "5b0720b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-06T23:18:57Z",
          "updatedAt": "2022-01-06T23:18:58Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I like the term `verifier_share`, but it's somewhat specific to schemes like `prio3` and `poplar1` where the output share are first recovered and then verified. At this stage I'd like to leave the door open for things like Prio+ that are based instead on oblivious transfer. (Output shares aren't known until the prep phase is complete.)",
              "createdAt": "2022-01-06T23:18:58Z",
              "updatedAt": "2022-01-06T23:18:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yb1Xm",
          "commit": {
            "abbreviatedOid": "5b0720b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-06T23:20:42Z",
          "updatedAt": "2022-01-06T23:20:42Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I went with \"prepare-message share\", which is overly wordy but says what we want. The method is now called `prep_share_to_prep`, which is somewhat consistent with our naming conventions else where. \r\n\r\nOther suggestions for alternatives are welcome! (Naming things is hard.) ",
              "createdAt": "2022-01-06T23:20:42Z",
              "updatedAt": "2022-01-06T23:20:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yb1ZF",
          "commit": {
            "abbreviatedOid": "5b0720b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-06T23:20:55Z",
          "updatedAt": "2022-01-06T23:20:55Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I've tacked on a commit that will hopefully make this more clear.",
              "createdAt": "2022-01-06T23:20:55Z",
              "updatedAt": "2022-01-06T23:20:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4y7LBX",
          "commit": {
            "abbreviatedOid": "176ab24"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-17T13:05:33Z",
          "updatedAt": "2022-01-17T13:09:35Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "`transffer` -> `transfer`",
              "createdAt": "2022-01-17T13:05:34Z",
              "updatedAt": "2022-01-17T13:09:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4zAkR7",
          "commit": {
            "abbreviatedOid": "6de0c44"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-18T17:57:39Z",
          "updatedAt": "2022-01-18T17:57:39Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "Done",
              "createdAt": "2022-01-18T17:57:39Z",
              "updatedAt": "2022-01-18T17:57:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 16,
      "id": "PR_kwDOGKuqOc4wiAdr",
      "title": "Rename \"Heavy Hitters\" to \"Poplar\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/16",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The authors of [BBCGGI21] have recently amended their paper to give the\r\nprotocol a proper name.",
      "createdAt": "2022-01-04T21:41:01Z",
      "updatedAt": "2022-02-08T16:52:26Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "84e7b02d3474c2a6fcf79de1c79abacec4d0303f",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/poplar",
      "headRefOid": "5b961d3a0192626bfc66a2ef97b24bb054283cf9",
      "closedAt": "2022-01-06T18:31:40Z",
      "mergedAt": "2022-01-06T18:31:40Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "082a2ed7e5090d2258be98039d51b10f7532900c"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "s/pops/poplar1",
          "createdAt": "2022-01-06T18:31:15Z",
          "updatedAt": "2022-01-06T18:31:15Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4yTwIQ",
          "commit": {
            "abbreviatedOid": "63015f9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-04T21:51:28Z",
          "updatedAt": "2022-01-04T21:51:52Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I would just call this `poplar`, since we just use `prio` for Prio.",
              "createdAt": "2022-01-04T21:51:28Z",
              "updatedAt": "2022-01-04T21:51:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yTwgh",
          "commit": {
            "abbreviatedOid": "63015f9"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-04T21:53:40Z",
          "updatedAt": "2022-01-04T21:53:40Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "In fact we use `prio3` for Prio, so it's not even like there's a 4-letter code convention.",
              "createdAt": "2022-01-04T21:53:40Z",
              "updatedAt": "2022-01-04T21:53:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yTwnd",
          "commit": {
            "abbreviatedOid": "63015f9"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-04T21:54:18Z",
          "updatedAt": "2022-01-04T21:54:19Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "It's tricky because the full-blown heavy hitters protocol is called \"Poplar\". I wanted a distinct name for the underlying VDAF. \"pops\" is the name that @henrycg and I discussed over email.",
              "createdAt": "2022-01-04T21:54:18Z",
              "updatedAt": "2022-01-04T21:54:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yTxF9",
          "commit": {
            "abbreviatedOid": "63015f9"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-04T21:57:09Z",
          "updatedAt": "2022-01-04T21:57:09Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "We could go with something more verbose, like \"poplar-vdaf\".",
              "createdAt": "2022-01-04T21:57:09Z",
              "updatedAt": "2022-01-04T21:57:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yT4NJ",
          "commit": {
            "abbreviatedOid": "63015f9"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-04T22:41:38Z",
          "updatedAt": "2022-01-04T22:41:38Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I prefer `poplar` but I'm happy to defer to you as the author here.",
              "createdAt": "2022-01-04T22:41:38Z",
              "updatedAt": "2022-01-04T22:41:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yT4OR",
          "commit": {
            "abbreviatedOid": "63015f9"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-04T22:41:46Z",
          "updatedAt": "2022-01-04T22:41:46Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc4yT7nH",
          "commit": {
            "abbreviatedOid": "63015f9"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-04T23:07:14Z",
          "updatedAt": "2022-01-04T23:07:14Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I'd like to give folks a chance to mull on it, so we''ll keep this open for now.",
              "createdAt": "2022-01-04T23:07:14Z",
              "updatedAt": "2022-01-04T23:07:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4yZnxO",
          "commit": {
            "abbreviatedOid": "63015f9"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-06T12:27:42Z",
          "updatedAt": "2022-01-06T12:28:54Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I'm not sure about `pops`, at first it looks like it's an acronym, but it isn't. I don't think using `poplar` for both the end-to-end protocol and the VDAF is too much of an issue. Or @cjpatton do you think there will be instantiations of poplar-the-protocol that use a different VDAF? And in that case, couldn't that VDAF be called `poplar2` (the same way the current Prio VDAF is `prio3`?\r\nAlternatively, I think using `poplar-vdaf` (and also changing `prio3` to `prio3-vdaf` or just `prio-vdaf`) is also fine.",
              "createdAt": "2022-01-06T12:27:42Z",
              "updatedAt": "2022-01-06T12:28:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4ya-PU",
          "commit": {
            "abbreviatedOid": "5b961d3"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-06T18:30:28Z",
          "updatedAt": "2022-01-06T18:30:28Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Cool, one more point of agreement :) As discussed in https://github.com/abetterinternet/ppm-specification/pull/177#discussion_r778413433 we're going with `poplar1`, for the same reason you point out.",
              "createdAt": "2022-01-06T18:30:28Z",
              "updatedAt": "2022-01-06T18:30:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 17,
      "id": "PR_kwDOGKuqOc4wiH08",
      "title": "fix typos",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/17",
      "state": "MERGED",
      "author": "tgeoghegan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fix typos encountered while reviewing #14",
      "createdAt": "2022-01-04T22:40:50Z",
      "updatedAt": "2022-01-04T23:03:23Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "2c85aaa13d93b9105bb4139ce501aa9f6dcbdd1b",
      "headRepository": "tgeoghegan/vdaf",
      "headRefName": "typo",
      "headRefOid": "c269414d533f4a20f91d6aca9f25a482e79eacae",
      "closedAt": "2022-01-04T23:03:23Z",
      "mergedAt": "2022-01-04T23:03:23Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "84e7b02d3474c2a6fcf79de1c79abacec4d0303f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4yT7If",
          "commit": {
            "abbreviatedOid": "c269414"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-04T23:03:16Z",
          "updatedAt": "2022-01-04T23:03:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 21,
      "id": "PR_kwDOGKuqOc4x1Ntz",
      "title": "Make re-generation of `verify_params` RECOMMENDED",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/21",
      "state": "MERGED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed in #18, generating `verify_params` in advance may allow an adversary to break correctness if they can corrupt an aggregation server (passively) and a client (actively). This change recommends generating `verify_params` only after a set of client shares has been fixed.",
      "createdAt": "2022-01-31T11:28:30Z",
      "updatedAt": "2022-05-26T14:58:05Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "6b856956b14b89d70e22ed8fd3655f9521720b14",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "regenerate_verify_params",
      "headRefOid": "1f0e87e6161fe5aa02f7945627ae06affc2982f8",
      "closedAt": "2022-02-04T15:22:50Z",
      "mergedAt": "2022-02-04T15:22:49Z",
      "mergedBy": "schoppmp",
      "mergeCommit": {
        "oid": "0412bc0b85f6f35bc510543840ba1a54aa9bfb35"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc4zwKNl",
          "commit": {
            "abbreviatedOid": "d29f39c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-31T18:32:32Z",
          "updatedAt": "2022-01-31T18:32:37Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I'd prefer this text to be in security considerations, along with a short explanation of the threat model being considered.",
              "createdAt": "2022-01-31T18:32:33Z",
              "updatedAt": "2022-01-31T18:32:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4z6ess",
          "commit": {
            "abbreviatedOid": "1f0e87e"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-02T18:42:35Z",
          "updatedAt": "2022-02-02T18:42:35Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Done.",
              "createdAt": "2022-02-02T18:42:35Z",
              "updatedAt": "2022-02-02T18:42:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc4z_lBN",
          "commit": {
            "abbreviatedOid": "1f0e87e"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Perfect, thanks!",
          "createdAt": "2022-02-03T19:17:14Z",
          "updatedAt": "2022-02-03T19:17:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 23,
      "id": "PR_kwDOGKuqOc4x_qJm",
      "title": "prio3 reference implementation (part 1)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/23",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-02T22:54:17Z",
      "updatedAt": "2022-02-03T02:30:38Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "6b856956b14b89d70e22ed8fd3655f9521720b14",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/prio3-wrapper",
      "headRefOid": "1bc6e937680767f7aa7075ac389c624c1899ecd5",
      "closedAt": "2022-02-03T02:30:38Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 24,
      "id": "PR_kwDOGKuqOc4yAQaA",
      "title": "poc: Wrapper bits for prio3",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/24",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-03T04:55:32Z",
      "updatedAt": "2022-02-08T22:16:46Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "5da19ba913c82e3b8c9a4d0cdeaa5fcf6309f778",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/prio3-wrapper",
      "headRefOid": "6d2f6fa590e0ecabaf9825f3aa6f4f086714c9c3",
      "closedAt": "2022-02-08T22:16:39Z",
      "mergedAt": "2022-02-08T22:16:39Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "181607612619efcab9115c5572ec523d364f0a5b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 25,
      "id": "PR_kwDOGKuqOc4yNMJN",
      "title": "Specify a method for deriving pseudorandom field elements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/25",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #13.",
      "createdAt": "2022-02-08T01:15:41Z",
      "updatedAt": "2022-08-26T18:33:11Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d5baf89e87695569f4dbf8d79d9e008fcfc9e79c",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/prg",
      "headRefOid": "24998534b894de7a5aeca6bd7764a81608384225",
      "closedAt": "2022-02-14T20:28:15Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Re-opening this PR with a new base.",
          "createdAt": "2022-02-14T20:28:15Z",
          "updatedAt": "2022-02-14T20:28:15Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 26,
      "id": "PR_kwDOGKuqOc4yRjBk",
      "title": "prio3: Don't generate joint randomness if JOINT_RAND_LEN == 0",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/26",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #15.",
      "createdAt": "2022-02-09T03:58:04Z",
      "updatedAt": "2022-02-09T04:35:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "0ed776f687b2592820af150416a30ed16dbab7da",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/joint-rand-len",
      "headRefOid": "94a9986bc29be2455f998dd60eec9091186fbf03",
      "closedAt": "2022-02-09T04:35:39Z",
      "mergedAt": "2022-02-09T04:35:39Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "5de2062ac1f1524a9ce8e23c08a24938c5f32fc1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 27,
      "id": "PR_kwDOGKuqOc4ydh-y",
      "title": "prio3: Specify the generic FLP",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/27",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Specification of the \"generic FLP\", an extension of Theorem 4.3 from [BBCGGI19]. This proof system is implemented by https://github.com/abetterinternet/libprio-rs/blob/main/src/pcp.rs.\r\n\r\n2022/2/10: This PR is marked as \"draft\" for now, as it'll need a few more clean-up passes before it's ready to merge. I wanted to have something up early so @chris-wood has something to work off of for the reference implementation.\r\n2022/23/14: Ready to merge.",
      "createdAt": "2022-02-11T02:25:06Z",
      "updatedAt": "2022-08-26T18:33:20Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d8cf35917ab6556cc5e7514a05569136fad23d1e",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/flp",
      "headRefOid": "bea5fd53554b10103a8ec92e4ebe1b820d6dd41c",
      "closedAt": "2022-02-25T19:40:13Z",
      "mergedAt": "2022-02-25T19:40:13Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "58d3bf725cbf33c83667f14f1d83746bbaf13fab"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc40_UD0",
          "commit": {
            "abbreviatedOid": "4b80527"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-21T18:38:43Z",
          "updatedAt": "2022-02-25T17:40:54Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Is this really a requirement, or simply something that's nice to have?",
              "createdAt": "2022-02-21T18:38:43Z",
              "updatedAt": "2022-02-25T17:40:54Z"
            },
            {
              "originalPosition": 129,
              "body": "```suggestion\r\nover the input. For VDAFs, this computation is distributed amongst multiple Aggregators, \r\neach of which has only a share of the input.\r\n```",
              "createdAt": "2022-02-21T18:42:49Z",
              "updatedAt": "2022-02-25T17:40:54Z"
            },
            {
              "originalPosition": 191,
              "body": "I'd hint at how these are fixed (for FFT friendliness) somehow.",
              "createdAt": "2022-02-21T18:57:55Z",
              "updatedAt": "2022-02-25T17:40:54Z"
            },
            {
              "originalPosition": 282,
              "body": "I wouldn't use the term arity in this document, even if it's technically correct. I would use something simpler, i.e., the gadgets input counts. ",
              "createdAt": "2022-02-21T19:07:59Z",
              "updatedAt": "2022-02-25T17:40:54Z"
            },
            {
              "originalPosition": 358,
              "body": "```suggestion\r\n1. For each `G` in `Valid.GADGETS` create an empty table `wire_i`.\r\n```",
              "createdAt": "2022-02-21T19:32:15Z",
              "updatedAt": "2022-02-25T17:40:54Z"
            },
            {
              "originalPosition": 331,
              "body": "```suggestion\r\n* For each `i` in `len(Valid.GADGETS)`:\r\n```",
              "createdAt": "2022-02-21T19:35:10Z",
              "updatedAt": "2022-02-25T17:40:54Z"
            },
            {
              "originalPosition": 336,
              "body": "```suggestion\r\n    * Let `alpha_i = Field.gen()^(Field.GEN_ORDER / P_i)`\r\n```",
              "createdAt": "2022-02-21T19:35:20Z",
              "updatedAt": "2022-02-25T17:40:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41Sivj",
          "commit": {
            "abbreviatedOid": "1e8ee51"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T19:00:54Z",
          "updatedAt": "2022-02-25T19:00:55Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "As noted here, this is required for the generic FLP construction, in particular because it uses the group generator to pick the points used to construct the gadget polynomials. It would be possible to pick these points differently, but that would be a different construction.\r\n\r\nAnother option is to make these fixed points a parameter. I see no reason to do this, however.",
              "createdAt": "2022-02-25T19:00:55Z",
              "updatedAt": "2022-02-25T19:00:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41SjHt",
          "commit": {
            "abbreviatedOid": "1e8ee51"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T19:02:17Z",
          "updatedAt": "2022-02-25T19:02:17Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "Done",
              "createdAt": "2022-02-25T19:02:17Z",
              "updatedAt": "2022-02-25T19:02:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41Sj78",
          "commit": {
            "abbreviatedOid": "1e8ee51"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T19:06:06Z",
          "updatedAt": "2022-02-25T19:06:06Z",
          "comments": [
            {
              "originalPosition": 191,
              "body": "Done",
              "createdAt": "2022-02-25T19:06:06Z",
              "updatedAt": "2022-02-25T19:06:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41Sj_a",
          "commit": {
            "abbreviatedOid": "1e8ee51"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T19:06:22Z",
          "updatedAt": "2022-02-25T19:06:23Z",
          "comments": [
            {
              "originalPosition": 282,
              "body": "Ack",
              "createdAt": "2022-02-25T19:06:23Z",
              "updatedAt": "2022-02-25T19:06:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41SkBt",
          "commit": {
            "abbreviatedOid": "1e8ee51"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T19:06:31Z",
          "updatedAt": "2022-02-25T19:06:31Z",
          "comments": [
            {
              "originalPosition": 358,
              "body": "Ack",
              "createdAt": "2022-02-25T19:06:31Z",
              "updatedAt": "2022-02-25T19:06:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41SkDe",
          "commit": {
            "abbreviatedOid": "1e8ee51"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T19:06:39Z",
          "updatedAt": "2022-02-25T19:06:39Z",
          "comments": [
            {
              "originalPosition": 331,
              "body": "Ack",
              "createdAt": "2022-02-25T19:06:39Z",
              "updatedAt": "2022-02-25T19:06:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41SkFo",
          "commit": {
            "abbreviatedOid": "1e8ee51"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T19:06:48Z",
          "updatedAt": "2022-02-25T19:06:48Z",
          "comments": [
            {
              "originalPosition": 336,
              "body": "Done",
              "createdAt": "2022-02-25T19:06:48Z",
              "updatedAt": "2022-02-25T19:06:48Z"
            }
          ]
        }
      ]
    },
    {
      "number": 28,
      "id": "PR_kwDOGKuqOc4y0Ao1",
      "title": "Specify an instantiation of `Prg`",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/28",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Specifies a construction based on AES128. While pretty straight-forward,\r\nthis scheme uses CMAC, which is not widely used. We may want to provide\r\nadditional options in the future.",
      "createdAt": "2022-02-14T20:33:31Z",
      "updatedAt": "2022-05-26T14:58:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "582c3a58e8c9a8c6c9fb1763b52ed4de98b3d248",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/prg-constructions",
      "headRefOid": "33d5930607a3853cb701e768314ec7f27fda2e76",
      "closedAt": "2022-02-28T16:07:42Z",
      "mergedAt": "2022-02-28T16:07:42Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "5b832679851002485c004c461948491837624102"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> This will likely be called often, but with small `length`s, right? In that case I believe constructions based on [fixed-key AES hashing](https://eprint.iacr.org/2019/074.pdf) should be more efficient, since they avoid repeating the AES key schedule. In the paper there is a tweakable version (using two AES calls) that can be used to derive new seeds for different `info` strings.\r\n\r\nGreat question. There are two key schedules:\r\n* One for CMAC. The same key is used for each blockcipher call, including for generating the subkey K1 (or K2, depending on the length of the message.) See https://datatracker.ietf.org/doc/html/rfc4493#section-2.2.\r\n* One for CTR.\r\n\r\nEventually the cumulative cost of AES costs will outstrip the cost of the initial setup of these two key schedules, so the question is whether we reach this point in our code. There are at least two cases to consider: \r\n1. In #31, each `length` passed to `prg.next()` is small, but we call `prg.next()` many times. Hence the computational cost will be dominated in `AES128-CTR()`.\r\n2. In prio3, we use `Prg.derive()` as a PRF. Here the input is long (though not as long as in (1.)), but the output is short. Hence the computational cost will be dominated by `AES128-CMAC()`.\r\n\r\nMy hunch is that we cross this threshold fairly quickly for (1.), but I'm not so sure about (2.). I think this is something worth benchmarking in any case.\r\n\r\nI suggest we put a pin in this for now. I'll mark this is an \"OPEN ISSUE\" in the text and we can open an issue for tracking benchmarking of various PRGs.\r\n\r\n\r\n",
          "createdAt": "2022-02-25T19:38:12Z",
          "updatedAt": "2022-02-25T19:38:12Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I've added a pointer to https://github.com/cjpatton/vdaf/issues/32 to the text.",
          "createdAt": "2022-02-25T19:50:52Z",
          "updatedAt": "2022-02-25T19:50:52Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "> I suggest we put a pin in this for now. I'll mark this is an \"OPEN ISSUE\" in the text and we can open an issue for tracking benchmarking of various PRGs.\r\n\r\nSounds good, thanks!",
          "createdAt": "2022-02-28T11:33:20Z",
          "updatedAt": "2022-02-28T11:33:20Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc40lRkI",
          "commit": {
            "abbreviatedOid": "7b4e1f9"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-14T21:05:30Z",
          "updatedAt": "2022-02-14T21:07:15Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\ngenerating the output. A fixed initialization vector (IV) is used.\r\n```",
              "createdAt": "2022-02-14T21:05:30Z",
              "updatedAt": "2022-02-14T21:07:15Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\n    # a fixed, all-zero IV.\r\n```",
              "createdAt": "2022-02-14T21:05:55Z",
              "updatedAt": "2022-02-14T21:07:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41SkO8",
          "commit": {
            "abbreviatedOid": "9c80897"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This will likely be called often, but with small `length`s, right? In that case I believe constructions based on [fixed-key AES hashing](https://eprint.iacr.org/2019/074.pdf) should be more efficient, since they avoid repeating the AES key schedule. In the paper there is a tweakable version (using two AES calls) that can be used to derive new seeds for different `info` strings.",
          "createdAt": "2022-02-25T19:07:29Z",
          "updatedAt": "2022-02-25T19:07:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc41WDWq",
          "commit": {
            "abbreviatedOid": "33d5930"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-28T11:33:30Z",
          "updatedAt": "2022-02-28T11:33:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 29,
      "id": "PR_kwDOGKuqOc4y0B4C",
      "title": "Use \"pad-then-reduce\" method for generating field elements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/29",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #13 by taking @armfazh' suggestion.\r\n\r\nSpecifies an algorithm for mapping a pseudorandom byte string to a\r\nvector of field elements. This method is based on the \"hash_to_field\"\r\nalgorithm from draft-irtf-cfrg-hash-to-curve-13.",
      "createdAt": "2022-02-14T20:39:05Z",
      "updatedAt": "2022-08-26T18:33:12Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d8cf35917ab6556cc5e7514a05569136fad23d1e",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/field-elem-gen-1",
      "headRefOid": "159d7a217560682d1a2c249fe5c89b555014dfeb",
      "closedAt": "2022-02-25T16:13:08Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed in favor of #31.\r\n",
          "createdAt": "2022-02-25T16:13:08Z",
          "updatedAt": "2022-02-25T16:13:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc40lUK4",
          "commit": {
            "abbreviatedOid": "6cdf917"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-14T21:17:14Z",
          "updatedAt": "2022-02-14T21:18:13Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "... The second one generates a sequence of field elements from a pseudorandom byte string. Such a generation is based on ...",
              "createdAt": "2022-02-14T21:17:14Z",
              "updatedAt": "2022-02-14T21:18:13Z"
            },
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n  per field element when expanding a seed into a sequence of field elements\r\n```",
              "createdAt": "2022-02-14T21:17:40Z",
              "updatedAt": "2022-02-14T21:18:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc40lWor",
          "commit": {
            "abbreviatedOid": "6cdf917"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-14T21:28:10Z",
          "updatedAt": "2022-02-14T21:28:11Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Done",
              "createdAt": "2022-02-14T21:28:10Z",
              "updatedAt": "2022-02-14T21:28:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 30,
      "id": "PR_kwDOGKuqOc4y0PEW",
      "title": "Use \"borrow-then-reduce\" method for generating field elements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/30",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #13 by taking @schoppmp's suggestion.\r\nAlternative to #29.\r\n\r\nSpecifies an algorithm for a mapping pseudorandom byte string to a\r\nvector of field elements. The algorithm was ported from google's IDPF\r\nimplementation.",
      "createdAt": "2022-02-14T21:39:21Z",
      "updatedAt": "2022-08-26T18:33:14Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d8cf35917ab6556cc5e7514a05569136fad23d1e",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/field-elem-gen-2",
      "headRefOid": "734b67651a3aea4156e840f12bbb1e21e0f0a81b",
      "closedAt": "2022-02-25T16:12:52Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed in favor of #31.",
          "createdAt": "2022-02-25T16:12:52Z",
          "updatedAt": "2022-02-25T16:12:52Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc40la8c",
          "commit": {
            "abbreviatedOid": "734b676"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-14T21:46:55Z",
          "updatedAt": "2022-02-14T21:46:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc41Hfoi",
          "commit": {
            "abbreviatedOid": "734b676"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-23T14:25:28Z",
          "updatedAt": "2022-02-23T14:30:04Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "This can be (length-1) * L + P, since the first sample is taken by reducing r directly, and we don't need to \"fill up\" r at the last iteration.",
              "createdAt": "2022-02-23T14:25:28Z",
              "updatedAt": "2022-02-23T14:30:04Z"
            },
            {
              "originalPosition": 40,
              "body": "This reduction mod 2**P is only needed because Python uses BigInt, right? In that case it might be more efficient to first use a mask to zero out the highest L*8 bits of r, and then do the left-shift. That way we'll only ever use P bits.",
              "createdAt": "2022-02-23T14:28:47Z",
              "updatedAt": "2022-02-23T14:30:04Z"
            },
            {
              "originalPosition": 41,
              "body": "As written above, this is not needed in the last iteration, so we can save L random bytes.",
              "createdAt": "2022-02-23T14:29:09Z",
              "updatedAt": "2022-02-23T14:30:04Z"
            },
            {
              "originalPosition": 36,
              "body": "Assuming the constructor doesn't fail when r > Field.MODULUS. Maybe make the modulo reduction explicit here?",
              "createdAt": "2022-02-23T14:29:51Z",
              "updatedAt": "2022-02-23T14:30:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41KhCb",
          "commit": {
            "abbreviatedOid": "734b676"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-24T03:43:14Z",
          "updatedAt": "2022-02-24T03:43:14Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Yup this this is because Python is bigint.",
              "createdAt": "2022-02-24T03:43:14Z",
              "updatedAt": "2022-02-24T03:43:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41KhIU",
          "commit": {
            "abbreviatedOid": "734b676"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-24T03:44:08Z",
          "updatedAt": "2022-02-24T03:44:09Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "The `Field(.)` constructor does the reduction, as documented above. But I think it would make sense to make this explicit.",
              "createdAt": "2022-02-24T03:44:08Z",
              "updatedAt": "2022-02-24T03:44:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41KhJr",
          "commit": {
            "abbreviatedOid": "734b676"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-24T03:44:23Z",
          "updatedAt": "2022-02-24T03:44:23Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Good call! I'll fix if we end up merging.",
              "createdAt": "2022-02-24T03:44:23Z",
              "updatedAt": "2022-02-24T03:44:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 31,
      "id": "PR_kwDOGKuqOc4zcDuH",
      "title": "Use \"rejection sampling\" for generating field elements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/31",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #13 by doing \"rejection sampling\". This an alternative to #29 and #30.",
      "createdAt": "2022-02-25T00:50:34Z",
      "updatedAt": "2022-08-26T18:33:21Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "58d3bf725cbf33c83667f14f1d83746bbaf13fab",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/prg-rejection-sampling",
      "headRefOid": "d6b3965cc36026bd77a2e4fb2f60853f76e39e5d",
      "closedAt": "2022-02-25T19:42:17Z",
      "mergedAt": "2022-02-25T19:42:16Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "7d74148aa7d2d8b8bfaf0346d0289ee318ed4801"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc41Ral0",
          "commit": {
            "abbreviatedOid": "e995fa5"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T14:41:59Z",
          "updatedAt": "2022-02-25T14:46:19Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Please add some info about what we expect from the output, e.g.\r\n`\r\nThe bytes returned are uniformly pseudorandom when the PRG was constructed with a uniformly random seed.\r\n`",
              "createdAt": "2022-02-25T14:41:59Z",
              "updatedAt": "2022-02-25T14:46:19Z"
            },
            {
              "originalPosition": 31,
              "body": "Can you add some information for why this is needed? Also please add that the seed MUST have high entropy.",
              "createdAt": "2022-02-25T14:44:46Z",
              "updatedAt": "2022-02-25T14:46:19Z"
            },
            {
              "originalPosition": 37,
              "body": "Same as above, please make sure that this is always used in a safe way by requiring that the seed MUST have high entropy and be only used once.",
              "createdAt": "2022-02-25T14:46:12Z",
              "updatedAt": "2022-02-25T14:46:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41Rq8D",
          "commit": {
            "abbreviatedOid": "e995fa5"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T15:31:44Z",
          "updatedAt": "2022-02-25T15:42:27Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Done. I also stipulated that the random seed might be an output of a previous call to the PRG.\r\n\r\n",
              "createdAt": "2022-02-25T15:31:44Z",
              "updatedAt": "2022-02-25T15:42:27Z"
            },
            {
              "originalPosition": 31,
              "body": "The intended usage is explained above:\r\n> Each `Prg` has two derived class methods. The first is used to derive a fresh seed from an existing one.\r\n\r\nIf you want to see this get used, search for `Prg.derive` in the prio3 section.\r\n\r\nHigh entropy ins't going to be sufficient for all PRGs, in particular for those constructed from a pseudorandom permutation (e.g., AES). I stipulated the same requirement for securely generating seeds as above.",
              "createdAt": "2022-02-25T15:38:44Z",
              "updatedAt": "2022-02-25T15:42:27Z"
            },
            {
              "originalPosition": 37,
              "body": "It depends on the PRG construction, but it should be secure to reuse the same seed with different \"info\" strings. That is, the intent of the \"info\" string is to provide domain separation.\r\n\r\nHere I stipulated the same requirements for generating the seed as above.",
              "createdAt": "2022-02-25T15:42:19Z",
              "updatedAt": "2022-02-25T15:42:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41SfHc",
          "commit": {
            "abbreviatedOid": "5f2e71e"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-25T18:44:28Z",
          "updatedAt": "2022-02-25T18:49:29Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "The current documentation sounds good, thanks!",
              "createdAt": "2022-02-25T18:44:29Z",
              "updatedAt": "2022-02-25T18:49:29Z"
            },
            {
              "originalPosition": 28,
              "body": "Maybe add a note about `info` and domain separation?",
              "createdAt": "2022-02-25T18:48:42Z",
              "updatedAt": "2022-02-25T18:49:29Z"
            },
            {
              "originalPosition": 37,
              "body": "Okay, let's maybe add a short sentence on this to the documentation (see comment above).",
              "createdAt": "2022-02-25T18:49:13Z",
              "updatedAt": "2022-02-25T18:49:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc41Sq74",
          "commit": {
            "abbreviatedOid": "5f2e71e"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-25T19:39:40Z",
          "updatedAt": "2022-02-25T19:39:41Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Done",
              "createdAt": "2022-02-25T19:39:41Z",
              "updatedAt": "2022-02-25T19:39:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 33,
      "id": "PR_kwDOGKuqOc4zfPGd",
      "title": "Acknoweledge Armando",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/33",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-25T21:40:36Z",
      "updatedAt": "2022-05-26T14:58:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "7d74148aa7d2d8b8bfaf0346d0289ee318ed4801",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/ack-armando",
      "headRefOid": "636e7ac818170194489b089a42464537c16a59e0",
      "closedAt": "2022-02-25T21:56:07Z",
      "mergedAt": "2022-02-25T21:56:07Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "03f3ac2114e8e728518728d30b6adb9c8902aedc"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 34,
      "id": "PR_kwDOGKuqOc4zvzEs",
      "title": "poc: Implement the generic FLP",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/34",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "fyi/ @chris-wood",
      "createdAt": "2022-03-01T18:50:27Z",
      "updatedAt": "2022-05-26T14:58:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "5b832679851002485c004c461948491837624102",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/poc-flp-generic",
      "headRefOid": "8a7f6f9e1ac9c122dfb1d02b588f24302e15b42d",
      "closedAt": "2022-03-01T18:52:08Z",
      "mergedAt": "2022-03-01T18:52:08Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "65cc1df73c94a074e6d651b0e831dfe7af80917d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 35,
      "id": "PR_kwDOGKuqOc4zwmLF",
      "title": "prio3: Add domain separation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/35",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Bind the derivation of field elements to the document name and the\r\n\"suite\", consisting of the PRG and FLP.",
      "createdAt": "2022-03-01T23:19:35Z",
      "updatedAt": "2022-05-26T14:58:25Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "7d12cac116bcb084c81d0f1ea64eca9f0fa271ba",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/prio3-test-vec",
      "headRefOid": "573b8be2128537d2a09073a8fbca2ba1224fc2e3",
      "closedAt": "2022-03-01T23:57:14Z",
      "mergedAt": "2022-03-01T23:57:14Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "34a51dd9ac5504e03b2bb5c418677bcea7f1238c"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "fyi/ @tgeoghegan ",
          "createdAt": "2022-03-01T23:19:44Z",
          "updatedAt": "2022-03-01T23:19:44Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 36,
      "id": "PR_kwDOGKuqOc4z2cbN",
      "title": "poc: Library compatibility",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/36",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This fixes a couple hiccups I ran into when running the Sage implementation with some older libraries from my distro. (sagemath 9.0-1ubuntu4 and python3-pycryptodome 3.6.1-2build4) I added a fallback to import PyCryptodome from either of its supported names, and added a conversion from `sage.rings.integer.Integer` to `int` in one place. The second change addresses a ctypes error I got from a PyCryptodome call; presumably newer versions of Sage cooperate with ctypes better on type coercion.",
      "createdAt": "2022-03-02T19:46:31Z",
      "updatedAt": "2022-03-02T23:34:15Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d8fcbfb639dcdeec80ece097e5012b992dade63e",
      "headRepository": "divergentdave/vdaf",
      "headRefName": "poc-library-compatibility",
      "headRefOid": "ab6d5fc2ae36e293d363952dbb36c982b73e348e",
      "closedAt": "2022-03-02T22:56:10Z",
      "mergedAt": "2022-03-02T22:56:10Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "dff2553f17b13b41a39e66509388a2e29c270df9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc41h_EH",
          "commit": {
            "abbreviatedOid": "ab6d5fc"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-02T19:58:19Z",
          "updatedAt": "2022-03-02T19:58:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 37,
      "id": "PR_kwDOGKuqOc4z-2-t",
      "title": "Edits and test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/37",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-03-05T01:06:59Z",
      "updatedAt": "2022-05-26T14:58:22Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "29840fd017e6dc9103d1fa996475e0ccaa71d222",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/edit-01",
      "headRefOid": "50717f2d973df8279267dff8a1df28f9f5373ebf",
      "closedAt": "2022-03-05T01:21:39Z",
      "mergedAt": "2022-03-05T01:21:39Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "3a2892a558703f66df671f03355d3e65b86e98fd"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 41,
      "id": "PR_kwDOGKuqOc41LJBc",
      "title": "Small fix to prime selection script",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/41",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This fixes a small bug in the prime searching script. Previously, it would skip candidate q values, since it decremented q by i, rather than check each `2^(n-k)-i`. In the interest of completeness, we now check each possible value.",
      "createdAt": "2022-03-28T17:58:47Z",
      "updatedAt": "2022-06-02T16:37:52Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d5d51ef9f7e990229ffa4b2fec624634ad398aa6",
      "headRepository": "divergentdave/vdaf",
      "headRefName": "david/prime-search",
      "headRefOid": "784285e500334e1f5cf5769aaa72fc36fb05996b",
      "closedAt": "2022-04-06T19:15:20Z",
      "mergedAt": "2022-04-06T19:15:19Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "439c2fe9ce67fb858bf3f05d84db2682e4e7f84c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc43Iwmv",
          "commit": {
            "abbreviatedOid": "784285e"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for checking :) Note that there is still time to pick new primes if we so choose.",
          "createdAt": "2022-03-29T18:12:57Z",
          "updatedAt": "2022-03-29T18:12:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 43,
      "id": "PR_kwDOGKuqOc41ge3l",
      "title": "Editorial changes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/43",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This collects some editorial changes throughout the document.\r\n\r\n1. Mention section 7 in the overview\r\n2. Link syntax\r\n3. Stray punctuation\r\n4. \"values `beta`\" appeared to be a singular/plural disagreement the first time I read it, until later reading that `beta` is itself a pair of values. This change identifies that at its introduction.\r\n5. Wrong variable in pseudocode\r\n6. Further explanation of how the correlation shares could be compressed\r\n7. Typo in pseudocode\r\n8. Copyediting",
      "createdAt": "2022-04-01T18:40:51Z",
      "updatedAt": "2022-06-02T16:37:32Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d5d51ef9f7e990229ffa4b2fec624634ad398aa6",
      "headRepository": "divergentdave/vdaf",
      "headRefName": "david/editorial-revisions",
      "headRefOid": "a8acb4c4402c37f2627135a325ec3b8e6163e434",
      "closedAt": "2022-04-06T19:15:09Z",
      "mergedAt": "2022-04-06T19:15:09Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "6cf02ebad34b670870b9c14a6b4f471ecd065c9b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc43q6YF",
          "commit": {
            "abbreviatedOid": "a8acb4c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-06T19:14:51Z",
          "updatedAt": "2022-04-06T19:14:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 46,
      "id": "PR_kwDOGKuqOc42u5Uw",
      "title": "Update authors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/46",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "* Sort authors alphabetically\r\n* Change Chris P.'s email address",
      "createdAt": "2022-04-25T14:51:03Z",
      "updatedAt": "2022-05-26T14:58:21Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "6904d4a6295da82daf7ecd09c094326db4fb8ccd",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/auth-update",
      "headRefOid": "85474e233519f4abb43ead5600585f46d8b9829f",
      "closedAt": "2022-04-25T15:23:20Z",
      "mergedAt": "2022-04-25T15:23:20Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "15c6abadc46d760a2b39a5708492a195fb4ee2e9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc44vohI",
          "commit": {
            "abbreviatedOid": "85474e2"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-25T14:58:24Z",
          "updatedAt": "2022-04-25T14:58:24Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc44vzZ5",
          "commit": {
            "abbreviatedOid": "85474e2"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-25T15:23:15Z",
          "updatedAt": "2022-04-25T15:23:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 49,
      "id": "PR_kwDOGKuqOc425hi2",
      "title": "Move draft to CFRG",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/49",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-04-27T19:54:36Z",
      "updatedAt": "2022-05-26T14:58:21Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "15c6abadc46d760a2b39a5708492a195fb4ee2e9",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/move-to-cfrg",
      "headRefOid": "f331520a313462d00c2d953c486c475c78fa834b",
      "closedAt": "2022-04-27T20:01:45Z",
      "mergedAt": "2022-04-27T20:01:45Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "404d2e2110d3d3703e2c289bdf6ec25a03939d2d"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation, @schoppmp, FYI: I'm moving this document to draft-irtf-cfrg-vdaf-00.",
          "createdAt": "2022-04-27T20:01:14Z",
          "updatedAt": "2022-04-27T20:01:14Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 50,
      "id": "PR_kwDOGKuqOc425xcU",
      "title": "Update links after moving repo",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/50",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-04-27T21:14:13Z",
      "updatedAt": "2022-05-26T14:58:20Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "404d2e2110d3d3703e2c289bdf6ec25a03939d2d",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/update-links",
      "headRefOid": "3ea87c6fad8d0b4d24f0716cd73a00afe1912375",
      "closedAt": "2022-04-27T21:16:01Z",
      "mergedAt": "2022-04-27T21:16:01Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "515905df41d7d8a499480f7ee15d75d975c4ac83"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 52,
      "id": "PR_kwDOGKuqOc426Ooa",
      "title": "fix duplicated JOINT_RAND_LEN",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/52",
      "state": "MERGED",
      "author": "jbr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "closes #51 ",
      "createdAt": "2022-04-28T00:34:18Z",
      "updatedAt": "2022-04-28T03:38:05Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "515905df41d7d8a499480f7ee15d75d975c4ac83",
      "headRepository": "jbr/draft-irtf-cfrg-vdaf",
      "headRefName": "poc-fix-flp-duplication",
      "headRefOid": "bc64a0bcd926a0bc4b74be255990e680e743c201",
      "closedAt": "2022-04-28T03:38:05Z",
      "mergedAt": "2022-04-28T03:38:05Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "ca421e5064d2767319006cfd8007fa9ad65ef60b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc449oq3",
          "commit": {
            "abbreviatedOid": "bc64a0b"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Nice catch. Thanks!",
          "createdAt": "2022-04-28T00:40:41Z",
          "updatedAt": "2022-04-28T00:40:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 53,
      "id": "PR_kwDOGKuqOc43G3Ky",
      "title": "Define DAFs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/53",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #20.\r\n\r\nThis defines syntax for DAFs. They are presented as a simpler alternative to VDAFs that may be suited for some applications. They are defined before VDAFs by way of a \"gentle introduction\". Text in the VDAF section that overlaps significantly with the new DAF text has been removed.\r\n\r\nReviewer note: This PR is broken up into several commits. It may be best to review commit-by-commit.\r\n\r\n2022-05-06: Ready for review.\r\n2022-04-29: WIP, not yet ready for review.",
      "createdAt": "2022-04-30T01:41:22Z",
      "updatedAt": "2022-05-26T14:58:18Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "28ef0c404c0548b6427c3f2a7e3857640d3a7968",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/daf",
      "headRefOid": "31bc9f32b34967c00e73b9ef6e209818bb065c26",
      "closedAt": "2022-05-13T15:20:06Z",
      "mergedAt": "2022-05-13T15:20:06Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "7ad3aa673c33540c63549062e38223d481ac845b"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @schoppmp, no substantial changes, if you want to inspect the diff you can do\r\n```\r\ngit diff f606049..cjpatton/daf\r\n```\r\n\r\nNote that this inccludes changes after rebasing on `main`.",
          "createdAt": "2022-05-10T19:00:17Z",
          "updatedAt": "2022-05-10T19:00:17Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc45hmrd",
          "commit": {
            "abbreviatedOid": "f606049"
          },
          "author": "divergentdave",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-06T19:25:30Z",
          "updatedAt": "2022-05-06T20:55:07Z",
          "comments": [
            {
              "originalPosition": 191,
              "body": "```suggestion\r\n{: #daf-param title=\"Constants and types defined by each concrete DAF.\"}\r\n```",
              "createdAt": "2022-05-06T19:25:30Z",
              "updatedAt": "2022-05-06T20:55:07Z"
            },
            {
              "originalPosition": 167,
              "body": "Would it be clearer to say that the mapping may be \"non-deterministic\", rather than \"one-to-many\"?",
              "createdAt": "2022-05-06T19:26:21Z",
              "updatedAt": "2022-05-06T20:55:07Z"
            },
            {
              "originalPosition": 349,
              "body": "nit: spelling\r\n```suggestion\r\nThe inputs to this procedure are the same as the aggregation function computed by\r\n```",
              "createdAt": "2022-05-06T20:19:27Z",
              "updatedAt": "2022-05-06T20:55:07Z"
            },
            {
              "originalPosition": 371,
              "body": "nit: spelling\r\n```suggestion\r\nof the computation's correctness. Accommodating this interaction will require\r\n```",
              "createdAt": "2022-05-06T20:31:36Z",
              "updatedAt": "2022-05-06T20:55:07Z"
            },
            {
              "originalPosition": 446,
              "body": "nit: typo\r\n```suggestion\r\ninput-distribution algorithm takes in the public parameter generated during the\r\n```",
              "createdAt": "2022-05-06T20:33:41Z",
              "updatedAt": "2022-05-06T20:55:08Z"
            },
            {
              "originalPosition": 15,
              "body": "```suggestion\r\n    # The measurement type.\r\n```",
              "createdAt": "2022-05-06T20:40:40Z",
              "updatedAt": "2022-05-06T20:55:08Z"
            },
            {
              "originalPosition": 55,
              "body": "nit: typo\r\n```suggestion\r\n    # called by the collector.\r\n```",
              "createdAt": "2022-05-06T20:42:30Z",
              "updatedAt": "2022-05-06T20:55:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45iFUs",
          "commit": {
            "abbreviatedOid": "ebc0d77"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-06T22:35:23Z",
          "updatedAt": "2022-05-06T23:11:46Z",
          "comments": [
            {
              "originalPosition": 167,
              "body": "In fact, the mapping from (input_share, agg_param) --> out_share is deterministic, i.e., not randomized. I think the wording is confusing here. What I mean is that each agg_param may result in a different out_share. I've tried to clarify the text.",
              "createdAt": "2022-05-06T22:35:24Z",
              "updatedAt": "2022-05-06T23:11:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45iJmx",
          "commit": {
            "abbreviatedOid": "f606049"
          },
          "author": "divergentdave",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-06T23:32:25Z",
          "updatedAt": "2022-05-06T23:32:25Z",
          "comments": [
            {
              "originalPosition": 167,
              "body": "Ah, got it, thanks! New text looks good.",
              "createdAt": "2022-05-06T23:32:25Z",
              "updatedAt": "2022-05-06T23:32:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45oJt6",
          "commit": {
            "abbreviatedOid": "ebc0d77"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T20:59:40Z",
          "updatedAt": "2022-05-09T21:32:51Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "What does `Prep.OutShare` refer to? Should that just be `OutShare`?",
              "createdAt": "2022-05-09T20:59:40Z",
              "updatedAt": "2022-05-09T21:32:51Z"
            },
            {
              "originalPosition": 23,
              "body": "\"may\" and \"optional\" are redundant.",
              "createdAt": "2022-05-09T21:05:57Z",
              "updatedAt": "2022-05-09T21:32:51Z"
            },
            {
              "originalPosition": 24,
              "body": "\"The semantics of this parameter *are* specific\"\r\n\r\n(GitHub won't let me use the suggestion feature when I review commit-by-commit)",
              "createdAt": "2022-05-09T21:06:50Z",
              "updatedAt": "2022-05-09T21:32:51Z"
            },
            {
              "originalPosition": 26,
              "body": "Missing period at the end of the line",
              "createdAt": "2022-05-09T21:06:58Z",
              "updatedAt": "2022-05-09T21:32:51Z"
            },
            {
              "originalPosition": 41,
              "body": "I think this sentence makes sense if we read \"input\" as a verb and not a noun, but it's a bit confusing given that those two words have specific meanings throughout VDAF and DAP. Maybe rephrase to only use one or the other word?",
              "createdAt": "2022-05-09T21:08:21Z",
              "updatedAt": "2022-05-09T21:32:51Z"
            },
            {
              "originalPosition": 42,
              "body": "\"Unsharding *is* done\"",
              "createdAt": "2022-05-09T21:08:32Z",
              "updatedAt": "2022-05-09T21:32:51Z"
            },
            {
              "originalPosition": 48,
              "body": "s/tyeps/types",
              "createdAt": "2022-05-09T21:08:56Z",
              "updatedAt": "2022-05-09T21:32:51Z"
            },
            {
              "originalPosition": 55,
              "body": "Reviewing this table of types and the existing one for VDAFs, it seems odd that we take the care of defining an `OutShare` type but then represent input shares as `Bytes` (e.g., `Vdaf.measurement_to_input_shares(public_param: PublicParam, input: Measurement) -> Vec[Bytes]`). Why not define `InShare`?\r\n\r\nThis wasn't introduced by this PR so feel free to punt with an issue or a TODO (or to disagree with me altogether)",
              "createdAt": "2022-05-09T21:11:59Z",
              "updatedAt": "2022-05-09T21:32:51Z"
            },
            {
              "originalPosition": 177,
              "body": "update this reference to `draft-ietf-ppm-dap` (and presumably elsewhere in the document where `draft-gpew-priv-ppm` occurs)",
              "createdAt": "2022-05-09T21:15:04Z",
              "updatedAt": "2022-05-09T21:32:51Z"
            },
            {
              "originalPosition": 96,
              "body": "I think this is adapted from the `run_vdaf` test/illustration, where `outbound` is used to simulate the leader gathering prepare messages from helpers and then broadcasting combined prepare messages back out. That step isn't needed in a DAF (right?), so I wonder if this could be rewritten to make it more clear that each aggregator is independent and doesn't interact with any other during `prepare`? That is, eliminate any value like `outbound` that is shared among aggregators (in this case, each aggregator is represented by one iteration of the `for j in range(Daf.SHARES)` loop).",
              "createdAt": "2022-05-09T21:20:18Z",
              "updatedAt": "2022-05-09T21:32:51Z"
            },
            {
              "originalPosition": 397,
              "body": "I'm a bit confused about \"one-shot\" vs. \"streaming\". The distinction that I'm aware of between VDAFs is whether the aggregation parameter exists or not. If it does, then aggregation can't start until the collector proves the aggregation parameter. If it does not, then aggregators can aggregate shares immediately upon upload.\r\n\r\nBut I don't think that has anything to do with whether aggregation can be \"streamed\". Let's say we're running `poplar1`, and my aggregator receives 50 shares, and then the collector sends me `agg_param`. Now I can aggregate together those 50 shares, but I'm likely to do so by preparing them individually, independently from each other, summing each output share into an aggregate, which sounds like \"streaming\" to me. Further, my aggregator may continue to receive shares between when it receives `agg_param` (in a DAP `CollectReq`) and when it delivers the aggregate share (which will happen when the collector hits the DAP collect job URI), and I don't think anything stops the aggregator from continuing to incorporate shares into the aggregate -- or _stream_ them.\r\n\r\nI think I know what you mean by \"one-shot\" vs. \"streaming\", but I don't think these are the right words to express it, since the issue here is when the aggregator can expect to have the aggregation parameter and not whether input shares can be aggregated incrementally.",
              "createdAt": "2022-05-09T21:32:13Z",
              "updatedAt": "2022-05-09T21:32:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45oRT3",
          "commit": {
            "abbreviatedOid": "ebc0d77"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T21:35:33Z",
          "updatedAt": "2022-05-09T21:35:33Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Oh, I think I see now that `Bytes` connotes that the output of the method is a message that can be transmitted on the wire to another protocol participant. I think that's inconsistent though: `AggShare` also has to be encoded to be transmitted from aggregators to the collector, but it gets a rich type definition here. My vote would be to use nice type aliases everywhere and then extend the definition of DAF/VDAF to include methods like `Daf.encode_input_share(InShare) -> Bytes` and `Daf.decode_input_share(Bytes) -> InShare`.",
              "createdAt": "2022-05-09T21:35:33Z",
              "updatedAt": "2022-05-09T21:35:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45oWOO",
          "commit": {
            "abbreviatedOid": "ebc0d77"
          },
          "author": "divergentdave",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T22:03:00Z",
          "updatedAt": "2022-05-09T22:03:01Z",
          "comments": [
            {
              "originalPosition": 397,
              "body": "Both `prio3` and `poplar1` support \"streaming\" aggregation in the sense used here, as both their aggregation operations are effectively vector addition in a vector space over a field. The distinction is that `out_shares_to_agg_share` as given here takes in all output shares at once, and returns an aggregate share, rather than processing output shares only one at a time, updating an accumulator, and returning an aggregate share at the end. For a strawman counterexample, consider a VDAF where `out_shares_to_agg_share` takes the median of numbers from each output share. This would be a non-streaming VDAF, as there's no efficient way to incrementally compute an aggregate share. Instead, the only way to compute the exact median is to keep the multiset of all output shares around until all output shares are received.",
              "createdAt": "2022-05-09T22:03:00Z",
              "updatedAt": "2022-05-09T22:06:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45oVtw",
          "commit": {
            "abbreviatedOid": "ebc0d77"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-05-09T22:00:01Z",
          "updatedAt": "2022-05-09T22:19:53Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "environment",
              "createdAt": "2022-05-09T22:00:02Z",
              "updatedAt": "2022-05-09T22:19:53Z"
            },
            {
              "originalPosition": 55,
              "body": "+1, I would prefer a concrete type for the input shares.",
              "createdAt": "2022-05-09T22:05:43Z",
              "updatedAt": "2022-05-09T22:19:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45oabg",
          "commit": {
            "abbreviatedOid": "ebc0d77"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T22:30:11Z",
          "updatedAt": "2022-05-09T22:33:47Z",
          "comments": [
            {
              "originalPosition": 373,
              "body": "> However, the Preparation stage will require interaction among the Aggregators in order to facilitate verifiability of the computation's correctness.\r\n\r\nI think it makes sense to split up the preparation (as in, turning an input share into an aggregation share), and the verification.\r\nThe reason is that the outer protocol using a VDAF might want to \"opportunistically\" aggregate shares, in particular for Poplar, where there are many rounds of Preparation, Aggregation, and Unsharding. This would save communication rounds, since the verification on one layer (of the Poplar tree) can be done in parallel with computing the aggregation shares on the next layer. In case a share turns out to be invalid, the corresponding aggregation shares can just be subtracted from the aggregated result.",
              "createdAt": "2022-05-09T22:30:12Z",
              "updatedAt": "2022-05-09T22:33:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45oaPI",
          "commit": {
            "abbreviatedOid": "31bc9f3"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T22:28:52Z",
          "updatedAt": "2022-05-09T23:00:56Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Done",
              "createdAt": "2022-05-09T22:28:52Z",
              "updatedAt": "2022-05-09T23:00:56Z"
            },
            {
              "originalPosition": 23,
              "body": "Done",
              "createdAt": "2022-05-09T22:29:39Z",
              "updatedAt": "2022-05-09T23:00:56Z"
            },
            {
              "originalPosition": 24,
              "body": "https://english.stackexchange.com/questions/411158/plural-form-of-semantics",
              "createdAt": "2022-05-09T22:30:55Z",
              "updatedAt": "2022-05-09T23:00:56Z"
            },
            {
              "originalPosition": 26,
              "body": "Done",
              "createdAt": "2022-05-09T22:31:14Z",
              "updatedAt": "2022-05-09T23:00:56Z"
            },
            {
              "originalPosition": 41,
              "body": "Done, changed to \"measurement\".",
              "createdAt": "2022-05-09T22:31:49Z",
              "updatedAt": "2022-05-09T23:00:56Z"
            },
            {
              "originalPosition": 42,
              "body": "\"X and Y are done\" follows grammar above. Is this wrong? Should it be \"X and Y is done?\"",
              "createdAt": "2022-05-09T22:32:41Z",
              "updatedAt": "2022-05-09T23:00:56Z"
            },
            {
              "originalPosition": 48,
              "body": "Done",
              "createdAt": "2022-05-09T22:33:04Z",
              "updatedAt": "2022-05-09T23:00:56Z"
            },
            {
              "originalPosition": 55,
              "body": "You're right about the inconsistency, however I'm not sure I agree with the solution. Let's move this discussion here: https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/58",
              "createdAt": "2022-05-09T22:40:06Z",
              "updatedAt": "2022-05-09T23:00:56Z"
            },
            {
              "originalPosition": 177,
              "body": "Ack, will do so after merging this change.",
              "createdAt": "2022-05-09T22:45:59Z",
              "updatedAt": "2022-05-09T23:00:56Z"
            },
            {
              "originalPosition": 397,
              "body": "Another answer: The intended meaning of the word \"streaming\" is the alternative API discussed here: https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/47",
              "createdAt": "2022-05-09T22:48:18Z",
              "updatedAt": "2022-05-09T23:00:56Z"
            },
            {
              "originalPosition": 51,
              "body": "Yes, done!",
              "createdAt": "2022-05-09T22:50:46Z",
              "updatedAt": "2022-05-09T23:00:56Z"
            },
            {
              "originalPosition": 96,
              "body": "Done",
              "createdAt": "2022-05-09T23:00:40Z",
              "updatedAt": "2022-05-09T23:00:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45olRc",
          "commit": {
            "abbreviatedOid": "ebc0d77"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T23:30:50Z",
          "updatedAt": "2022-05-09T23:30:51Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Hmm, TIL the semantics of the word \"semantics\". Well, maybe the IETF has a style guide that someone can cite from to settle this. For now I say go with whichever you prefer.",
              "createdAt": "2022-05-09T23:30:51Z",
              "updatedAt": "2022-05-09T23:30:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45olho",
          "commit": {
            "abbreviatedOid": "ebc0d77"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T23:31:28Z",
          "updatedAt": "2022-05-09T23:31:28Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "No, you're right, this is correct as-is. I don't have a \"resolve conversation button\" here because ???? so I guess just ignore this thread.",
              "createdAt": "2022-05-09T23:31:28Z",
              "updatedAt": "2022-05-09T23:31:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45onY_",
          "commit": {
            "abbreviatedOid": "ebc0d77"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T23:36:03Z",
          "updatedAt": "2022-05-09T23:36:03Z",
          "comments": [
            {
              "originalPosition": 397,
              "body": "Maybe this is too big of a nomenclature issue to tackle in this particular PR",
              "createdAt": "2022-05-09T23:36:03Z",
              "updatedAt": "2022-05-09T23:36:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45oqBd",
          "commit": {
            "abbreviatedOid": "31bc9f3"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T23:42:25Z",
          "updatedAt": "2022-05-09T23:45:24Z",
          "comments": [
            {
              "originalPosition": 373,
              "body": "To be clear:\r\n* Prepare takes input shares to output shares; and\r\n* Aggregation takes output shares to aggregate shares.\r\n\r\n> [...] the verification on one layer (of the Poplar tree) can be done in parallel with computing the aggregation shares on the next layer. In case a share turns out to be invalid, the corresponding aggregation shares can just be subtracted from the aggregated result.\r\n\r\nVery Interesting idea. The current text points to two reasons for not breaking Prepare abstraction this way:\r\n1. Not every VDAF is compatible with this change. E.g., in Prio+ the output shares are only computed after multiple rounds of interaction.\r\n2. Releasing unverified output shares early may lead to them being misused.\r\n\r\nThus, a change here would be significant and would need to be thought through. I'd suggest we discuss it in a new issue.\r\n\r\n\r\n\r\n\r\n",
              "createdAt": "2022-05-09T23:42:25Z",
              "updatedAt": "2022-05-09T23:45:24Z"
            },
            {
              "originalPosition": 397,
              "body": "It's arguably orthogonal given that \"one-shot\" is the current terminology (i.e., not introduced by this PR). How about adding a comment to #47 about fixing this?",
              "createdAt": "2022-05-09T23:44:36Z",
              "updatedAt": "2022-05-09T23:45:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45tMDw",
          "commit": {
            "abbreviatedOid": "ebc0d77"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-10T17:17:33Z",
          "updatedAt": "2022-05-10T17:17:33Z",
          "comments": [
            {
              "originalPosition": 373,
              "body": "> Not every VDAF is compatible with this change. E.g., in Prio+ the output shares are only computed after multiple rounds of interaction.\r\n\r\nI'm not asking for every VDAF to support this opportunistic aggregation, but instead to *allow* it in places where it's supported by both the VDAF and the outer aggregation protocol.\r\n\r\nI opened https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/61 to continue this discussion.",
              "createdAt": "2022-05-10T17:17:33Z",
              "updatedAt": "2022-05-10T17:17:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc45tOkh",
          "commit": {
            "abbreviatedOid": "31bc9f3"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I can't see the diff between my last review and the current state. LGTM assuming there are no substantial changes.",
          "createdAt": "2022-05-10T17:22:01Z",
          "updatedAt": "2022-05-10T17:22:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc459Nxu",
          "commit": {
            "abbreviatedOid": "31bc9f3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-13T14:27:13Z",
          "updatedAt": "2022-05-13T14:27:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 54,
      "id": "PR_kwDOGKuqOc43P_l9",
      "title": "Remove unused g_calls in FlpGeneric.prove",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/54",
      "state": "MERGED",
      "author": "jbr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As far as I can tell this is an unnecessary zip, as `g_calls` is unused in this scope",
      "createdAt": "2022-05-03T19:45:06Z",
      "updatedAt": "2022-05-03T20:01:56Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "ca421e5064d2767319006cfd8007fa9ad65ef60b",
      "headRepository": "jbr/draft-irtf-cfrg-vdaf",
      "headRefName": "remove-unused-valid-gadget-calls",
      "headRefOid": "9061fc1f8711696305784fdae42f46ba425ed47c",
      "closedAt": "2022-05-03T20:01:56Z",
      "mergedAt": "2022-05-03T20:01:56Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "2a5c2dd4720280ea9f9e2ab5a2b5ba5062212d6b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc45RzaU",
          "commit": {
            "abbreviatedOid": "9061fc1"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Right you are!",
          "createdAt": "2022-05-03T20:01:47Z",
          "updatedAt": "2022-05-03T20:01:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 55,
      "id": "PR_kwDOGKuqOc43Qo1w",
      "title": "remove another unused g_calls",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/55",
      "state": "MERGED",
      "author": "jbr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-03T23:01:47Z",
      "updatedAt": "2022-05-04T23:12:41Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "2a5c2dd4720280ea9f9e2ab5a2b5ba5062212d6b",
      "headRepository": "jbr/draft-irtf-cfrg-vdaf",
      "headRefName": "remove-another-unused-g_calls",
      "headRefOid": "30d8013e64cec3ca919274676e7e2b999eb39ec2",
      "closedAt": "2022-05-04T23:12:41Z",
      "mergedAt": "2022-05-04T23:12:41Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "958c619dae34b20cbbac81afed3aa8d4d50829d7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc45Yhqe",
          "commit": {
            "abbreviatedOid": "30d8013"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-04T23:12:35Z",
          "updatedAt": "2022-05-04T23:12:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 56,
      "id": "PR_kwDOGKuqOc43btGQ",
      "title": "gadget_poly_len should not include the wire seed arity",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/56",
      "state": "MERGED",
      "author": "jbr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently `gadget_poly_len` is the same as the total gadget chunk length (proof length for a one-gadget circuit), which is off by the wire seed length/arity. The tests passed because all of the tested circuits have only a single gadget and the wire seed is before the polynomial, so attempting to read off the end of the proof truncated back to the expected length. If there were two gadgets, this would read part of the second gadget's wire seed into the polynomial of the first",
      "createdAt": "2022-05-06T19:02:30Z",
      "updatedAt": "2022-05-09T15:03:52Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "c1548a7c37a4e11eef9a7ba37c5af3c1bad6134b",
      "headRepository": "jbr/draft-irtf-cfrg-vdaf",
      "headRefName": "correct-gadget-poly-len",
      "headRefOid": "c44c5e10409e3d556b509325f70807cfb1e721ae",
      "closedAt": "2022-05-09T15:03:52Z",
      "mergedAt": "2022-05-09T15:03:52Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "28ef0c404c0548b6427c3f2a7e3857640d3a7968"
      },
      "comments": [
        {
          "author": "jbr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Confirmed manually that the tests failed as follows before this pr:\r\n```\r\n\u276f make test\r\nParsing flp_generic.sage\r\nsage common.sage\r\nsage field.sage\r\nsage flp.sage\r\nsage flp_generic.sage\r\nTestMultiGadget: test 0 failed: proof evaluation resulted in False; want True\r\nsage prg.sage\r\nsage vdaf.sage\r\nsage vdaf_prio3.sage\r\n```\r\n\r\nand with this pr they pass:\r\n```\r\n\u276f make test\r\nParsing flp_generic.sage\r\nsage common.sage\r\nsage field.sage\r\nsage flp.sage\r\nsage flp_generic.sage\r\nsage prg.sage\r\nsage vdaf.sage\r\nsage vdaf_prio3.sage\r\n```\r\n\r\nWould you be interested in a PR that runs the POC tests in GitHub actions as CI?",
          "createdAt": "2022-05-06T23:52:37Z",
          "updatedAt": "2022-05-06T23:52:37Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Sweet, thanks again.",
          "createdAt": "2022-05-09T15:03:39Z",
          "updatedAt": "2022-05-09T15:03:39Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc45iIGN",
          "commit": {
            "abbreviatedOid": "aa71d3c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks again @jbr! I merged a test that exercises this bug: https://github.com/cfrg/draft-irtf-cfrg-vdaf/commit/c1548a7c37a4e11eef9a7ba37c5af3c1bad6134b. Two asks:\r\n1. Please rebase on `main` and make sure the fix is sufficient.\r\n2. Please revise the commit message to use a verb, e..g, \"poc: Fix bug in `FlpGeneric` triggered by multiple gadgets\". Also, please add to the commit message a note about what the bug is.\r\n",
          "createdAt": "2022-05-06T23:09:56Z",
          "updatedAt": "2022-05-06T23:09:56Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc45mJix",
          "commit": {
            "abbreviatedOid": "c44c5e1"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-09T15:03:27Z",
          "updatedAt": "2022-05-09T15:03:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 57,
      "id": "PR_kwDOGKuqOc43hPpb",
      "title": "poc: Add VerifyParam type annotation to Prio3",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/57",
      "state": "MERGED",
      "author": "jbr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I'm not certain that this is correct, but it seems like `VerifyParam` isn't the `Vdaf` default of `None` for `Prio3`",
      "createdAt": "2022-05-09T17:36:09Z",
      "updatedAt": "2022-05-10T02:06:21Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "28ef0c404c0548b6427c3f2a7e3857640d3a7968",
      "headRepository": "jbr/draft-irtf-cfrg-vdaf",
      "headRefName": "pod-vdaf-prio3-add-verify-param-type",
      "headRefOid": "703fd8f3319d0c03adde78c3d37b21d5d69fae78",
      "closedAt": "2022-05-10T02:06:21Z",
      "mergedAt": "2022-05-10T02:06:21Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "b8b1496aeead11d73bae34b8b63ed41f46857367"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc45pAUx",
          "commit": {
            "abbreviatedOid": "23720f0"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Yes that's correct. Before merging, would you mind changing the commit message by replacing \"VdafPrio3\" with \"Prio3\"? \"VdafPrio3\" isn't a proper name of something.\r\n\r\nBy the way, I filed https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/59 to investigate where else way may have missed this.",
          "createdAt": "2022-05-10T01:13:49Z",
          "updatedAt": "2022-05-10T01:13:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc45pIsE",
          "commit": {
            "abbreviatedOid": "703fd8f"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "\u2764\ufe0f ",
          "createdAt": "2022-05-10T02:06:15Z",
          "updatedAt": "2022-05-10T02:06:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 62,
      "id": "PR_kwDOGKuqOc43zOts",
      "title": "Remove public param and simplify verify param",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/62",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #19.\r\n\r\nThere are currently no VDAFs that use the public parameter. As noted\r\nnoted in https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/18 and https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/19, this creates friction for applications like DAP\r\n(formerly known as PPM) that require frequent rotation of the\r\nverification parameter shared by the Aggregators. This change addresses\r\nthis issue by dropping the public parameter from the syntax.\r\n\r\nFor our current set of VDAFs (Prio3 and Poplar1), the verification\r\nparameter held by an Aggregator is basically a shared secret and some\r\nsort of identifier of its role (aggregator 0, aggregator 1, ...). This\r\nchange codifies these two values in the syntax by dropping the\r\nverification parameter and replacing it with a shared \"verification key\"\r\nand an \"aggregator ID\". This allows us to replace the `setup()`\r\nprocedure with simply generating a shared secret, paving the way for a\r\nsolution for https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/18 that doesn't require breaking the abstraction boundary.",
      "createdAt": "2022-05-13T17:58:09Z",
      "updatedAt": "2022-05-26T14:58:31Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "f2c70cc9547333945e287adbbd22ddd81d89a5be",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/pub-param-die-die-die",
      "headRefOid": "902b849a4c0a7591a5899accb031febc96e336d5",
      "closedAt": "2022-05-18T23:12:34Z",
      "mergedAt": "2022-05-18T23:12:33Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "b08c3e9cc0bce68315ead46dafc69a3a7edc7c4a"
      },
      "comments": [
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "There are still a couple of `verify_param` throughout the document, for example under Security Considerations. Do you plan to replace them in this PR?",
          "createdAt": "2022-05-16T23:21:59Z",
          "updatedAt": "2022-05-16T23:21:59Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "There are still a couple of `verify_param` throughout the document, for example under Security Considerations. Do you plan to replace them in this PR?",
          "createdAt": "2022-05-16T23:21:59Z",
          "updatedAt": "2022-05-16T23:21:59Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> There are still a couple of `verify_param` throughout the document, for example under Security Considerations. Do you plan to replace them in this PR?\r\n\r\nI intended to leave the Poplar1 section unchanged, but missed the updates in Security Considerations. Nice catch, fixed.",
          "createdAt": "2022-05-16T23:32:27Z",
          "updatedAt": "2022-05-16T23:32:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc45-lqt",
          "commit": {
            "abbreviatedOid": "fe8a3f3"
          },
          "author": "divergentdave",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-13T19:35:12Z",
          "updatedAt": "2022-05-13T20:31:36Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "nit: typo\r\n```suggestion\r\n  The application MUST ensure that the Aggregator's identifier is equal to the\r\n```",
              "createdAt": "2022-05-13T19:35:12Z",
              "updatedAt": "2022-05-13T20:31:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc46GE55",
          "commit": {
            "abbreviatedOid": "fe8a3f3"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-16T23:32:41Z",
          "updatedAt": "2022-05-16T23:32:41Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "Done.",
              "createdAt": "2022-05-16T23:32:41Z",
              "updatedAt": "2022-05-16T23:32:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc46GFTH",
          "commit": {
            "abbreviatedOid": "8e5e1a5"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-16T23:35:55Z",
          "updatedAt": "2022-05-16T23:35:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc46QxmC",
          "commit": {
            "abbreviatedOid": "93677c0"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-18T19:12:41Z",
          "updatedAt": "2022-05-18T19:13:36Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Nit: Please add spaces below so that the column dividers align.",
              "createdAt": "2022-05-18T19:12:41Z",
              "updatedAt": "2022-05-18T19:13:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc46Rx8D",
          "commit": {
            "abbreviatedOid": "93677c0"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-18T23:08:16Z",
          "updatedAt": "2022-05-18T23:08:16Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Done",
              "createdAt": "2022-05-18T23:08:16Z",
              "updatedAt": "2022-05-18T23:08:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 64,
      "id": "PR_kwDOGKuqOc43_qpl",
      "title": "Prio3: Move proof verifier check to prep_shares_to_prep()",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/64",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Moves the proof verifier check to prep_shares_to_prep() in oder to avoid\r\nincluding the verifier in the unsharded prep message. Now this message\r\nincludes just the joint randomness checker, unless no joint randomness\r\nis required, in which case the unshareded prep message is the empty\r\nstring.",
      "createdAt": "2022-05-18T02:22:28Z",
      "updatedAt": "2022-05-26T14:58:15Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "3888d46adb568c5ea8e6d276524954172e92d4c6",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/prio3-prep-share",
      "headRefOid": "9b387224c84726c4734327710950357c082f9fe5",
      "closedAt": "2022-05-18T23:12:54Z",
      "mergedAt": "2022-05-18T23:12:54Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "6e1eb6fc296f92ec147c88d8c6e2e9139a1b0ceb"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 65,
      "id": "PR_kwDOGKuqOc44B_Tc",
      "title": "define \"domain separation tag\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/65",
      "state": "CLOSED",
      "author": "tgeoghegan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "@jbr pointed out that the `dst` variables that occur in a few VDAF\r\ninstantiations are a bit inscrutable. This commit adds `DST` associated\r\nconstants to the DAF and VDAF definitions which are then used in PRGs.\r\nThe intent is to (1) provide a clear definition of a DST and (2) reduce\r\nthe number of places where the string `vdaf-00 prio3` has to be updated\r\nto `vdaf-01 prio3`.",
      "createdAt": "2022-05-18T14:22:56Z",
      "updatedAt": "2022-05-18T15:48:07Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "3888d46adb568c5ea8e6d276524954172e92d4c6",
      "headRepository": "tgeoghegan/vdaf",
      "headRefName": "timg/define-dst",
      "headRefOid": "3df27257d2b9ed54018eea794fefa7fd95883e1d",
      "closedAt": "2022-05-18T15:46:38Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Tagging @jbr and @cjpatton: I don't have the privileges to request review on this PR, but PTAL. Chris, if this seems good to you, then I'll make the corresponding changes to the Sage scripts.",
          "createdAt": "2022-05-18T14:26:06Z",
          "updatedAt": "2022-05-18T14:26:06Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "One more note: I think a comment defining the acronym DST is sufficient.",
          "createdAt": "2022-05-18T15:38:41Z",
          "updatedAt": "2022-05-18T15:38:41Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> One more note: I think a comment defining the acronym DST is sufficient.\r\n\r\nYeah, in the interest of moving forward and not re-writing half the doc and POC, I'm going to close this PR and just add a couple of comments: #66 ",
          "createdAt": "2022-05-18T15:46:38Z",
          "updatedAt": "2022-05-18T15:48:07Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc46Paw7",
          "commit": {
            "abbreviatedOid": "3df2725"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I agree that DST needs to be defined somewhere and that de-duplicating is desirable. However I don't think this change is at the right level of the \"stack\".\r\n\r\nTwo important things to note here:\r\n(1) Not every (V)DAF will necessarily have a DST that serves the same purpose.\r\n(2) Many DSTs will have a common prefix, e.g., \"vdaf-00\".\r\n\r\nPer (1) I don't think it makes sense to lift the DST to a parameter of the (V)DAF. \r\nPer (2) I think it's a good idea to define the common prefix somewhere.\r\n\r\nWhat do you think about this alternative:\r\n* Define somewhere in the document a global constant `VERSION` whose value is `vdaf-00`. Perhaps this could go in Section 2.\r\n* In the Prio3 definition, let `dst = VERSION + b\" prio3\"`.\r\n\r\n",
          "createdAt": "2022-05-18T14:54:54Z",
          "updatedAt": "2022-05-18T14:54:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 66,
      "id": "PR_kwDOGKuqOc44CXmG",
      "title": "Clarify that `dst` = domain separation tag",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/66",
      "state": "MERGED",
      "author": "tgeoghegan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-18T15:47:47Z",
      "updatedAt": "2022-05-18T16:05:42Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "3888d46adb568c5ea8e6d276524954172e92d4c6",
      "headRepository": "tgeoghegan/vdaf",
      "headRefName": "timg/dst-comment",
      "headRefOid": "16ed69280261cbbf7038424458e91725ce07357b",
      "closedAt": "2022-05-18T15:49:04Z",
      "mergedAt": "2022-05-18T15:49:04Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "f2c70cc9547333945e287adbbd22ddd81d89a5be"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc46PwV9",
          "commit": {
            "abbreviatedOid": "16ed692"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-18T15:48:49Z",
          "updatedAt": "2022-05-18T15:48:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 69,
      "id": "PR_kwDOGKuqOc44EQxq",
      "title": "Add Aggregator ID to `Vdaf.prep()`",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/69",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #68.\r\n\r\nThis allows DAFs to distinguish between different types of input shares\r\nwithout requiring the input shares themselves to encode the\r\ndistinguisher.",
      "createdAt": "2022-05-18T23:42:44Z",
      "updatedAt": "2022-05-26T14:58:33Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "6e1eb6fc296f92ec147c88d8c6e2e9139a1b0ceb",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/daf-agg-id",
      "headRefOid": "1a4614c4369d9521399917948c34fca1b71f24a2",
      "closedAt": "2022-05-19T20:45:59Z",
      "mergedAt": "2022-05-19T20:45:59Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "67f12eb900b5c6e7efe2e196eb752ad58044efe4"
      },
      "comments": [
        {
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe this also addresses #40, unless there's another spot in VDAF where the leader distinction matters.",
          "createdAt": "2022-05-19T14:37:39Z",
          "updatedAt": "2022-05-19T14:37:39Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think the aggregator ID adequately addresses that issue. The draft may need more guidance on generating input shares, as pointed out by @branlwyd: https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/40#issuecomment-1099719279",
          "createdAt": "2022-05-19T15:55:48Z",
          "updatedAt": "2022-05-19T15:57:35Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 70,
      "id": "PR_kwDOGKuqOc44Ej-H",
      "title": "editorial: Replace double quotes with single quotes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/70",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Backticks get rendered as double quotes in the plaintext version,\r\npotentially colliding with byte string literals in the spec, e.g.:\r\n\r\n    \"b\"vdaf-00\"\"\r\n\r\nBy using single quotes, we ensure this gets rendored instead as\r\n\r\n    \"b'vdaf'00'\"\r\n\r\nwhich is a bit clearer.\r\n\r\nWe may want to consider removing backticks altogether.",
      "createdAt": "2022-05-19T00:31:33Z",
      "updatedAt": "2022-05-26T14:58:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "b1fa888930d2eb6d1c1318ea6a0bfe3509078c27",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/editorial",
      "headRefOid": "4bdabec3af55cd6321c7595f1e4c20fd03baa63d",
      "closedAt": "2022-05-19T00:33:56Z",
      "mergedAt": "2022-05-19T00:33:56Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "6f46b822a760cb6c1ca5a083587719e79dd088d6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 71,
      "id": "PR_kwDOGKuqOc44ElYi",
      "title": "Define global `VERSION` for building domain separation tags",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/71",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #67.",
      "createdAt": "2022-05-19T00:35:33Z",
      "updatedAt": "2022-05-26T14:58:45Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "6f46b822a760cb6c1ca5a083587719e79dd088d6",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/global-vers",
      "headRefOid": "62ec407229b5544c4de947b23479cc1094276505",
      "closedAt": "2022-05-19T00:41:45Z",
      "mergedAt": "2022-05-19T00:41:45Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "180ffa005dcbf9d88341d104b81aef691c23bbd2"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 73,
      "id": "PR_kwDOGKuqOc44E0L0",
      "title": "Have `Vdaf.prep_init()` output first round prep share",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/73",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #60.\r\n\r\nNow that we have defined DAFs explicitly and removed the public\r\nparameter, there is no longer a need to support 0-round VDAFs. This\r\nchange codifies the requirement that ROUNDS >= 1 in the syntax.",
      "createdAt": "2022-05-19T01:11:52Z",
      "updatedAt": "2022-05-25T17:24:09Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "50e872c2f0d4c1f5cf4d60146bae57d0f8eaa1a6",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/refactor-prep-init",
      "headRefOid": "f3a6f421a37f118899569dc2af09fcc0da7021cf",
      "closedAt": "2022-05-25T17:24:08Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "Is there a reason for requiring at least one verification round? I don't think it's immediately clear why the verification can't be non-interactive (e.g., the client provides separate NIZK proofs to each party).",
          "createdAt": "2022-05-19T21:01:27Z",
          "updatedAt": "2022-05-19T21:01:27Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is there a reason for requiring at least one verification round? I don't think it's immediately clear why the verification can't be non-interactive (e.g., the client provides separate NIZK proofs to each party).\r\n\r\nI agree it's not immediately clear. However, in particular for NIZKs I think the prover would need a public key, right?  In fact, the draft-00 anticipated adapting something like https://isi.jhu.edu/~mgreen/advertising.pdf into a 0-round VDAF. Such a scheme would have used the public parameter to encode one of the Aggregator's public key (whoever does the verifying).\r\n\r\nThe downside to making room for this hypothetical construction is extra complexity for applications: see https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/60#issuecomment-1130733568. At this point, my feeling is if we wanted to a VDAF that uses some form of public key crypto, it ought to be considered a different kind of object. Especially since it's likely to have different applications.\r\n\r\nIf someone comes along with a 0-round VDAF that doesn't use public key crypto, perhaps it would fit more or less into the new DAF syntax?\r\n\r\n",
          "createdAt": "2022-05-19T21:11:55Z",
          "updatedAt": "2022-05-19T21:12:21Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure we should exclude VDAFs based on public-key cryptography. I was under the assumption that the issue with the public parameter was that it would need to be frequently rotated. Even without it, I can imagine a spec for a VDAF that has some out-of-band mechanism of retrieving public keys.\r\n\r\nIn your linked comment, both solutions don't look very complex to me... Is there maybe a way to have the simpler interface you propose in #60 without prescribing at least one communication round between aggregators?\r\n",
          "createdAt": "2022-05-19T21:38:11Z",
          "updatedAt": "2022-05-19T21:38:11Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm not sure we should exclude VDAFs based on public-key cryptography. I was under the assumption that the issue with the public parameter was that it would need to be frequently rotated. Even without it, I can imagine a spec for a VDAF that has some out-of-band mechanism of retrieving public keys.\r\n\r\nI'm not suggesting we exclude this, I'm merely suggesting it can be treated as a different type of primitive, perhaps defined in this draft. Call it a PK-VDAF or something :)\r\n\r\n> In your linked comment, both solutions don't look very complex to me... Is there maybe a way to have the simpler interface you propose in #60 without prescribing at least one communication round between aggregators?\r\n\r\nMaybe! We can hold off on merging this if you want to spend some time thinking about it.\r\n",
          "createdAt": "2022-05-19T21:42:50Z",
          "updatedAt": "2022-05-19T21:42:50Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "FWIW, translating the vdaf-00 syntax into a Rust API unearthed at least one nasty edge case: In some applications it'll be necessary to serialize the Prepare state. (Concretely, consider a DAP helper, who needs to carry state across HTTP requests during the aggregation flow.) However it is never the case that you need to serialize the first state, since you immediately consume it to get the next output bound prep share. See https://github.com/divviup/libprio-rs/pull/218 for details.",
          "createdAt": "2022-05-19T21:47:51Z",
          "updatedAt": "2022-05-19T21:52:11Z"
        },
        {
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "body": "> > I'm not sure we should exclude VDAFs based on public-key cryptography. I was under the assumption that the issue with the public parameter was that it would need to be frequently rotated. Even without it, I can imagine a spec for a VDAF that has some out-of-band mechanism of retrieving public keys.\r\n> \r\n> I'm not suggesting we exclude this, I'm merely suggesting it can be treated as a different type of primitive, perhaps defined in this draft. Call it a PK-VDAF or something :)\r\n\r\nWhat I mean is that VDAF should include any DAF that has a verification procedure, even if it's public-key or zero-round. Otherwise I'd worry that standards like DAP could over-optimize towards particular VDAFs and for example be incompatible with your proposed \"PK-VDAF\" or non-interactive verification. So in overall I'd prefer generality when it comes to the VDAF interface, to ensure compatibility of various VDAFs that might be developed in the future with the DAP infrastructure that is being developed right now.\r\n\r\n> However it is never the case that you need to serialize the first state, since you immediately consume it to get the next output bound prep share.\r\n\r\nI can see that this is a bit inefficient, although I don't think this will be a bottle neck in terms of performance. I guess one possibility would be to allow for an OPTIONAL combined function, but that seems like premature optimization to me.",
          "createdAt": "2022-05-23T16:36:26Z",
          "updatedAt": "2022-05-23T16:36:26Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> > I'm not suggesting we exclude this, I'm merely suggesting it can be treated as a different type of primitive, perhaps defined in this draft. Call it a PK-VDAF or something :)\r\n> \r\n> What I mean is that VDAF should include any DAF that has a verification procedure, even if it's public-key or zero-round. Otherwise I'd worry that standards like DAP could over-optimize towards particular VDAFs and for example be incompatible with your proposed \"PK-VDAF\" or non-interactive verification. So in overall I'd prefer generality when it comes to the VDAF interface, to ensure compatibility of various VDAFs that might be developed in the future with the DAP infrastructure that is being developed right now.\r\n\r\nAgreed, we absolutely want to plan for other applications beyond DAP (and even potentially PPM). From this perspective, I wonder if you feel like #62 was a regression after all? The concern would be that the syntax for input-share generation no longer includes an explicit public key.\r\n\r\n#62 solved a specific problem, which is to allow DAP to rotate the verification parameters without having to push a new public parameter to the clients. The need to do so is inherent to a potential public-key VDAF, but not to the VDAFs we have today. The natural question to ask ourselves here is: At what point do we specialize syntax for specific classes of constructions?\r\n\r\nSo far we have addressed this question on a case-by-case basis, which I think is right. My rule of thumb is basically: \"specialize as soon as the generalization creates a rough edge\". In the case of #62, the rough edge was key distribution having different requirements for public-key and non-public-key schemes. Were we to add support for the latter into DAP, I think it would make sense to consider this an alternative \"mode of operation\" for the protocol.\r\n\r\n> > However it is never the case that you need to serialize the first state, since you immediately consume it to get the next output bound prep share.\r\n> \r\n> I can see that this is a bit inefficient, although I don't think this will be a bottle neck in terms of performance. I guess one possibility would be to allow for an OPTIONAL combined function, but that seems like premature optimization to me.\r\n\r\nI agree that would be premature, and to be honest this isn't a problem we need to solve in the VDAF spec. It would be sufficient to make a note about this somewhere, e.g.:\r\n\r\n```\r\nImplementation note: For VDAFs with one round or more, it is necessary in some applications to serialize the Aggregator's Prepare state so that it can be stored while the Aggregator awaits a prepare message from the network. However it is not necessary to serialize the output of `prep_init()`, but only the output of of `prep_next()`.\r\n```",
          "createdAt": "2022-05-24T18:24:16Z",
          "updatedAt": "2022-05-24T18:24:16Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed in favor of #78.",
          "createdAt": "2022-05-25T17:24:08Z",
          "updatedAt": "2022-05-25T17:24:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc46UjtX",
          "commit": {
            "abbreviatedOid": "46d99bf"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-19T12:17:02Z",
          "updatedAt": "2022-05-19T12:17:18Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Nit: I would adjust this so that the `...` is vertically centered between the boxes",
              "createdAt": "2022-05-19T12:17:03Z",
              "updatedAt": "2022-05-19T12:17:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc46XfC8",
          "commit": {
            "abbreviatedOid": "46d99bf"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-19T20:36:39Z",
          "updatedAt": "2022-05-19T20:36:39Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Done.",
              "createdAt": "2022-05-19T20:36:39Z",
              "updatedAt": "2022-05-19T20:36:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 74,
      "id": "PR_kwDOGKuqOc44IEWZ",
      "title": "poc: Add test for expand_into_vec rejection sampling",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/74",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The inputs for this test were chosen through a brute-force search, so that they exercise the rejection sampling logic.\r\n\r\nI will be submitting PRs with the same test vector to the Rust and TypeScript implementations.",
      "createdAt": "2022-05-19T14:35:18Z",
      "updatedAt": "2022-06-02T16:36:06Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "67f12eb900b5c6e7efe2e196eb752ad58044efe4",
      "headRepository": "divergentdave/vdaf",
      "headRefName": "rejection-sampling-test",
      "headRefOid": "e59c66f95c68db4a2e160ed761345cd3c741e2f5",
      "closedAt": "2022-05-19T20:55:19Z",
      "mergedAt": "2022-05-19T20:55:19Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "222517a6dc72870924236dd0e6c60c4092c4aa94"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc46V1Vx",
          "commit": {
            "abbreviatedOid": "39cf430"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Nice! One minor ask.",
          "createdAt": "2022-05-19T15:30:41Z",
          "updatedAt": "2022-05-19T15:30:50Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Would you mind copy-pasting this comment here? https://github.com/divviup/libprio-rs/pull/222/files#diff-ee53018b069fa1ccd59e63911e683c27b728af0963b465436b100019b691808eR192-R193",
              "createdAt": "2022-05-19T15:30:41Z",
              "updatedAt": "2022-05-19T15:30:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc46WRKs",
          "commit": {
            "abbreviatedOid": "5c401bf"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Perfect! Please squash changes into a single commit, and I'll merge.",
          "createdAt": "2022-05-19T16:50:06Z",
          "updatedAt": "2022-05-19T16:50:06Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc46XjpK",
          "commit": {
            "abbreviatedOid": "e59c66f"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-19T20:55:12Z",
          "updatedAt": "2022-05-19T20:55:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 75,
      "id": "PR_kwDOGKuqOc44JyiW",
      "title": "Specify encoding of aggregate shares",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/75",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "draft-01"
      ],
      "body": "Removes the associated type `AggShare` from `Vdaf` and `Daf` and\r\nmodifies the syntax to treat the aggregate share as an opauqe byte\r\nstring. This is consistent with input shares, which, like the aggregate\r\nshare, are ncessarily transmitted over the network.\r\n\r\nThis partially addresses #58. In the future we may want to define a type\r\nfor every quantity and have that type implement a type whereever\r\napplicable. Or we might decide not to be prescriptive about encoding at\r\nall.\r\n\r\ncc/ @tgeoghegan",
      "createdAt": "2022-05-19T22:53:29Z",
      "updatedAt": "2022-05-26T14:57:54Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "222517a6dc72870924236dd0e6c60c4092c4aa94",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/agg-share-encoding",
      "headRefOid": "b230f1b9b615aaacdf8a6506b3c0a762441d3dd7",
      "closedAt": "2022-05-24T15:06:50Z",
      "mergedAt": "2022-05-24T15:06:50Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "b3f8a8c3f7f457ebf33ca74ea1f0a8346f6eace0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc46hm6Q",
          "commit": {
            "abbreviatedOid": "a7752a4"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-23T14:41:09Z",
          "updatedAt": "2022-05-23T16:23:01Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "```suggestion\r\n    # aggregate result. This is called by the Collector.\r\n```",
              "createdAt": "2022-05-23T14:41:09Z",
              "updatedAt": "2022-05-23T16:23:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 76,
      "id": "PR_kwDOGKuqOc44aATm",
      "title": "Update VERSION and test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/76",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Partially addresses #72.",
      "createdAt": "2022-05-25T02:18:20Z",
      "updatedAt": "2022-05-26T14:57:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "90c7438a25ade85e0ace93d9dcc2044a4be9b753",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/update-test-vec",
      "headRefOid": "f1751a945343db53fa24bbe00eac3159dcaedeb5",
      "closedAt": "2022-05-25T16:17:14Z",
      "mergedAt": "2022-05-25T16:17:13Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "799f16f1e920a4b16b2dcc7557eddef74d1fa6fa"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 78,
      "id": "PR_kwDOGKuqOc44dkC4",
      "title": "Close #60 by doing nothing",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/78",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #60.\r\n\r\nThis issue touches on a broader question, which is how to account for a\r\nvariety of different cryptographic techniques while minimizing burden\r\nfor applications. This question is tracked by #77.",
      "createdAt": "2022-05-25T17:22:47Z",
      "updatedAt": "2022-05-26T14:57:51Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "799f16f1e920a4b16b2dcc7557eddef74d1fa6fa",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/issue60",
      "headRefOid": "6bbc8f1a39bce7ddfcbc6856590051356038ed54",
      "closedAt": "2022-05-25T17:29:06Z",
      "mergedAt": "2022-05-25T17:29:06Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "481f48e7cec9c7509a6eedcf000ff4a2e84358c7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc46uSZV",
          "commit": {
            "abbreviatedOid": "6bbc8f1"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-25T17:27:52Z",
          "updatedAt": "2022-05-25T17:27:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 79,
      "id": "PR_kwDOGKuqOc44epwe",
      "title": "Change log and various editorial changes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/79",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #72.",
      "createdAt": "2022-05-25T21:23:57Z",
      "updatedAt": "2022-05-26T14:57:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "7a8ca7b5af8af043806c753207cd518a14c84a43",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/01-edit",
      "headRefOid": "760c2d559a14b78727e0ab58ebfff35abcb12507",
      "closedAt": "2022-05-26T14:09:46Z",
      "mergedAt": "2022-05-26T14:09:46Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "a6eb2bc7558d719db6867e753f4808bacb7765ee"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 80,
      "id": "PR_kwDOGKuqOc44iAiz",
      "title": "End each test vector file with a newline",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/80",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc/ @tgeoghegan ",
      "createdAt": "2022-05-26T16:10:33Z",
      "updatedAt": "2022-08-26T18:34:15Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "3629f1adda261270adaa59fbe1e6713fc5980e14",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/test-vec-newline",
      "headRefOid": "f1e136774822c863fd9b9ae59031e4d7e12de561",
      "closedAt": "2022-05-26T16:28:51Z",
      "mergedAt": "2022-05-26T16:28:51Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "7c58b042d84d46e34b8d41f8deb663670a17a665"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc46zHTA",
          "commit": {
            "abbreviatedOid": "f1e1367"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-26T16:23:52Z",
          "updatedAt": "2022-05-26T16:23:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 81,
      "id": "PR_kwDOGKuqOc44qP3F",
      "title": "Small editorial changes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/81",
      "state": "MERGED",
      "author": "simon-friedberger",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Really just nits",
      "createdAt": "2022-05-30T07:07:00Z",
      "updatedAt": "2022-05-31T15:14:06Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "7c58b042d84d46e34b8d41f8deb663670a17a665",
      "headRepository": "simon-friedberger/draft-irtf-cfrg-vdaf",
      "headRefName": "main",
      "headRefOid": "313a0ce1a2f3ab41cde9dfb203cd92e6f63e2fee",
      "closedAt": "2022-05-31T15:14:06Z",
      "mergedAt": "2022-05-31T15:14:06Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "ed9b9043f362cb64be8bd6364be9f8e43f8a14b8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc47Cihr",
          "commit": {
            "abbreviatedOid": "313a0ce"
          },
          "author": "divergentdave",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-31T14:06:59Z",
          "updatedAt": "2022-05-31T14:06:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc47C_MM",
          "commit": {
            "abbreviatedOid": "313a0ce"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-31T15:12:10Z",
          "updatedAt": "2022-05-31T15:12:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 85,
      "id": "PR_kwDOGKuqOc45qXPm",
      "title": "poc: Define syntax for IDPFs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/85",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Partially addresses #84.",
      "createdAt": "2022-06-14T20:55:38Z",
      "updatedAt": "2022-06-16T18:57:22Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "7ad9f0e5c94240674a5881a188bc9aba133353f9",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/idpf-1",
      "headRefOid": "381d8e808549820b0ff74afb134e8099831be38a",
      "closedAt": "2022-06-16T18:57:22Z",
      "mergedAt": "2022-06-16T18:57:22Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "40198da9b45b16eb93d891a6847baa6ce512ff78"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "FYI, I pushed some minor changes to the syntax (https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/85/commits/447b04ca40686a0a951321a4ed68a3a4fdd6fb2d that resulted from having implemented the Poplar IDPF. I will squash the commit once the PR is approved.",
          "createdAt": "2022-06-16T01:44:26Z",
          "updatedAt": "2022-06-16T01:49:01Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc47_ytG",
          "commit": {
            "abbreviatedOid": "6b41b4a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-14T21:02:01Z",
          "updatedAt": "2022-06-14T21:02:02Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "@schoppmp we had previously talked about allowing each level of the hierarchy to have its own field. I decided to just define two fields, one for the leaves and another for the inner nodes. That's sufficient to admit the construction on the Poplar paper. Do you think more flexibility will be desirable?\r\n\r\nRemoving this flexibility seems useful for keeping things simple.",
              "createdAt": "2022-06-14T21:02:01Z",
              "updatedAt": "2022-06-14T21:02:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48CXj8",
          "commit": {
            "abbreviatedOid": "c62939c"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-15T10:25:32Z",
          "updatedAt": "2022-06-15T13:26:24Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "If it makes things easier, let's stick to two fields.",
              "createdAt": "2022-06-15T10:25:33Z",
              "updatedAt": "2022-06-15T13:26:24Z"
            },
            {
              "originalPosition": 11,
              "body": "Is this assuming that there could be an IDPF with >2 shares?",
              "createdAt": "2022-06-15T10:27:05Z",
              "updatedAt": "2022-06-15T13:26:24Z"
            },
            {
              "originalPosition": 46,
              "body": "How do you plan to implement this? I'm asking because it might make sense to keep intermediate state for the prefixes (i.e., the inner nodes in the DPF evaluation tree). Alternatively, you can always evaluate from the root, but then the total runtime for evaluating all levels sequentially will be quadratic in the number of levels.",
              "createdAt": "2022-06-15T13:25:52Z",
              "updatedAt": "2022-06-15T13:26:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48A6x4",
          "commit": {
            "abbreviatedOid": "c62939c"
          },
          "author": "divergentdave",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Here are some typo fixes:",
          "createdAt": "2022-06-15T05:11:10Z",
          "updatedAt": "2022-06-15T14:58:25Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\n    # The finite field used to represent the inner nodes of the IDPF tree.\r\n```",
              "createdAt": "2022-06-15T05:11:10Z",
              "updatedAt": "2022-06-15T14:58:25Z"
            },
            {
              "originalPosition": 22,
              "body": "```suggestion\r\n    # The type of each key generated by the IDPF-key generation algorithm.\r\n```",
              "createdAt": "2022-06-15T05:11:29Z",
              "updatedAt": "2022-06-15T14:58:25Z"
            },
            {
              "originalPosition": 51,
              "body": "```suggestion\r\n    # An error is raised if any element of `prefixes` is larger than or equal to\r\n```",
              "createdAt": "2022-06-15T05:14:28Z",
              "updatedAt": "2022-06-15T14:58:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48Eacm",
          "commit": {
            "abbreviatedOid": "04f9850"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-15T16:18:53Z",
          "updatedAt": "2022-06-15T16:20:54Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Yes. Of course for the Poplar IDPF, `SHARES == 2`.\r\n\r\n",
              "createdAt": "2022-06-15T16:18:53Z",
              "updatedAt": "2022-06-15T16:20:54Z"
            },
            {
              "originalPosition": 46,
              "body": "I'm planning on translating Figure 11 more or less directly, including carving out an explicit `EvalNext()` function. In the spec we will certainly want to note that implementations will typically make use of this stateful functionality.",
              "createdAt": "2022-06-15T16:20:38Z",
              "updatedAt": "2022-06-15T16:20:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48EiLP",
          "commit": {
            "abbreviatedOid": "c62939c"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-15T16:43:21Z",
          "updatedAt": "2022-06-15T16:43:22Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Does that mean that `eval_inner` with this signature will usually not be called, and instead people will call `eval_next`? Then why specify `eval_inner`?",
              "createdAt": "2022-06-15T16:43:22Z",
              "updatedAt": "2022-06-15T16:43:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48Ek6N",
          "commit": {
            "abbreviatedOid": "c62939c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-15T16:52:27Z",
          "updatedAt": "2022-06-15T16:52:27Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Hmm, good question. I suppose `eval_next()` will return either field type, depending on the value of `level`. Under the hood, both `eval_inner()` and `eval_leaf()` will call `eval_next()` some number of times.\r\n\r\nPerhaps it would make sense to just unify `eval_inner()` and `eval_leaf()` into one function that returns either field type, as in the paper. Thinking about the eventual Poplar1 spec, I think this would be a bit awkward.",
              "createdAt": "2022-06-15T16:52:27Z",
              "updatedAt": "2022-06-15T16:52:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48ErV_",
          "commit": {
            "abbreviatedOid": "c62939c"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-15T17:13:33Z",
          "updatedAt": "2022-06-15T17:13:33Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "> Perhaps it would make sense to just unify eval_inner() and eval_leaf() into one function that returns either field type, as in the paper. Thinking about the eventual Poplar1 spec, I think this would be a bit awkward.\r\n\r\nI think it's fine to have two functions for the two fields (in C++ I used a single templated function, I guess generics would work in Rust as well).\r\n\r\n> Under the hood, both eval_inner() and eval_leaf() will call eval_next() some number of times.\r\n\r\nMy point is that if you want to have a sequence of calls `eval_inner(key, 1, ...)`,  `eval_inner(key, 2, ...)`, ..., `eval_leaf(key, ...)`, the number of calls you'd have to make to `eval_next` would be quadratic in the number of levels if you don't save state between the `eval_inner` calls and pass it to the next call.\r\n",
              "createdAt": "2022-06-15T17:13:33Z",
              "updatedAt": "2022-06-15T17:13:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48Eule",
          "commit": {
            "abbreviatedOid": "c62939c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-15T17:23:19Z",
          "updatedAt": "2022-06-15T17:23:19Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Right, but the question is whether to address this in the syntax (by having `eval_inner()` output state to use in the next round) or leave to implementations. It sounds like you'd prefer the former?\r\n\r\nI'm good either way, though I have a weak preference for the latter, since it's slightly easier to present. One thing to keep in mind is that the VDAF syntax isn't stateful, so `Poplar1.prep_init()` will take as input a set of candidate prefixes and will end up with the quadratic explosion. Thus we will need to make a note there that `Poplar1` SHOULD be implemented in a way that avoids this.",
              "createdAt": "2022-06-15T17:23:19Z",
              "updatedAt": "2022-06-15T17:24:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48Ev9E",
          "commit": {
            "abbreviatedOid": "c62939c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-15T17:27:57Z",
          "updatedAt": "2022-06-15T17:27:57Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Remember that for the reference implementation we're after the clearest implementation, not necessarily the most efficient.",
              "createdAt": "2022-06-15T17:27:57Z",
              "updatedAt": "2022-06-15T17:27:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48E5tb",
          "commit": {
            "abbreviatedOid": "c62939c"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-15T18:01:12Z",
          "updatedAt": "2022-06-15T18:01:13Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "> Thus we will need to make a note there that Poplar1 SHOULD be implemented in a way that avoids this.\r\n\r\nCan you elaborate on how you'd implement this optimized version?\r\n\r\nI was thinking of passing the state into and out of the VDAF interface by appropriately defined input/output shares. In fact, in the C++ DPF library, I use an [`EvaluationContext`](https://github.com/google/distributed_point_functions/blob/0f7f758d2c67092c05a3b93ff4ae9ad00cca1487/dpf/distributed_point_function.proto#L156=) object as the input to [`EvaluateNext`](https://github.com/google/distributed_point_functions/blob/0f7f758d2c67092c05a3b93ff4ae9ad00cca1487/dpf/distributed_point_function.h#L307=)/[`EvaluateUntil`](https://github.com/google/distributed_point_functions/blob/0f7f758d2c67092c05a3b93ff4ae9ad00cca1487/dpf/distributed_point_function.h#L302=), which wraps a [`DpfKey`](https://github.com/google/distributed_point_functions/blob/0f7f758d2c67092c05a3b93ff4ae9ad00cca1487/dpf/distributed_point_function.proto#L129=) and additionally keeps state between iterations.\r\n\r\n> Remember that for the reference implementation we're after the clearest implementation, not necessarily the most efficient.\r\n\r\nAgreed, let's focus on simplicity and clarity over speed in the reference implementation. I just want to make sure that we don't rule out these efficient implementations via the syntax.",
              "createdAt": "2022-06-15T18:01:13Z",
              "updatedAt": "2022-06-15T18:01:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48E85c",
          "commit": {
            "abbreviatedOid": "c62939c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-15T18:12:48Z",
          "updatedAt": "2022-06-15T18:12:48Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "> Can you elaborate on how you'd implement this optimized version?\r\n> \r\n> I was thinking of passing the state into and out of the VDAF interface by appropriately defined input/output shares. In fact, in the C++ DPF library, I use an [`EvaluationContext`](https://github.com/google/distributed_point_functions/blob/0f7f758d2c67092c05a3b93ff4ae9ad00cca1487/dpf/distributed_point_function.proto#L156=) object as the input to [`EvaluateNext`](https://github.com/google/distributed_point_functions/blob/0f7f758d2c67092c05a3b93ff4ae9ad00cca1487/dpf/distributed_point_function.h#L307=)/[`EvaluateUntil`](https://github.com/google/distributed_point_functions/blob/0f7f758d2c67092c05a3b93ff4ae9ad00cca1487/dpf/distributed_point_function.h#L302=), which wraps a [`DpfKey`](https://github.com/google/distributed_point_functions/blob/0f7f758d2c67092c05a3b93ff4ae9ad00cca1487/dpf/distributed_point_function.proto#L129=) and additionally keeps state between iterations.\r\n\r\nYeah this is more or less what I would do in an efficient implementation of `Poplar1`. The [current API for libprio-rs](https://github.com/divviup/libprio-rs/blob/main/src/vdaf.rs#L164-L174) is too strict and will need to be changed in order to allow `prepare_init()` to to update this `EvaluationContext`.",
              "createdAt": "2022-06-15T18:12:48Z",
              "updatedAt": "2022-06-15T18:12:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48IiBk",
          "commit": {
            "abbreviatedOid": "c62939c"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T11:00:50Z",
          "updatedAt": "2022-06-16T11:00:50Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Okay, as long as this can still be implemented while being standard-compliant, I'm fine with it.",
              "createdAt": "2022-06-16T11:00:50Z",
              "updatedAt": "2022-06-16T11:00:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48IiWr",
          "commit": {
            "abbreviatedOid": "f5c0bf6"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T11:02:08Z",
          "updatedAt": "2022-06-16T11:03:44Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Does `Unsigned` here have a limit on the bit length? For large domains (e.g. 256 bits), `Bytes` might be more appropriate.",
              "createdAt": "2022-06-16T11:02:08Z",
              "updatedAt": "2022-06-16T11:03:44Z"
            },
            {
              "originalPosition": 42,
              "body": "Is there a particular reason for this change? It forces the caller to repeatedly deserialize `key`, right?",
              "createdAt": "2022-06-16T11:03:40Z",
              "updatedAt": "2022-06-16T11:03:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48JteE",
          "commit": {
            "abbreviatedOid": "f5c0bf6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T14:55:22Z",
          "updatedAt": "2022-06-16T14:55:22Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "No it doesn't. This seemed like a reasonable way to represent the input string and candidate prefixes, but I'm open to alternatives. One concern I have about `Bytes` is that we need to represent bit strings whose length are not a multiple of 8.\r\n\r\nOf course, the input string and prefixes need not have the same type. We could have the input string be `Bytes` (this will be perfectly fine for most applications, if not all) and we could define the candidate prefixes as `Unsigned` (and leave it to implementations to deal with larger domains).",
              "createdAt": "2022-06-16T14:55:22Z",
              "updatedAt": "2022-06-16T14:55:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48JuFL",
          "commit": {
            "abbreviatedOid": "f5c0bf6"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T14:56:59Z",
          "updatedAt": "2022-06-16T14:57:00Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Alright, if `Unsigned` doesn't have a limit then let's keep it, I agree that being able to specify the bit-length makes it a better choice than `Bytes`.",
              "createdAt": "2022-06-16T14:56:59Z",
              "updatedAt": "2022-06-16T14:57:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48Ju9r",
          "commit": {
            "abbreviatedOid": "f5c0bf6"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T14:59:16Z",
          "updatedAt": "2022-06-16T14:59:16Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "This is consistent with the (current) convention that anything that needs to be written to the network is dealt with explicitly as a `Bytes`. We might change this convention in the future, see https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/58. In any case, I think it's reasonable to leave this to implementations.",
              "createdAt": "2022-06-16T14:59:16Z",
              "updatedAt": "2022-06-16T14:59:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48JwJo",
          "commit": {
            "abbreviatedOid": "f5c0bf6"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T15:02:29Z",
          "updatedAt": "2022-06-16T15:02:29Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "SG",
              "createdAt": "2022-06-16T15:02:29Z",
              "updatedAt": "2022-06-16T15:02:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48JwV5",
          "commit": {
            "abbreviatedOid": "f5c0bf6"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-16T15:03:01Z",
          "updatedAt": "2022-06-16T15:03:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 86,
      "id": "PR_kwDOGKuqOc45vuQ6",
      "title": "poc: Add `OUT_LEN` parameter to IDPF syntax",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/86",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on #85 (merge that first).\r\n\r\nSpecifies that the output type is a vector over a finite field. This\r\nallows IDPFs to be specified that are more naturally integrated with the\r\nPoplar secure sketching scheme where one of the programmed outputs is\r\n`1` and the other is a random \"authenticator\" value.",
      "createdAt": "2022-06-16T02:46:27Z",
      "updatedAt": "2022-08-26T18:34:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "cjpatton/idpf-1",
      "baseRefOid": "381d8e808549820b0ff74afb134e8099831be38a",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/idpf-2",
      "headRefOid": "579bc3666311d36bea72062ae53a3ad29c61116d",
      "closedAt": "2022-06-16T18:59:11Z",
      "mergedAt": "2022-06-16T18:59:10Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "fbf37e01440ddc1ee51198d2e2a4fa9b467ea4c3"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Merged into the wrong branch!",
          "createdAt": "2022-06-16T19:02:48Z",
          "updatedAt": "2022-06-16T19:02:48Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc48JECD",
          "commit": {
            "abbreviatedOid": "e7e20a0"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T13:04:45Z",
          "updatedAt": "2022-06-16T13:06:03Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Doesn't the output length depend on the number of prefixes? Or is this to support tuples as values?",
              "createdAt": "2022-06-16T13:04:46Z",
              "updatedAt": "2022-06-16T13:06:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48JvP0",
          "commit": {
            "abbreviatedOid": "e7e20a0"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T14:59:58Z",
          "updatedAt": "2022-06-16T14:59:58Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "This is to support tuples as values. I guess the comments need to be clearer ...",
              "createdAt": "2022-06-16T14:59:58Z",
              "updatedAt": "2022-06-16T14:59:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48Jw4L",
          "commit": {
            "abbreviatedOid": "e7e20a0"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T15:04:34Z",
          "updatedAt": "2022-06-16T15:04:34Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Maybe call it `VALUE_LEN` then, since it's the length of one output value, not the entire output?",
              "createdAt": "2022-06-16T15:04:34Z",
              "updatedAt": "2022-06-16T15:04:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48Jw9B",
          "commit": {
            "abbreviatedOid": "e7e20a0"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-16T15:04:46Z",
          "updatedAt": "2022-06-16T15:04:46Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc48JxOF",
          "commit": {
            "abbreviatedOid": "e7e20a0"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T15:05:30Z",
          "updatedAt": "2022-06-16T15:05:31Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Oh that's better.",
              "createdAt": "2022-06-16T15:05:30Z",
              "updatedAt": "2022-06-16T15:05:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48LJS8",
          "commit": {
            "abbreviatedOid": "e7e20a0"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-16T18:58:47Z",
          "updatedAt": "2022-06-16T18:58:47Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Done.",
              "createdAt": "2022-06-16T18:58:47Z",
              "updatedAt": "2022-06-16T18:58:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 87,
      "id": "PR_kwDOGKuqOc45zD9b",
      "title": "poc: Add `VALUE_LEN` parameter to IDPF syntax",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/87",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Specifies that the output type is a vector over a finite field. This\r\nallows IDPFs to be defined that are more naturally integrated with the\r\nPoplar secure sketching scheme.",
      "createdAt": "2022-06-16T19:05:22Z",
      "updatedAt": "2022-08-26T18:34:29Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "40198da9b45b16eb93d891a6847baa6ce512ff78",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/idpf-2-retry",
      "headRefOid": "3c3049a5f1fd09c9411b4bc8dba9d0edd3edb2b4",
      "closedAt": "2022-06-16T19:08:41Z",
      "mergedAt": "2022-06-16T19:08:41Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "485e7c4cab08f0d0a1a763b423b265f222ba832e"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Replaces https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/86, which I merged into the wrong branch.",
          "createdAt": "2022-06-16T19:05:50Z",
          "updatedAt": "2022-06-16T19:06:08Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 88,
      "id": "PR_kwDOGKuqOc45z_cv",
      "title": "poc: Implement the Poplar IDPF",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/88",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #22.\r\nPartially addresses #84.\r\n\r\n\r\nImplement the Poplar IDPF, extended to allow the outputs to be tuples.\r\nThis required a few minor changes:\r\n\r\n* Extend the IPDF syntax so that `eval()` takes as input the Aggregator\r\n  ID. (This would be passed via `Poplar1.prep_init()`.)\r\n\r\n* Refactor `Prg` by adding a derived method, `next_vec()`, that outputs\r\n  a vector of field elements and updates the PRG state.\r\n\r\n* Allow fields to be defined that aren't suitable for FFT.",
      "createdAt": "2022-06-17T00:07:07Z",
      "updatedAt": "2022-08-26T18:34:17Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "3a4a167c1696b18c2f2dbf2b197b1e5428e6d619",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/idpf-3",
      "headRefOid": "abc10d841d69926c8bd4960027a39f5dd091c340",
      "closedAt": "2022-06-22T15:19:38Z",
      "mergedAt": "2022-06-22T15:19:37Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "e74218c3551f58e6c28b912ce4e2b59b1bb2c157"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc48MUkr",
          "commit": {
            "abbreviatedOid": "7b6d49d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-17T00:15:05Z",
          "updatedAt": "2022-06-17T00:15:05Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "@armfazh I was hoping you can double check that the encoding we specify here for `GF(2^255-19)` will be convenient for existing implementations of this field.",
              "createdAt": "2022-06-17T00:15:05Z",
              "updatedAt": "2022-06-17T00:15:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48MUto",
          "commit": {
            "abbreviatedOid": "7b6d49d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-17T00:16:32Z",
          "updatedAt": "2022-06-17T00:16:32Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "See `Field.encode_vec()` in `field.sage` for the encoding.",
              "createdAt": "2022-06-17T00:16:32Z",
              "updatedAt": "2022-06-17T00:16:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48MWAb",
          "commit": {
            "abbreviatedOid": "7b6d49d"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-17T00:29:23Z",
          "updatedAt": "2022-06-17T00:29:23Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "that function is using I2OSP, which is an encoding in big-endian format, while most implementations of Fp25519 use little-endian format.\r\nRelated: there is no check while decoding whether the numbers are fully reduced mod p.",
              "createdAt": "2022-06-17T00:29:23Z",
              "updatedAt": "2022-06-17T00:29:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48MXBT",
          "commit": {
            "abbreviatedOid": "7b6d49d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-17T00:39:54Z",
          "updatedAt": "2022-06-17T00:39:54Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "* Do you think it would be worth going to little-endian for compaitibility with existing implementations? Did you consider this in the hash-to-curve draft?\r\n* Good point about checking that the inputs are reduced mod p. Raised https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/89.",
              "createdAt": "2022-06-17T00:39:54Z",
              "updatedAt": "2022-06-17T00:39:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48QDQB",
          "commit": {
            "abbreviatedOid": "7b6d49d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-17T17:27:39Z",
          "updatedAt": "2022-06-17T17:27:40Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Ok, if we decide to use Fp25519 (as opposed to some other field of similar size), then we'll have to make accommodations. I will file an issue once this PR lands.",
              "createdAt": "2022-06-17T17:27:39Z",
              "updatedAt": "2022-06-17T17:27:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48QDwB",
          "commit": {
            "abbreviatedOid": "7b6d49d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-17T17:29:51Z",
          "updatedAt": "2022-06-17T17:29:51Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Precedent (thanks @armfazh): https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-voprf#section-4.1.1",
              "createdAt": "2022-06-17T17:29:51Z",
              "updatedAt": "2022-06-17T17:29:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48QD2Q",
          "commit": {
            "abbreviatedOid": "7b6d49d"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-17T17:30:16Z",
          "updatedAt": "2022-06-17T17:30:17Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "For example, in the [VOPRF draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-voprf#section-4.1.1), it is considered the encoding of fp25519 as little-endian.",
              "createdAt": "2022-06-17T17:30:16Z",
              "updatedAt": "2022-06-17T17:30:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48OAcL",
          "commit": {
            "abbreviatedOid": "a132005"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-17T10:15:35Z",
          "updatedAt": "2022-06-20T16:23:05Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I don't think this is computing \"the smallest power of 2 that is larger than or equal to n\".",
              "createdAt": "2022-06-17T10:15:35Z",
              "updatedAt": "2022-06-20T16:23:06Z"
            },
            {
              "originalPosition": 27,
              "body": "Here, \"prefix\" means bits starting from least significant to most significant, right? This should be explicitly documented.\r\nAlso, it seems like this just ignores the higher-level bits of `prefix`, so `is_prefix(0xABCD, 0xDECD, 1)` would return `True` (which might be intentional but again should be documented).",
              "createdAt": "2022-06-20T11:37:30Z",
              "updatedAt": "2022-06-20T16:23:06Z"
            },
            {
              "originalPosition": 65,
              "body": "... or too short",
              "createdAt": "2022-06-20T13:29:25Z",
              "updatedAt": "2022-06-20T16:23:06Z"
            },
            {
              "originalPosition": 58,
              "body": "Since we have a PRG with arbitrary stretch, we could go with the variant described in the last paragraph of Section C.2 in the paper. That is, instead of expanding the seed into two seeds and then expanding one seed to a group element and the \"actual\" seed again, we can generate the group element (of the current level) in parallel with the expansion of seeds for the next level. This saves at least one AES call per expansion. It's probably more relevant for `eval` than `gen`, but has to be considered in both places since the two variants are incompatible. This incompatibility also means that this needs to be decided sooner rather than later, unless we want to standardize both variants.",
              "createdAt": "2022-06-20T13:47:26Z",
              "updatedAt": "2022-06-20T16:23:06Z"
            },
            {
              "originalPosition": 83,
              "body": "Can you add a comment to the base class documentation what exactly the elements in `prefixes` are?",
              "createdAt": "2022-06-20T15:46:22Z",
              "updatedAt": "2022-06-20T16:23:06Z"
            },
            {
              "originalPosition": 27,
              "body": "One thing to consider is that with this notion of prefix, the leaves of the DPF tree do not enumerate the domain in order, but instead in bit-flipped order. I.e., the leftmost two leaves are 0 and 1 << l, not 0 and 1. This has implications for how the DPF evaluation depends on the location of non-zeros in the domain, i.e., how many non-zero prefixes you'll find in the part of the DPF evaluation trree close to the root.",
              "createdAt": "2022-06-20T15:53:04Z",
              "updatedAt": "2022-06-20T16:23:06Z"
            },
            {
              "originalPosition": 176,
              "body": "The fact that a part of the DPF keys is shared by aggregators has security implications for Poplar, so it would be good to emphasize this. If this is not enforced by the syntax (i.e., a malicious client could submit different correction words to the aggregators), then the aggregators need to check the CWs are the same at verification time.",
              "createdAt": "2022-06-20T16:21:23Z",
              "updatedAt": "2022-06-20T16:23:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48WrR3",
          "commit": {
            "abbreviatedOid": "429422e"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-20T17:20:19Z",
          "updatedAt": "2022-06-20T22:40:34Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "It seems to work for n > 0:\r\n* Suppose 2^k-1 < n < 2^k for some k > 0. Then (n-1).nbits() = k, thus next_power_of_2(n) = 2^k.\r\n* Suppose n = 2^k for some k >= 0. Then (n-1).nbits() = k, thus next_power_of_2(n) = 2^k.\r\n\r\nNote that nbits() is the number of bits required to encode the number. For example, (2^32-1).nbits() would be 32, but 2^32.nbits() would be 33.\r\n\r\nI added an assertion that n > 0. For context, this needed to change because sage can't precisely compute log(n) / log(2) for elements of field as large as `GF(2^255-19)`.",
              "createdAt": "2022-06-20T17:20:19Z",
              "updatedAt": "2022-06-20T22:40:34Z"
            },
            {
              "originalPosition": 65,
              "body": "Done",
              "createdAt": "2022-06-20T17:40:35Z",
              "updatedAt": "2022-06-20T22:40:35Z"
            },
            {
              "originalPosition": 83,
              "body": "Done",
              "createdAt": "2022-06-20T20:26:06Z",
              "updatedAt": "2022-06-20T22:40:35Z"
            },
            {
              "originalPosition": 27,
              "body": "I've modified the code to traverse `alpha` beginning with the most significant bit. This leads to a more natural definition of \"prefix\", which has been updated.",
              "createdAt": "2022-06-20T20:29:03Z",
              "updatedAt": "2022-06-20T22:40:34Z"
            },
            {
              "originalPosition": 176,
              "body": "Do you have an attack in mind? I thought that the \"secure sketch\" scheme would handle this.\r\n\r\nIn any case, a syntactic change seems useful here. However unless this really is a security issue for Poplar1,  then I would say let's hold off and do it in a future PR.",
              "createdAt": "2022-06-20T21:28:07Z",
              "updatedAt": "2022-06-20T22:40:35Z"
            },
            {
              "originalPosition": 58,
              "body": "I think only one variant should be specified. I don't quite understand the optimization, but would be happy to consider it in a future PR. I've added a TODO to consider this later.\r\n\r\n",
              "createdAt": "2022-06-20T22:40:14Z",
              "updatedAt": "2022-06-20T22:40:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48Xqle",
          "commit": {
            "abbreviatedOid": "7b6d49d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T00:36:49Z",
          "updatedAt": "2022-06-21T00:36:50Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "@schoppmp if you have no objection to using this particular field, I will open an issue to discuss what to do about endianness. Basically our options are:\r\n1. Use big-endian for all fields (status quo). This seems \"standard\", but would be slightly inconvenient for anyone using an existing implementation of Fp25519.\r\n2. Use little-endian for all fields. My impression is that this would be somewhat non-standard, as many CFRG things use I2OSP() for encoding numbers.\r\n3. Allow each field to specify its own `encode_vec()`.\r\n4. If we decide to not be prescriptive about encoding (cf. #58), then this is a non-issue.",
              "createdAt": "2022-06-21T00:36:50Z",
              "updatedAt": "2022-06-21T00:36:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48aPiy",
          "commit": {
            "abbreviatedOid": "7b6d49d"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T12:28:21Z",
          "updatedAt": "2022-06-21T12:28:22Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I have no objections to using this field.",
              "createdAt": "2022-06-21T12:28:21Z",
              "updatedAt": "2022-06-21T12:28:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48aQUd",
          "commit": {
            "abbreviatedOid": "7b6d49d"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T12:30:36Z",
          "updatedAt": "2022-06-21T12:30:36Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "You are right, I somehow misread this as `(1<<(n-1)).nbits()`.",
              "createdAt": "2022-06-21T12:30:36Z",
              "updatedAt": "2022-06-21T12:30:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48aRES",
          "commit": {
            "abbreviatedOid": "7b6d49d"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T12:32:48Z",
          "updatedAt": "2022-06-21T12:32:48Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I suggest adding parentheses or spaces, even though the operator precedence is pretty clear in this case.",
              "createdAt": "2022-06-21T12:32:48Z",
              "updatedAt": "2022-06-21T12:32:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48aSYV",
          "commit": {
            "abbreviatedOid": "a132005"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T12:36:31Z",
          "updatedAt": "2022-06-21T12:36:32Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "The security issue is described in Appendix D in the paper. Basically, a malicious client could create a DPF that has non-zero output in two location instead of one when the correction words given to each aggregator are different.",
              "createdAt": "2022-06-21T12:36:32Z",
              "updatedAt": "2022-06-21T12:36:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48aTAP",
          "commit": {
            "abbreviatedOid": "d3a7889"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T12:38:21Z",
          "updatedAt": "2022-06-21T13:56:29Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "As written in the older comment, I suggest adding parentheses:\r\n`2 ** ((n - 1).nbits())`",
              "createdAt": "2022-06-21T12:38:21Z",
              "updatedAt": "2022-06-21T13:56:29Z"
            },
            {
              "originalPosition": 16,
              "body": "Does the notion of \"most significant bit\" not depend on the integer type? I.e., for a 8-bit integer with value 6 (00000110), the MSB is 0, and it would not be a prefix of the 8-bit integer 25 (00011001). Maybe you can say \"is equal to the most significant `L` bits among the `BITS` least significant bits of `y`.\"? In that case, 6 would be a prefix of 25 again if `BITS == 5`.",
              "createdAt": "2022-06-21T12:46:28Z",
              "updatedAt": "2022-06-21T13:56:29Z"
            },
            {
              "originalPosition": 42,
              "body": "See above.",
              "createdAt": "2022-06-21T12:47:53Z",
              "updatedAt": "2022-06-21T13:56:29Z"
            },
            {
              "originalPosition": 45,
              "body": "Maybe add an assertion that `L >= IdpfPoplar.BITS` (or whatever error handling you want to use in this reference implementation)",
              "createdAt": "2022-06-21T12:49:45Z",
              "updatedAt": "2022-06-21T13:56:29Z"
            },
            {
              "originalPosition": 50,
              "body": "```suggestion\r\n    # the end of [BBCGGI21, Appendix C.3]. This could on average reduce the number of\r\n```",
              "createdAt": "2022-06-21T13:56:17Z",
              "updatedAt": "2022-06-21T13:56:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48dSbv",
          "commit": {
            "abbreviatedOid": "6572ae0"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-21T22:22:08Z",
          "updatedAt": "2022-06-22T01:03:46Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Done.",
              "createdAt": "2022-06-21T22:22:08Z",
              "updatedAt": "2022-06-22T01:03:46Z"
            },
            {
              "originalPosition": 16,
              "body": "Nice catch. In fact we need to refine this a bit more, since we care about the `L` least significant bits of `x`. (See updated definition.)\r\n\r\nTaking a step back: Is this the right way to define prefixes? What's nice about it is that each prefix at tree level `level` can be expressed as an `L`-bit integer.",
              "createdAt": "2022-06-21T22:41:44Z",
              "updatedAt": "2022-06-22T01:03:46Z"
            },
            {
              "originalPosition": 42,
              "body": "Done.",
              "createdAt": "2022-06-21T22:41:52Z",
              "updatedAt": "2022-06-22T01:03:46Z"
            },
            {
              "originalPosition": 45,
              "body": "Added an assertion that `0 < L and L < IdpfPoplar.BITS`. I don't think this going to end up appearing in the spec (maybe it will?) so an `assert` is sufficient.",
              "createdAt": "2022-06-21T22:43:46Z",
              "updatedAt": "2022-06-22T01:03:46Z"
            },
            {
              "originalPosition": 23,
              "body": "Raised https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/90.",
              "createdAt": "2022-06-21T23:47:54Z",
              "updatedAt": "2022-06-22T01:03:46Z"
            },
            {
              "originalPosition": 58,
              "body": "Bump :)",
              "createdAt": "2022-06-21T23:48:11Z",
              "updatedAt": "2022-06-22T01:03:46Z"
            },
            {
              "originalPosition": 176,
              "body": "Got it, nice catch. Let's be sure to address this now. I crated https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/91 and rebased this PR on top.\r\n\r\nA potential way to solve this without syntax changes would be to have the Aggregators exchange the hash of the correction words during preparation. This seems a little hacky to me. Plus, as pointed out in the TODO encoding the correction words in each input share is wasteful.\r\n",
              "createdAt": "2022-06-21T23:51:02Z",
              "updatedAt": "2022-06-22T01:03:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48doUI",
          "commit": {
            "abbreviatedOid": "a132005"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T01:04:55Z",
          "updatedAt": "2022-06-22T01:04:56Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "I have rebase on top of #91. For your convenience, you can see the changes by looking at `git pull && git diff 6a51ac1..6572ae0`",
              "createdAt": "2022-06-22T01:04:56Z",
              "updatedAt": "2022-06-22T01:04:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48doW3",
          "commit": {
            "abbreviatedOid": "7b6d49d"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T01:05:21Z",
          "updatedAt": "2022-06-22T01:05:21Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done.",
              "createdAt": "2022-06-22T01:05:21Z",
              "updatedAt": "2022-06-22T01:05:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48dpIH",
          "commit": {
            "abbreviatedOid": "a132005"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T01:10:11Z",
          "updatedAt": "2022-06-22T01:10:12Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Bump",
              "createdAt": "2022-06-22T01:10:11Z",
              "updatedAt": "2022-06-22T01:10:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48ficO",
          "commit": {
            "abbreviatedOid": "a132005"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T10:12:01Z",
          "updatedAt": "2022-06-22T10:12:01Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "The new definition of prefix sounds good.",
              "createdAt": "2022-06-22T10:12:01Z",
              "updatedAt": "2022-06-22T10:12:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48fijO",
          "commit": {
            "abbreviatedOid": "a132005"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T10:12:22Z",
          "updatedAt": "2022-06-22T10:12:22Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Sounds good.",
              "createdAt": "2022-06-22T10:12:22Z",
              "updatedAt": "2022-06-22T10:12:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48fj-L",
          "commit": {
            "abbreviatedOid": "a132005"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T10:16:31Z",
          "updatedAt": "2022-06-22T10:16:32Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Thanks! #91 looks good to me.",
              "createdAt": "2022-06-22T10:16:32Z",
              "updatedAt": "2022-06-22T10:16:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48fk0R",
          "commit": {
            "abbreviatedOid": "d3a7889"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T10:18:24Z",
          "updatedAt": "2022-06-22T10:18:24Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "> Taking a step back: Is this the right way to define prefixes? What's nice about it is that each prefix at tree level level can be expressed as an L-bit integer.\r\n\r\nI agree it's quite complicated, but I also haven't found an easier way to express it. Maybe if we went to a \"bit vector\" type instead of numbers for alpha and prefixes?",
              "createdAt": "2022-06-22T10:18:24Z",
              "updatedAt": "2022-06-22T10:18:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48ftf8",
          "commit": {
            "abbreviatedOid": "a132005"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T10:43:43Z",
          "updatedAt": "2022-06-22T10:43:44Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "> For your convenience, you can see the changes by looking at git pull && git diff 6a51ac1..6572ae0\r\n\r\nThis doesn't work for me, as `6a51ac1` is not part of any active branch (I hadn't pulled the previous version).\r\nWould it work to defer rebasing until the commit is fully reviewed? Then the GH web interface shows the diff nicely.",
              "createdAt": "2022-06-22T10:43:44Z",
              "updatedAt": "2022-06-22T10:43:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48fttX",
          "commit": {
            "abbreviatedOid": "d3a7889"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T10:44:28Z",
          "updatedAt": "2022-06-22T10:44:28Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Either way I think this can be addressed in a future PR.",
              "createdAt": "2022-06-22T10:44:28Z",
              "updatedAt": "2022-06-22T10:44:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48ft1l",
          "commit": {
            "abbreviatedOid": "a132005"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T10:44:56Z",
          "updatedAt": "2022-06-22T10:44:57Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Either way, this PR looks good assuming no substantial changes beyond what's commented on.",
              "createdAt": "2022-06-22T10:44:57Z",
              "updatedAt": "2022-06-22T10:44:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48ft6y",
          "commit": {
            "abbreviatedOid": "6572ae0"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-22T10:45:13Z",
          "updatedAt": "2022-06-22T10:45:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOGKuqOc48hYVU",
          "commit": {
            "abbreviatedOid": "a132005"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T15:15:43Z",
          "updatedAt": "2022-06-22T15:15:44Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Ohhh, `6a51ac1` only exists in my reflog. I thought pushing would have also pushed that head.\r\n\r\nI typically try to hold off on rebasing until review is done, but in this instance we needed to rebase on #91. This would all be much easier if we had Gerrit..\r\n\r\nIn any case, there were no significant changes. Here's the patch:\r\n```\r\ndiff --git a/poc/idpf.sage b/poc/idpf.sage\r\nindex 4191c4f..e95637f 100644\r\n--- a/poc/idpf.sage\r\n+++ b/poc/idpf.sage\r\n@@ -91,7 +91,7 @@ def test_idpf_exhaustive(Idpf, alpha):\r\n     beta_leaf = Idpf.FieldLeaf.rand_vec(Idpf.VALUE_LEN)\r\n\r\n     # Generate the IDPF keys.\r\n-    keys = Idpf.gen(alpha, beta_inner, beta_leaf)\r\n+    (public_share, keys) = Idpf.gen(alpha, beta_inner, beta_leaf)\r\n\r\n     # Evaluate the IDPF at every node of the tree.\r\n     for level in range(Idpf.BITS):\r\n@@ -100,7 +100,9 @@ def test_idpf_exhaustive(Idpf, alpha):\r\n\r\n         out_shares = []\r\n         for agg_id in range(Idpf.SHARES):\r\n-            out_shares.append(Idpf.eval(agg_id, keys[agg_id], level, prefixes))\r\n+            out_shares.append(\r\n+                Idpf.eval(agg_id, public_share,\r\n+                          keys[agg_id], level, prefixes))\r\n\r\n         # Check that each set of output shares for each prefix sums up to the\r\n         # correct value.\r\ndiff --git a/poc/idpf_poplar.sage b/poc/idpf_poplar.sage\r\nindex e0c33ac..2f71e96 100644\r\n--- a/poc/idpf_poplar.sage\r\n+++ b/poc/idpf_poplar.sage\r\n@@ -69,16 +69,17 @@ class IdpfPoplar(Idpf):\r\n                 w_cw = vec_neg(w_cw)\r\n             correction_words.append((seed_cw, ctrl_cw, w_cw))\r\n\r\n-        return IdpfPoplar.encode_keys(correction_words, init_seed)\r\n+        public_share = IdpfPoplar.encode_public_share(correction_words)\r\n+        return (public_share, init_seed)\r\n\r\n     @classmethod\r\n-    def eval(IdpfPoplar, agg_id, key, level, prefixes):\r\n+    def eval(IdpfPoplar, agg_id, public_share, init_seed, level, prefixes):\r\n         if agg_id >= IdpfPoplar.SHARES:\r\n             raise ERR_INPUT # invalid aggregator ID\r\n         if level >= IdpfPoplar.BITS:\r\n             raise ERR_INPUT # level too deep\r\n\r\n-        (correction_words, init_seed) = IdpfPoplar.decode_key(key)\r\n+        correction_words = IdpfPoplar.decode_public_share(public_share)\r\n         out_share = []\r\n         for prefix in prefixes:\r\n             if prefix >= 2^level:\r\n@@ -156,28 +157,23 @@ class IdpfPoplar(Idpf):\r\n         return (next_seed, w)\r\n\r\n     @classmethod\r\n-    def encode_keys(IdpfPoplar, correction_words, init_seed):\r\n+    def encode_public_share(IdpfPoplar, correction_words):\r\n         encoded = Bytes()\r\n         for (level, (seed_cw, ctrl_cw, w_cw)) in enumerate(correction_words):\r\n             encoded += seed_cw\r\n-            # TODO Packing only two control bits into a byte is wasteful.\r\n-            # Consider packing them more tightly.\r\n+            # TODO Consider packing the correction bits more tightly. This\r\n+            # encoding is designed to make it convenient for implementations to\r\n+            # \"throw away\" correction words they know they're no longer going to\r\n+            # need. However, using a byte to encode two bits is slightly\r\n+            # wasteful.\r\n             encoded += byte(ctrl_cw[0].as_unsigned() | \\\r\n                            (ctrl_cw[1].as_unsigned() << 1))\r\n             Field = IdpfPoplar.current_field(level)\r\n             encoded += Field.encode_vec(w_cw)\r\n-        # TODO The correction words vector needs to be encoded by both IPDF key\r\n-        # shares so that both Aggregators have access to it. This is wasteful\r\n-        # for applications like DAP in which the VDAF input shares are encrypted\r\n-        # and sent to one Aggregator: The correction words vector ends up\r\n-        # getting sent twice when sending them once would have been sufficient.\r\n-        #\r\n-        # Consider modifying the VDAF syntax so that the sharding algorithm\r\n-        # outputs a public value shared by all Aggregators.\r\n-        return [encoded + init_seed[0], encoded + init_seed[1]]\r\n+        return encoded\r\n\r\n     @classmethod\r\n-    def decode_key(IdpfPoplar, encoded):\r\n+    def decode_public_share(IdpfPoplar, encoded):\r\n         correction_words = []\r\n         for level in range(IdpfPoplar.BITS):\r\n             l = IdpfPoplar.Prg.SEED_SIZE\r\n@@ -189,11 +185,9 @@ class IdpfPoplar(Idpf):\r\n             encoded_w_cw, encoded = encoded[:l], encoded[l:]\r\n             w_cw = Field.decode_vec(encoded_w_cw)\r\n             correction_words.append((seed_cw, ctrl_cw, w_cw))\r\n-        l = IdpfPoplar.Prg.SEED_SIZE\r\n-        seed, encoded = encoded[:l], encoded[l:]\r\n         if len(encoded) != 0:\r\n             raise ERR_DECODE\r\n-        return (correction_words, seed)\r\n+        return correction_words\r\n\r\n     @classmethod\r\n     def with_prg(IdpfPoplar, Prg):\r\n```",
              "createdAt": "2022-06-22T15:15:43Z",
              "updatedAt": "2022-06-22T15:15:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48hZOu",
          "commit": {
            "abbreviatedOid": "d3a7889"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T15:17:21Z",
          "updatedAt": "2022-06-22T15:17:21Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I think an explicit \"bit-vector\" representation would end up being cumbersome. It's complicated, and therefore needs to be explained well, but it seems like the best option to me.",
              "createdAt": "2022-06-22T15:17:21Z",
              "updatedAt": "2022-06-22T15:17:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 91,
      "id": "PR_kwDOGKuqOc46EuE6",
      "title": "Add public share to sharding algorithm",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/91",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Partially addresses #84.\r\n\r\nModifies the syntax for (V)DAFs to allow the Client to generate a\r\n\"public share\" that is distributed to all of the Aggregators. This is to\r\nsupport VDAFs such as Poplar1 that require an IDPF. (See see [BBCGGI21,\r\nAppendix D].)",
      "createdAt": "2022-06-22T00:14:19Z",
      "updatedAt": "2022-08-26T18:34:17Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "485e7c4cab08f0d0a1a763b423b265f222ba832e",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/idpf-3-public-share",
      "headRefOid": "64ed2762dd74cb680b6233f41d8fc26c929933ff",
      "closedAt": "2022-06-22T15:08:58Z",
      "mergedAt": "2022-06-22T15:08:57Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "3a4a167c1696b18c2f2dbf2b197b1e5428e6d619"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc48dn9N",
          "commit": {
            "abbreviatedOid": "9a15373"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-22T01:01:55Z",
          "updatedAt": "2022-06-22T01:01:55Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\n  Aggregators, and a corresponding sequence of input shares, one for each\r\n```",
              "createdAt": "2022-06-22T01:01:55Z",
              "updatedAt": "2022-06-22T01:01:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc48fjg1",
          "commit": {
            "abbreviatedOid": "9a15373"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-22T10:14:59Z",
          "updatedAt": "2022-06-22T10:14:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 93,
      "id": "PR_kwDOGKuqOc46bfEb",
      "title": "Update Poplar1 syntax to match VDAF definition",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/93",
      "state": "MERGED",
      "author": "schoppmp",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-06-27T16:35:25Z",
      "updatedAt": "2022-06-29T16:26:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "d272ec9d17e61205da5189c124ba7687b23f8dfd",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "schoppmp/poplar1",
      "headRefOid": "9d75d1a7e08f9cf5d5ca0c207b6349ae8f231599",
      "closedAt": "2022-06-28T15:32:08Z",
      "mergedAt": "2022-06-28T15:32:08Z",
      "mergedBy": "schoppmp",
      "mergeCommit": {
        "oid": "bd63d077e9e67b8792fb3fe767bf21fa13a5ab07"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "For the record, this partially addresses #84.",
          "createdAt": "2022-06-29T16:26:08Z",
          "updatedAt": "2022-06-29T16:26:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc481Nv2",
          "commit": {
            "abbreviatedOid": "04da027"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This is definitely moving in the right direction. One open question before we merge: Should `level` be in range `[1, BITS]` or `[0, BITS)`? The latter is used in the reference code, if I remember right.",
          "createdAt": "2022-06-27T18:02:06Z",
          "updatedAt": "2022-06-27T18:17:03Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\n`beta`, one for each \"level\" `1 <= L <= BITS`. The key generation algorithm generates two\r\n```",
              "createdAt": "2022-06-27T18:02:06Z",
              "updatedAt": "2022-06-27T18:17:03Z"
            },
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nIDPF keys, one for each Aggregator. When evaluated at level `L` and index `0 <= x < 2^L`, each\r\n```",
              "createdAt": "2022-06-27T18:02:54Z",
              "updatedAt": "2022-06-27T18:17:03Z"
            },
            {
              "originalPosition": 39,
              "body": "Ack, feel free to remove my comment.",
              "createdAt": "2022-06-27T18:04:12Z",
              "updatedAt": "2022-06-27T18:17:03Z"
            },
            {
              "originalPosition": 52,
              "body": "nit: Remove colon (\":\") and put the function definition on a single line. https://github.com/cfrg/draft-irtf-cfrg-vdaf/blob/main/draft-irtf-cfrg-vdaf.md?plain=1#L476\r\n\r\nHere and below.",
              "createdAt": "2022-06-27T18:10:10Z",
              "updatedAt": "2022-06-27T18:17:03Z"
            },
            {
              "originalPosition": 70,
              "body": "The reference implementation begins indexing the levels at `0` rather than `1`. I don't care which we go with, as long as we're consistent. If you want to change this, either file an issue to fix the reference implementation or fix the reference implementation in this PR.",
              "createdAt": "2022-06-27T18:12:24Z",
              "updatedAt": "2022-06-27T18:17:03Z"
            },
            {
              "originalPosition": 81,
              "body": "```suggestion\r\n  associated constants as `Field` in {{field}}.\r\n```",
              "createdAt": "2022-06-27T18:13:10Z",
              "updatedAt": "2022-06-27T18:17:03Z"
            },
            {
              "originalPosition": 141,
              "body": "```suggestion\r\n  (key_0, key_1) = Idpf.gen(alpha, beta[:-1], beta[-1])\r\n```",
              "createdAt": "2022-06-27T18:14:05Z",
              "updatedAt": "2022-06-27T18:17:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc485EHQ",
          "commit": {
            "abbreviatedOid": "04da027"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-28T11:45:33Z",
          "updatedAt": "2022-06-28T11:45:33Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Done.",
              "createdAt": "2022-06-28T11:45:33Z",
              "updatedAt": "2022-06-28T11:45:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc485EJI",
          "commit": {
            "abbreviatedOid": "04da027"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-28T11:45:39Z",
          "updatedAt": "2022-06-28T11:45:40Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Done.",
              "createdAt": "2022-06-28T11:45:39Z",
              "updatedAt": "2022-06-28T11:45:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc485Ec3",
          "commit": {
            "abbreviatedOid": "04da027"
          },
          "author": "schoppmp",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-28T11:46:47Z",
          "updatedAt": "2022-06-28T11:46:47Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Changed it, now levels begin at 0.",
              "createdAt": "2022-06-28T11:46:47Z",
              "updatedAt": "2022-06-28T11:46:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc486NxM",
          "commit": {
            "abbreviatedOid": "9d75d1a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Approving to unblock this merge so that you can go on PTO with a clean plate. This is a great start!\r\n\r\nWould you mind squashing before merging?",
          "createdAt": "2022-06-28T14:54:39Z",
          "updatedAt": "2022-06-28T14:54:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 95,
      "id": "PR_kwDOGKuqOc46mkc0",
      "title": "Pass num_measurements when computing AggResult, add decode methods",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/95",
      "state": "MERGED",
      "author": "divergentdave",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This implements the change proposed by #92, passing `num_measurements` to `agg_shares_to_result()`. For Prio3, I decided to thread this through both the FLP and validity circuit layers, in new `decode()` methods. With this change, `encode()`, `truncate()`, and `decode()` now give us a more complete API for Prio's AFEs. To test this, I wrote a quick Average type that makes use of the new argument. I also took advantage of the new flexibility in `Prio3.AggResult` to change the output types of Prio3Aes128Count and Prio3Aes128Sum to be `Unsigned`, as it's more intuitive and ergonomic. (If we don't like that last bit, it's separated out in the commit history already)",
      "createdAt": "2022-06-29T23:01:06Z",
      "updatedAt": "2022-07-08T17:01:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "bd63d077e9e67b8792fb3fe767bf21fa13a5ab07",
      "headRepository": "divergentdave/vdaf",
      "headRefName": "afe-decode-with-number-of-measurements",
      "headRefOid": "9eed57da7d68c64e49a42ce08ff5dcb724ecf844",
      "closedAt": "2022-07-08T17:01:47Z",
      "mergedAt": "2022-07-08T17:01:47Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "a363a96268edbb2fedac26766696efaddcde0f70"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @divergentdave! Please squash the last commit (\"Review comments\") before merging. Great work.",
          "createdAt": "2022-07-08T14:32:29Z",
          "updatedAt": "2022-07-08T14:32:29Z"
        },
        {
          "author": "divergentdave",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I rebased to clean up the commit history, and also added an editorial change to the spec (propagating the x => bucket_count change) and fixed two associated types in test-only classes. https://github.com/cfrg/draft-irtf-cfrg-vdaf/compare/5e772df22a071f8fab828073a361805424399ff8..9eed57da7d68c64e49a42ce08ff5dcb724ecf844",
          "createdAt": "2022-07-08T15:51:07Z",
          "updatedAt": "2022-07-08T15:51:07Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc49Csm2",
          "commit": {
            "abbreviatedOid": "e29d2df"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks @divergentdave! I massively appreciate your thoroughness and attention to detail here. Adding test code to exercise the new logic is particularly appreciated.\r\n\r\nI will give this a thorough review next Thursday, 7/7, when I'm back from PTO. In the meantime, a few high-level things:\r\n* I'm a bit weary of the reference implementation defining the VDAF `Prio3Aes128Average` without also defining it in the draft itself. That said it's definitely useful to exercise the API changes that are introduced in this change. We should either add it it to the draft or rename it to something like `TestPrio3Aes128Average` (to suggest that it's there for testing, but may eventually go in the draft).\r\n* Don't worry about updating the change log. We'll wait to do so until we're ready to cut the next draft.",
          "createdAt": "2022-06-29T23:44:23Z",
          "updatedAt": "2022-06-29T23:47:20Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Does this method actually need to be re-implemented?",
              "createdAt": "2022-06-29T23:44:23Z",
              "updatedAt": "2022-06-29T23:47:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc49CwPd",
          "commit": {
            "abbreviatedOid": "e29d2df"
          },
          "author": "divergentdave",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-30T00:17:37Z",
          "updatedAt": "2022-06-30T00:17:37Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I re-implemented it to swap out `flp_generic.Sum` for `flp_generic.Average`. I could possibly define some new members on `Prio3Aes128Sum`, and and override a member for the validity circuit instead, but I figure the separate factory classmethod is less invasive.",
              "createdAt": "2022-06-30T00:17:37Z",
              "updatedAt": "2022-06-30T00:17:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc49h1rf",
          "commit": {
            "abbreviatedOid": "dd81b5c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Excellent work! Just a few minor comments and this'll be ready to merge.",
          "createdAt": "2022-07-08T00:29:36Z",
          "updatedAt": "2022-07-08T00:41:08Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "nit: Since this parameter gets ignored here, prefix it with `_`. ",
              "createdAt": "2022-07-08T00:29:36Z",
              "updatedAt": "2022-07-08T00:41:08Z"
            },
            {
              "originalPosition": 103,
              "body": "A more descriptive name than `x` would be useful. How about `bucket_count`?",
              "createdAt": "2022-07-08T00:33:03Z",
              "updatedAt": "2022-07-08T00:41:08Z"
            },
            {
              "originalPosition": 115,
              "body": "I'm not sure we should have `float` as the result type, since the measurements are `Unsigned` and thus have a different precisison. What about defining this aggregation function as `floor(average(measurements))` and letting `AggResult = Unsigned`.",
              "createdAt": "2022-07-08T00:37:15Z",
              "updatedAt": "2022-07-08T00:41:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc49klPy",
          "commit": {
            "abbreviatedOid": "5e772df"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-08T14:31:52Z",
          "updatedAt": "2022-07-08T14:31:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 96,
      "id": "PR_kwDOGKuqOc47Hs73",
      "title": "Revert \"Pass num_measurements when computing AggResult, add decode methods\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/96",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Reverts cfrg/draft-irtf-cfrg-vdaf#95. This was reviewed and ready for approval, but I got punchy and merged before @nakatsuka-y had a chance to squash.",
      "createdAt": "2022-07-08T17:03:41Z",
      "updatedAt": "2022-08-26T18:34:16Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "a363a96268edbb2fedac26766696efaddcde0f70",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "revert-95-afe-decode-with-number-of-measurements",
      "headRefOid": "b0d8e24ca426fdf6f4f05b52b043ecb74fc2a100",
      "closedAt": "2022-07-08T17:03:49Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 97,
      "id": "PR_kwDOGKuqOc47JZA-",
      "title": "Complete spec of Poplar1",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/97",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #84.\r\nCloses #44.\r\n\r\nCompletes the specification of Poplar1, including the reference\r\nimplementation and test vectors.\r\n\r\n* poc: Add additional tests for IdpfPoplar.\r\n* poc: Modify Idpf syntax so that the size of the keys is defined. This\r\n  is needed for decoding the keysfrom the Poplar1 input share.\r\n* poc: Fix a minor bug in IdpfPoplar that caused `eval()` to throw an\r\n  error when it shouldn't.\r\n* poc: Have `eval()` check that the prefixes are unique. This is needed\r\n  for Poplar1, which checks for one-hotness of the output shares.\r\n* poc: Fix various typos.\r\n* poc: Implement Poplar1 and add code for generating test vectors.\r\n* Add new field `Field255`, as required for IdpfPoplar.\r\n* Refactor Prg interface to align with reference implementation.\r\n* Re-generate test vectors and add test vectors for Poplar1Aes128.",
      "createdAt": "2022-07-09T23:04:45Z",
      "updatedAt": "2022-08-26T18:34:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "a363a96268edbb2fedac26766696efaddcde0f70",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/84/1",
      "headRefOid": "352a8d2db8c447c119f663650f7b198e562895cb",
      "closedAt": "2022-07-11T21:00:31Z",
      "mergedAt": "2022-07-11T21:00:31Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "a88e2cef27b754677e2a6c30bc1e070f75f9012a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc49qe6R",
          "commit": {
            "abbreviatedOid": "e3b465c"
          },
          "author": "divergentdave",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good, I left remarks with a variety of small cleanups. I'm excited!",
          "createdAt": "2022-07-11T15:34:24Z",
          "updatedAt": "2022-07-11T19:02:42Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "This reflects a change I made in #95, which is not in draft-01. I see the `01` directory is named after the draft number, so I think the `agg_result`-unwrapping part of this should be backed out, and the new Poplar1 test vectors should go in a different directory. (\"latest\"? \"next\"? \"02\"?)",
              "createdAt": "2022-07-11T15:34:24Z",
              "updatedAt": "2022-07-11T19:02:42Z"
            },
            {
              "originalPosition": 199,
              "body": "nit\r\n```suggestion\r\n  The type of the output depends on the value of `level`: If `level < Idpf.BITS-1`,\r\n```",
              "createdAt": "2022-07-11T16:05:25Z",
              "updatedAt": "2022-07-11T19:02:42Z"
            },
            {
              "originalPosition": 201,
              "body": "For consistency:\r\n```suggestion\r\n  `Vec[Idpf.FieldInner]`; otherwise, if `level == Idpf.BITS-1`, then the output is\r\n```",
              "createdAt": "2022-07-11T16:05:56Z",
              "updatedAt": "2022-07-11T19:02:42Z"
            },
            {
              "originalPosition": 202,
              "body": "Should we make the two layers of `Vec` explicit here?\r\n```suggestion\r\n  `Vec[Vec[Idpf.FieldInner]]`; otherwise, if `level == BITS-1`, then the output is\r\n  the value for a leaf node, which has type `Vec[Vec[Idpf.FieldLeaf]]`.\r\n```",
              "createdAt": "2022-07-11T16:07:30Z",
              "updatedAt": "2022-07-11T19:02:42Z"
            },
            {
              "originalPosition": 411,
              "body": "nit\r\n```suggestion\r\n    # requires expanding PRG seeds into a vector of field elements\r\n```",
              "createdAt": "2022-07-11T17:25:19Z",
              "updatedAt": "2022-07-11T19:02:42Z"
            },
            {
              "originalPosition": 814,
              "body": "I think this got left over from the prior section.\r\n```suggestion\r\nThe description of the IDPF evaluation algorithm makes use\r\n```",
              "createdAt": "2022-07-11T18:32:41Z",
              "updatedAt": "2022-07-11T19:02:42Z"
            },
            {
              "originalPosition": 849,
              "body": "I think the prefix-of relationship is backwards here.\r\n```suggestion\r\n            # example, when using `IdpfPoplar` to compute heavy\r\n            # hitters, a string whose hit count exceeded the given\r\n            # threshold in the last round would be the prefix of each\r\n            # `prefix` in the current round. (See\r\n```",
              "createdAt": "2022-07-11T18:37:28Z",
              "updatedAt": "2022-07-11T19:02:42Z"
            },
            {
              "originalPosition": 867,
              "body": "Should this refer to C.2? C.3 is just a proof.\r\n```suggestion\r\n# discussed at the end of [BBCGGI21, Appendix C.2]. This could on\r\n```",
              "createdAt": "2022-07-11T18:42:10Z",
              "updatedAt": "2022-07-11T19:02:42Z"
            },
            {
              "originalPosition": 961,
              "body": "See my comment regarding the Prio3 test vector files",
              "createdAt": "2022-07-11T18:49:08Z",
              "updatedAt": "2022-07-11T19:02:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc49riC0",
          "commit": {
            "abbreviatedOid": "e3b465c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Couple of high-level notes, otherwise LGTM",
          "createdAt": "2022-07-11T19:17:57Z",
          "updatedAt": "2022-07-11T19:31:18Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "I note that before you say `1 <= L <= BITS` and here you say `[0, BITS)`.  The latter is the former shifted by one.  Just making sure this is correct.",
              "createdAt": "2022-07-11T19:17:57Z",
              "updatedAt": "2022-07-11T19:31:18Z"
            },
            {
              "originalPosition": 173,
              "body": "`alpha` is the index being sharded here, right?  If so, it would be clearer to call it a bit string, not an integer, since that's how it is referred to above.  (Maybe internally to the function it is converted to an integer, but that doesn't really matter as long as all participants put the bits in the same order.)\r\n\r\nWhere do the `beta` values come from?  If they're computed from `alpha`, it seems like there's a missing step for that.  If they're constant / defined by the IDPF, then it seems like they can be treated as internal to the function, not arguments.",
              "createdAt": "2022-07-11T19:29:57Z",
              "updatedAt": "2022-07-11T19:31:18Z"
            },
            {
              "originalPosition": 233,
              "body": "```suggestion\r\n```",
              "createdAt": "2022-07-11T19:30:34Z",
              "updatedAt": "2022-07-11T19:31:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc49ryz1",
          "commit": {
            "abbreviatedOid": "80904de"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-11T20:24:51Z",
          "updatedAt": "2022-07-11T20:24:52Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Right now the plan is for the test vectors to match a tag of the repo. For example, test_vec/01 will matches `draft-irtf-cfrg-vdaf-01`. Moreover, I plan to remove test vectors from old versions from the repo as changes are made. (See #100). Thus these \"in-between\" changes to the test vectors don't matter much for interop.",
              "createdAt": "2022-07-11T20:24:51Z",
              "updatedAt": "2022-07-11T20:24:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc49rzay",
          "commit": {
            "abbreviatedOid": "80904de"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-11T20:27:16Z",
          "updatedAt": "2022-07-11T20:27:16Z",
          "comments": [
            {
              "originalPosition": 202,
              "body": "Yes, nice catch.",
              "createdAt": "2022-07-11T20:27:16Z",
              "updatedAt": "2022-07-11T20:27:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc49rz0E",
          "commit": {
            "abbreviatedOid": "e3b465c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-11T20:28:52Z",
          "updatedAt": "2022-07-11T20:28:52Z",
          "comments": [
            {
              "originalPosition": 814,
              "body": "\u2764\ufe0f ",
              "createdAt": "2022-07-11T20:28:52Z",
              "updatedAt": "2022-07-11T20:28:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc49r3LW",
          "commit": {
            "abbreviatedOid": "e3b465c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-11T20:41:28Z",
          "updatedAt": "2022-07-11T20:41:28Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "The level SHOULD be in range `[0, BITS)`. Looking at all instances of \"BITS\" in the doc, I believe this is consistent. However I did spot a range bug in the definition of \"prefix\" below. Fixed now.",
              "createdAt": "2022-07-11T20:41:28Z",
              "updatedAt": "2022-07-11T20:41:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc49r3fm",
          "commit": {
            "abbreviatedOid": "e3b465c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-11T20:42:41Z",
          "updatedAt": "2022-07-11T20:42:42Z",
          "comments": [
            {
              "originalPosition": 233,
              "body": "Done, here and elsewhere.",
              "createdAt": "2022-07-11T20:42:41Z",
              "updatedAt": "2022-07-11T20:42:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc49r5IU",
          "commit": {
            "abbreviatedOid": "e3b465c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-11T20:49:13Z",
          "updatedAt": "2022-07-11T20:49:13Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "> `alpha` is the index being sharded here, right? If so, it would be clearer to call it a bit string, not an integer, since that's how it is referred to above. (Maybe internally to the function it is converted to an integer, but that doesn't really matter as long as all participants put the bits in the same order.)\r\n\r\n@schoppmp and I discussed this a bit and decided that `Unsigned` was the best representation of the input. A couple of alternatives:\r\n* `Bytes` - This is the most intuitive, however it has the problem of not being able to represent a bit strings whose length is not a multiple of 8. Of course we could consider requiring input strings be a multiple 8. This would probably be fine for most applications.\r\n* Define some sort of `BitString` type, perhaps even making use of ASN.1. We decided this would be a bit too complicated.\r\n \r\n> Where do the `beta` values come from? If they're computed from `alpha`, it seems like there's a missing step for that. If they're constant / defined by the IDPF, then it seems like they can be treated as internal to the function, not arguments.\r\n\r\nThe `beta` values are arbitrary and are picked by the caller. In `Poplar1`, they are chosen in a particular way.\r\n\r\n",
              "createdAt": "2022-07-11T20:49:13Z",
              "updatedAt": "2022-07-11T20:49:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc49sCWy",
          "commit": {
            "abbreviatedOid": "e3b465c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-11T21:29:10Z",
          "updatedAt": "2022-07-11T21:29:10Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "On the first point: I'm not overly picky here.  Maybe you could just say somewhere that the Unsigned value is the input bit string of length `BITS`, interpreted as a `BITS`-bit big-endian integer (or whatever, doesn't really matter).\r\n\r\nOn the second point: If they're (a) generated unilaterally by the caller and (b) not used elsewhere, they should get generated internally to `gen`, not passed in as arguments.",
              "createdAt": "2022-07-11T21:29:10Z",
              "updatedAt": "2022-07-11T21:29:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc49sEJf",
          "commit": {
            "abbreviatedOid": "e3b465c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-11T21:38:10Z",
          "updatedAt": "2022-07-11T21:38:10Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "> On the first point: I'm not overly picky here. Maybe you could just say somewhere that the Unsigned value is the input bit string of length `BITS`, interpreted as a `BITS`-bit big-endian integer (or whatever, doesn't really matter).\r\n\r\nYeah we should provide some guidance here, but at this point I'm not sure what to recommend here. Really any encoding is fine, so long as the application is consistent.\r\n\r\n\r\n> On the second point: If they're (a) generated unilaterally by the caller and (b) not used elsewhere, they should get generated internally to `gen`, not passed in as arguments.\r\n\r\nWell, one could imagine different applications for IDPFs that call for different values to be \"programmed\". For Poplar1, the programmed values are pairs `(1, k)` where `k` is a random field element used for verifying the output shares. When used in a plain DAF, there would be no need for the random field element. One could also imagine an application in which \"weighted\" inputs are used, i.e., rather than always output `1`, output some integer in range `[0, c)` chosen by the user.\r\n\r\nAnother thing to note is that the current IDPF syntax more or less matches the paper.\r\n",
              "createdAt": "2022-07-11T21:38:10Z",
              "updatedAt": "2022-07-11T21:38:10Z"
            }
          ]
        }
      ]
    },
    {
      "number": 98,
      "id": "PR_kwDOGKuqOc47JZzg",
      "title": "IdpfPoplar: Pack control bits more tightly in public share",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/98",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Merge #97 first.\r\n\r\nWhile at it, add the public share to the test vectors.",
      "createdAt": "2022-07-09T23:42:34Z",
      "updatedAt": "2022-08-26T18:34:16Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "a88e2cef27b754677e2a6c30bc1e070f75f9012a",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/84/2",
      "headRefOid": "2e86acce649d7f815e6bbac8b6415e4145f19e5b",
      "closedAt": "2022-07-11T21:05:37Z",
      "mergedAt": "2022-07-11T21:05:37Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "e2ab413e9268f8e0ea0630489d7c033c99a3749e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc49rlxL",
          "commit": {
            "abbreviatedOid": "67d213d"
          },
          "author": "divergentdave",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-11T19:33:07Z",
          "updatedAt": "2022-07-11T19:33:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 99,
      "id": "PR_kwDOGKuqOc47JaE8",
      "title": "Check that field elements are fully reduced while decoding",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/99",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #89.\r\nMerge #98 first.",
      "createdAt": "2022-07-09T23:55:38Z",
      "updatedAt": "2022-08-26T18:34:16Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "e2ab413e9268f8e0ea0630489d7c033c99a3749e",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/89",
      "headRefOid": "f612338b31b41382c9d6baae72d5fe2fbd12d076",
      "closedAt": "2022-07-11T21:13:02Z",
      "mergedAt": "2022-07-11T21:13:02Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "26365db5cbbc995c9a7daa1017505076fdf1bf02"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 100,
      "id": "PR_kwDOGKuqOc47Nmdx",
      "title": "Prepare to cut draft-02",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/100",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Merge #99 first.\r\n\r\nChanges for draft-02, including:\r\n\r\n* Bump VERSION\r\n* Update Change Log\r\n* Update test vectors",
      "createdAt": "2022-07-11T18:28:45Z",
      "updatedAt": "2022-08-26T18:34:16Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "26365db5cbbc995c9a7daa1017505076fdf1bf02",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/draft-02",
      "headRefOid": "ed7d2d40dc1f988a94f159dbc5843c5a1c866264",
      "closedAt": "2022-07-11T21:18:17Z",
      "mergedAt": "2022-07-11T21:18:17Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "5bfef02e11ac27de5106d013ce0c2e879f3883b4"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 104,
      "id": "PR_kwDOGKuqOc49Nd_O",
      "title": "Define codepoints for (V)DAFs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/104",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Partially addresses #102.\r\n\r\nEach (V)DAF defines a 32-bit codepoint used to uniquely identify it. The\r\ncurrent scheme is as follows:\r\n\r\n* The first 3 nibbles are used to identify the VDAF \"class\", e.g.,\r\n  Prio3Aes128 or Poplar1Aes128.\r\n* The remaining 5 nibbles are reserved for particular \"instances\",\r\n  e.g., Prio3Aes128Count, Prio3Aes128Sum, etc.\r\n\r\nWhile at it, incorporate the codepoints into domain separation tags\r\n(DSTs) in Prio3 and Poplar1. This is needed primarily for Prio3. (See\r\nissue#102.)",
      "createdAt": "2022-08-15T22:11:31Z",
      "updatedAt": "2022-08-26T18:34:16Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "5bfef02e11ac27de5106d013ce0c2e879f3883b4",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/102/codepoints",
      "headRefOid": "875da0e4804e03977a584ca39c3b563412078cc4",
      "closedAt": "2022-08-24T21:38:51Z",
      "mergedAt": "2022-08-24T21:38:51Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "0f5c636383acc6637bc837cd234cb2e1fd88087f"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> This seems good enough for now. We can always change the shape of these later on. One question I might consider asking is whether or not you want the draft version to be part of the DST, if it's not already, just in case things change over time.\r\n\r\nThe version (literally `b'vdaf-02'`) is the prefix of the DST :)\r\n",
          "createdAt": "2022-08-16T21:15:21Z",
          "updatedAt": "2022-08-16T21:15:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "\ud83e\udd86",
          "createdAt": "2022-08-16T21:16:00Z",
          "updatedAt": "2022-08-16T21:16:00Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't love the division of the algorithm identifier into high- and low-order nibbles. Why not just have two identifiers here, say a 2-byte VDAF class and a 4-byte algorithm identifier within that class? There crypto things we're dealing with here are so gigantic that a couple of bytes doesn't seem likely to be noticeable.\r\n\r\nPrio3 has a large class of variants; Poplar1 does not. In general I would expect many VDAFs to have no variants, and some to have many. I figured merging \"class\" and \"variant\" into the same codepoint would allow us to more fully utilize the codepoint space.\r\n\r\nAlternatively, we could make the codepoint 2 bytes for the class and then add more bytes as needed for VDAFs with lots of variants. This is doable, but might make the spec a bit more complicated. On balance I think I would prefer the current PR. What do you think @bifurcation?",
          "createdAt": "2022-08-23T16:15:38Z",
          "updatedAt": "2022-08-23T16:15:38Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "If you don't think that this variant pattern is going to be common for other VDAFs, then yeah, we shouldn't structure the code points around it.  But at the same time, you're not going to have 2^32 Prio variants, so I would suggest being a little more restrained, since (a) you're not going to have 2^20 Prio variants and (b) you can always grab more space later.  Maybe something like:\r\n\r\n* 0x00000000 - 0x000000FF - Prio variants\r\n* 0x00000100 - Poplar\r\n* 0xFFFF0000 - 0xFFFFFFFF reserved for private use\r\n\r\n(It is traditional to put reserved space at the high end, see, e.g., [TLS ciphersuites](https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4).) ",
          "createdAt": "2022-08-24T16:26:28Z",
          "updatedAt": "2022-08-24T16:26:28Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5AC-ii",
          "commit": {
            "abbreviatedOid": "d684990"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T17:33:42Z",
          "updatedAt": "2022-08-16T17:34:27Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "I think it'd be a good idea to reserve everything with the prefix `0x000` for testing, just in case someone has a test scenario that requires multiple fake (V)DAFs interacting somehow.",
              "createdAt": "2022-08-16T17:33:42Z",
              "updatedAt": "2022-08-16T17:34:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ADAcj",
          "commit": {
            "abbreviatedOid": "d684990"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T17:40:25Z",
          "updatedAt": "2022-08-16T17:40:25Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "We can probably do that. Once concern I have is that 32 bits might be too large. Typically codepoints are just 8-16 bits, in which case we wouldn't be able to afford allocating lots of space.",
              "createdAt": "2022-08-16T17:40:25Z",
              "updatedAt": "2022-08-16T17:40:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ADL4x",
          "commit": {
            "abbreviatedOid": "d684990"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T18:20:05Z",
          "updatedAt": "2022-08-16T18:20:06Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "Then reserving `0x000000XX` should suffice. ",
              "createdAt": "2022-08-16T18:20:05Z",
              "updatedAt": "2022-08-16T18:20:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ADOPP",
          "commit": {
            "abbreviatedOid": "d684990"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T18:28:28Z",
          "updatedAt": "2022-08-16T18:28:28Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "Will do.\u00a0First I want to see if anyone objects to 32 bits :)",
              "createdAt": "2022-08-16T18:28:28Z",
              "updatedAt": "2022-08-16T18:28:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5AD77Q",
          "commit": {
            "abbreviatedOid": "d684990"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "This seems good enough for now. We can always change the shape of these later on. One question I might consider asking is whether or not you want the draft version to be part of the DST, if it's not already, just in case things change over time.",
          "createdAt": "2022-08-16T21:02:43Z",
          "updatedAt": "2022-08-16T21:03:50Z",
          "comments": [
            {
              "originalPosition": 185,
              "body": "I would leave it as-is for now. I don't know see any reason why an application would want to be opinionated about the PRG, so it makes sense to me that we pick one or maybe two variants that work well for all.",
              "createdAt": "2022-08-16T21:02:43Z",
              "updatedAt": "2022-08-16T21:03:50Z"
            },
            {
              "originalPosition": 185,
              "body": "I would leave it as-is for now. I don't know see any reason why an application would want to be opinionated about the PRG, so it makes sense to me that we pick one or maybe two variants that work well for all.",
              "createdAt": "2022-08-16T21:02:45Z",
              "updatedAt": "2022-08-16T21:03:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5AEAZE",
          "commit": {
            "abbreviatedOid": "d684990"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T21:21:58Z",
          "updatedAt": "2022-08-16T21:21:59Z",
          "comments": [
            {
              "originalPosition": 185,
              "body": "I think there are a couple potential reasons for this:\r\n1. It's useful to be able to reuse existing primitives whenever possible. (For instance, @simon-friedberger found himself in the position of having to re-implement `PrgAes128` from primitives in NSS.) This suggests to me that there may eventually be a preference to build something from, say, HMAC. (HKDF is not particularly well suited here, given its relatively short output length.)\r\n2. In #32 we're discussing an alternative AES-based PRG. One might have a preference to stick with what we have today. (I hope not, though.)\r\n\r\nIn any case, we can cross this bridge later.",
              "createdAt": "2022-08-16T21:21:59Z",
              "updatedAt": "2022-08-16T21:21:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5AED1p",
          "commit": {
            "abbreviatedOid": "d684990"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T21:37:44Z",
          "updatedAt": "2022-08-16T21:37:44Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "Done",
              "createdAt": "2022-08-16T21:37:44Z",
              "updatedAt": "2022-08-16T21:37:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5AJaPV",
          "commit": {
            "abbreviatedOid": "6da1b7a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This seems fine, but could be aligned better with the usual patterns for IANA language.\r\n\r\nI don't love the division of the algorithm identifier into high- and low-order nibbles.  Why not just have two identifiers here, say a 2-byte VDAF class and a 4-byte algorithm identifier within that class?  There crypto things we're dealing with here are so gigantic that a couple of bytes doesn't seem likely to be noticeable.",
          "createdAt": "2022-08-17T18:21:11Z",
          "updatedAt": "2022-08-17T18:26:41Z",
          "comments": [
            {
              "originalPosition": 171,
              "body": "You probably want to structure this section a little differently.  You're providing instructions to IANA: Create X, Y, Z, registries; add entries to Q registry; etc.  So I would have a top-level summary here, and then a subsection for each registry you're creating / touching.  You should be able to basically copy/paste the prose you need from MLS:\r\n\r\nhttps://messaginglayersecurity.rocks/mls-protocol/draft-ietf-mls-protocol.html#name-iana-considerations",
              "createdAt": "2022-08-17T18:21:11Z",
              "updatedAt": "2022-08-17T18:26:41Z"
            },
            {
              "originalPosition": 176,
              "body": "The more common way to specify test code points is as a range, so `0x00000000 - 0x000000ff` here (as in the prose above).\r\n\r\nAlso, usually a reservation like this is made not just for testing, but for \"vendor specific usage\" -- whatever you want to do for your own products that you don't expect to generally interop.",
              "createdAt": "2022-08-17T18:21:56Z",
              "updatedAt": "2022-08-17T18:26:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5AhNpH",
          "commit": {
            "abbreviatedOid": "6da1b7a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-23T16:00:45Z",
          "updatedAt": "2022-08-23T16:00:46Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Good catch. I'm also going to bump the range to 0x00000000 - 0x0000FFFF so that there's more room for \"vendor specific usage\".",
              "createdAt": "2022-08-23T16:00:45Z",
              "updatedAt": "2022-08-23T16:00:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5AhTNa",
          "commit": {
            "abbreviatedOid": "6da1b7a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-23T16:15:35Z",
          "updatedAt": "2022-08-23T16:15:36Z",
          "comments": [
            {
              "originalPosition": 171,
              "body": "Thanks, @bifurcation! The immediate need for codepoints is to address #102. I filed #110 to address this later on.",
              "createdAt": "2022-08-23T16:15:35Z",
              "updatedAt": "2022-08-23T16:15:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 105,
      "id": "PR_kwDOGKuqOc49N8Gw",
      "title": "Prio3: Align spec with revised paper",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/105",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Partially addresses #102.\r\n\r\nA bug was found in [BBCGGI+19] that leads to an attack on the robustness\r\nof Prio3. The attack is based on an observation in Appendix A of the\r\npaper \"A New Paradigm for Collision-Free Hashing: Incrementality at\r\nReduced Cost\" from Bellare and Micciancio (Eurocrypt 1997). In short,\r\nthe attack allows a malicious Client to construct invalid input shares\r\nfor which the Aggregators would compute a `k_joint_rand` of its\r\nchoosing.\r\n\r\nThis bug was patched in Section 6.2.3 of\r\nhttps://eprint.iacr.org/archive/2019/188/20220727:184451 as follows:\r\nInstead of XORing joint randomness shares computed by the\r\nAggregators, `k_joint_rand` is computed by hashing the shares. This\r\nchange patches the Prio3 spec in kind.",
      "createdAt": "2022-08-16T02:05:11Z",
      "updatedAt": "2022-08-26T18:33:06Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "0f5c636383acc6637bc837cd234cb2e1fd88087f",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/102/bug-fix/1",
      "headRefOid": "529c503b922c164f23e4066a4eaaf880e880ab76",
      "closedAt": "2022-08-24T21:47:11Z",
      "mergedAt": "2022-08-24T21:47:11Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "adce91e25a235ce33c48b63587597e3d511cb81b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOGKuqOc5ACD1M",
          "commit": {
            "abbreviatedOid": "d99544a"
          },
          "author": "divergentdave",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T15:00:44Z",
          "updatedAt": "2022-08-16T15:00:44Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "I don't think this could work, as it would fall prey to the same attack. The attacker would still be able to choose an output value for the XOR operation, and then hash it before deriving the joint randomness elements it generates. Then, they could do the same Gaussian reduction to select shares that would result in the chosen XOR output. In effect, this change would just change the random oracle from expand_into_vec to derive_seed composed with expand_into_vec. We need to get rid of the linearity of the XOR operation entirely, as that's what gives the attacker an advantage.\r\n\r\nOne idea for an alternative scheme, with lower overhead: The client includes the joint randomness seed in each report, computed as H(...H(H(H(share 1 || blinding nonce 1) || share 2 || blinding nonce 2) || share 3 || blinding nonce 3) ... || share n || blinding nonce n). The client also sends hash i-1 and hash i from this chain of hashes (if i-1 is in bounds) as part of each report i. Then, the aggregators use the joint randomness seed in their calculation, confirm that hash i == H(hash i-1 || share i || blinding nonce n) based on the view of its report share, and broadcast hash i-1 and hash i from its report share, along with the joint randomness seed they used. During preprocessing, the leader verifies that each aggregator reported that its check of the next hash evaluation was valid on its report share, verifies that all consecutive aggregators agree on their views of successive hash values, and that each aggregator's view of the joint randomness seed was equal to the final hash value. This would only require sending 2 or 3 seeds in each direction, rather than n-1. (This could probably be optimized a bit more, but it follows the guideline of hashing everything to produce the public coin)",
              "createdAt": "2022-08-16T15:00:44Z",
              "updatedAt": "2022-08-16T15:00:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ACbzb",
          "commit": {
            "abbreviatedOid": "d99544a"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T15:54:21Z",
          "updatedAt": "2022-08-16T15:54:21Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "This seems like it would definitely improve communication overhead for large n, but in most applications I think we're still expecting n to be small, say 2 or 3.",
              "createdAt": "2022-08-16T15:54:21Z",
              "updatedAt": "2022-08-16T15:54:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5AC8J7",
          "commit": {
            "abbreviatedOid": "c2ea50c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T17:25:42Z",
          "updatedAt": "2022-08-16T17:25:43Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Filed https://github.com/cfrg/draft-irtf-cfrg-vdaf/issues/106.",
              "createdAt": "2022-08-16T17:25:42Z",
              "updatedAt": "2022-08-16T17:25:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ADBJL",
          "commit": {
            "abbreviatedOid": "c2ea50c"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T17:42:51Z",
          "updatedAt": "2022-08-16T18:13:15Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Don't you need to inserting the helper's joint_rand_parts at index `j+1`? Otherwise the first helper's joint rand part will be overwritten by the leader's, below, when you insert at index 0 on line 1464.",
              "createdAt": "2022-08-16T17:42:51Z",
              "updatedAt": "2022-08-16T18:13:15Z"
            },
            {
              "originalPosition": 105,
              "body": "Isn't `j+2` going to go past the end of `k_joint_rand_parts` most of the time?",
              "createdAt": "2022-08-16T17:53:03Z",
              "updatedAt": "2022-08-16T18:13:15Z"
            },
            {
              "originalPosition": 166,
              "body": "What do the enclosing `[]` denote on this line? `k_joint_rand_part` is already a `Bytes` (`def derive_seed(Prg, seed: Bytes, info: Bytes) -> bytes`), so can't it already be concatenated with the elements of `k_hint`?",
              "createdAt": "2022-08-16T18:07:02Z",
              "updatedAt": "2022-08-16T18:13:15Z"
            },
            {
              "originalPosition": 214,
              "body": "This isn't really an issue with this PR, but is there a reason these function declarations can't have type annotations on their arguments, like we do for `derive_seed` or `expand_into_vec` in the PRG section? It would be a big help to readers trying to understand if `k_joint_rand_parts` is a `Bytes` (all parts already concatenated) or a `[Bytes]` (each element is a part) or some other thing.",
              "createdAt": "2022-08-16T18:09:31Z",
              "updatedAt": "2022-08-16T18:13:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ADKnV",
          "commit": {
            "abbreviatedOid": "c2ea50c"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T18:15:32Z",
          "updatedAt": "2022-08-16T18:15:33Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "Oh, no, never mind, Python's slice operator doesn't care:\r\n```\r\nPython 3.10.6 (main, Aug  2 2022, 00:00:00) [GCC 12.1.1 20220507 (Red Hat 12.1.1-1)] on linux\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> the_list = [1, 2, 3]\r\n>>> the_list[100:]\r\n[]\r\n```\r\n",
              "createdAt": "2022-08-16T18:15:32Z",
              "updatedAt": "2022-08-16T18:15:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ADK6c",
          "commit": {
            "abbreviatedOid": "c2ea50c"
          },
          "author": "divergentdave",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T18:16:38Z",
          "updatedAt": "2022-08-16T18:16:38Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "The list's insert method shifts all later list elements to higher indices, so we won't lose the first helper's contribution.",
              "createdAt": "2022-08-16T18:16:38Z",
              "updatedAt": "2022-08-16T18:16:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ADLbn",
          "commit": {
            "abbreviatedOid": "c2ea50c"
          },
          "author": "tgeoghegan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T18:18:29Z",
          "updatedAt": "2022-08-16T18:18:29Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Oh, once again, I have misunderstood Python list semantics: `list.insert(0, val)` will put the new value at 0 and push existing values to the right. ",
              "createdAt": "2022-08-16T18:18:29Z",
              "updatedAt": "2022-08-16T18:18:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ADL41",
          "commit": {
            "abbreviatedOid": "c2ea50c"
          },
          "author": "divergentdave",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T18:20:05Z",
          "updatedAt": "2022-08-16T18:20:06Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "The plus operators here are acting as list concatenation -- the first and last arguments are slices of the k_hint list, so they are both lists of Bytes. The middle argument is a list literal, consisting of just the `k_join_rand_part` Bytes object.",
              "createdAt": "2022-08-16T18:20:06Z",
              "updatedAt": "2022-08-16T18:20:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ADYEK",
          "commit": {
            "abbreviatedOid": "c2ea50c"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-16T18:56:10Z",
          "updatedAt": "2022-08-16T18:56:10Z",
          "comments": [
            {
              "originalPosition": 214,
              "body": "There's no rhyme or reason for this. I'm happy to add type hints here.\r\n",
              "createdAt": "2022-08-16T18:56:10Z",
              "updatedAt": "2022-08-16T18:56:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5AI9yX",
          "commit": {
            "abbreviatedOid": "4f569cb"
          },
          "author": "divergentdave",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-08-17T16:48:51Z",
          "updatedAt": "2022-08-17T16:49:05Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Nit: this import is unused now\r\n```suggestion\r\n                           gen_rand, vec_add, vec_sub, zeros\r\n```",
              "createdAt": "2022-08-17T16:48:51Z",
              "updatedAt": "2022-08-17T16:49:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOGKuqOc5ApOhT",
          "commit": {
            "abbreviatedOid": "4f569cb"
          },
          "author": "cjpatton",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-08-24T21:46:36Z",
          "updatedAt": "2022-08-24T21:46:36Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Done!",
              "createdAt": "2022-08-24T21:46:36Z",
              "updatedAt": "2022-08-24T21:46:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 107,
      "id": "PR_kwDOGKuqOc49RSq_",
      "title": "Editorial feedback from HCG",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/107",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on #105 (merge that first).\r\nPartially addresses #102.",
      "createdAt": "2022-08-16T18:27:25Z",
      "updatedAt": "2022-08-26T18:33:04Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "adce91e25a235ce33c48b63587597e3d511cb81b",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/102/editorial",
      "headRefOid": "66d2df00e91f4d27f97d33197a83e454bb2ef6f2",
      "closedAt": "2022-08-24T21:50:31Z",
      "mergedAt": "2022-08-24T21:50:31Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "7502ea4daf0cd4775d060e026ef5493e66f6acd0"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 108,
      "id": "PR_kwDOGKuqOc49SOmQ",
      "title": "Prio3: prep_init(): Remove intermediate `k_query_rand`",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/108",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on #107 (merge that first).\r\n\r\nInstead, derive the query randomness from `verify_key` directly.",
      "createdAt": "2022-08-17T00:25:28Z",
      "updatedAt": "2022-08-26T18:33:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "7502ea4daf0cd4775d060e026ef5493e66f6acd0",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/draft03/1",
      "headRefOid": "f71ed01a8a48714d1d7ae2f45c3edea5f9ef0999",
      "closedAt": "2022-08-24T21:52:50Z",
      "mergedAt": "2022-08-24T21:52:50Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "caee9bc8cb8eef7e747e626e2fe539c93f961f33"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 111,
      "id": "PR_kwDOGKuqOc49q3r7",
      "title": "Generate test vectors for draft 03",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/111",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on #108 (merge that first).",
      "createdAt": "2022-08-23T19:58:18Z",
      "updatedAt": "2022-08-26T18:33:02Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "caee9bc8cb8eef7e747e626e2fe539c93f961f33",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/draft03/2",
      "headRefOid": "477f0b851435effe16ef194e29b034fbe2221319",
      "closedAt": "2022-08-24T22:10:03Z",
      "mergedAt": "2022-08-24T22:10:03Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "21569b2e9479ca81b98c3f8ac3a15fd03ddbf250"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 112,
      "id": "PR_kwDOGKuqOc49wNy2",
      "title": "Misc changes for draft 03",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-vdaf/pull/112",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-08-24T22:30:15Z",
      "updatedAt": "2022-08-26T18:33:01Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "baseRefName": "main",
      "baseRefOid": "21569b2e9479ca81b98c3f8ac3a15fd03ddbf250",
      "headRepository": "cfrg/draft-irtf-cfrg-vdaf",
      "headRefName": "cjpatton/draft03/3",
      "headRefOid": "8ffb03fe2fdc9101aeda7e042aa443c9d7ba0e8b",
      "closedAt": "2022-08-24T22:35:58Z",
      "mergedAt": "2022-08-24T22:35:58Z",
      "mergedBy": "cjpatton",
      "mergeCommit": {
        "oid": "74d8d23666896a7609712ca384e287557a905398"
      },
      "comments": [],
      "reviews": []
    }
  ]
}